{
  "address": "0xaDCbFdA02931eEE74a6AeC0106cFd48ACa90cA6E",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "exists",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "ArchaeologistProfileExistsShouldBe",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getArchaeologistProfile",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "maximumRewrapInterval",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumResurrectionTime",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "peerId",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "minimumDiggingFeePerSecond",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "freeBond",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cursedBond",
              "type": "uint256"
            }
          ],
          "internalType": "struct LibTypes.ArchaeologistProfile",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "getArchaeologistProfileAddressAtIndex",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getArchaeologistProfileAddresses",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "addresses",
          "type": "address[]"
        }
      ],
      "name": "getArchaeologistProfiles",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "maximumRewrapInterval",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumResurrectionTime",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "peerId",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "minimumDiggingFeePerSecond",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "freeBond",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cursedBond",
              "type": "uint256"
            }
          ],
          "internalType": "struct LibTypes.ArchaeologistProfile[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getArchaeologistSarcophagi",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getCursedBond",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCursedBondPercentage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getEmbalmerClaimWindow",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "embalmer",
          "type": "address"
        }
      ],
      "name": "getEmbalmerSarcophagi",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getExpirationThreshold",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getFreeBond",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getGracePeriod",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProtocolFeeBasePercentage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "getRecipientSarcophagi",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getRewards",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "getSarcophagus",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "resurrectionTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "previousRewrapTime",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "isCompromised",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isCleaned",
              "type": "bool"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "uint8",
              "name": "threshold",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "maximumRewrapInterval",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumResurrectionTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cursedBondPercentage",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "arweaveTxId",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "embalmerAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipientAddress",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "archaeologistAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint8",
              "name": "publishedPrivateKeyCount",
              "type": "uint8"
            },
            {
              "internalType": "bool",
              "name": "hasLockedBond",
              "type": "bool"
            }
          ],
          "internalType": "struct ViewStateFacet.SarcophagusResponse",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getSarcophagusArchaeologist",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "diggingFeePerSecond",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "privateKey",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "publicKey",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "isAccused",
              "type": "bool"
            }
          ],
          "internalType": "struct LibTypes.CursedArchaeologist",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTotalProtocolFees",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x22f4c6c578d91a826ca5a842664427065bb3d729a19e377735e174b2ede73d47",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xDa863f802Cc8CBA3C436bF801BD7785d9E7d4F36",
    "contractAddress": null,
    "transactionIndex": 68,
    "gasUsed": "1873907",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x3a5dc785be5271b1c3e6eb0cfe1f5458d5e79ea05a17f866d32c573a8b58a777",
    "transactionHash": "0x22f4c6c578d91a826ca5a842664427065bb3d729a19e377735e174b2ede73d47",
    "logs": [],
    "blockNumber": 8783815,
    "cumulativeGasUsed": "13369414",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 4,
  "solcInputHash": "50efe6a3d8d462e9abce44badd6273ba",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"ArchaeologistProfileExistsShouldBe\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getArchaeologistProfile\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFeePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cursedBond\",\"type\":\"uint256\"}],\"internalType\":\"struct LibTypes.ArchaeologistProfile\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getArchaeologistProfileAddressAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getArchaeologistProfileAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getArchaeologistProfiles\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFeePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cursedBond\",\"type\":\"uint256\"}],\"internalType\":\"struct LibTypes.ArchaeologistProfile[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getArchaeologistSarcophagi\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getCursedBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCursedBondPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEmbalmerClaimWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"embalmer\",\"type\":\"address\"}],\"name\":\"getEmbalmerSarcophagi\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExpirationThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getFreeBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGracePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolFeeBasePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"getRecipientSarcophagi\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"getSarcophagus\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"resurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousRewrapTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCompromised\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCleaned\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"threshold\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cursedBondPercentage\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"arweaveTxId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"embalmerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"archaeologistAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"publishedPrivateKeyCount\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hasLockedBond\",\"type\":\"bool\"}],\"internalType\":\"struct ViewStateFacet.SarcophagusResponse\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getSarcophagusArchaeologist\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"diggingFeePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"isAccused\",\"type\":\"bool\"}],\"internalType\":\"struct LibTypes.CursedArchaeologist\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalProtocolFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getArchaeologistProfile(address)\":{\"params\":{\"archaeologist\":\"The archaeologist account's address\"},\"returns\":{\"_0\":\"the Archaeologist object\"}},\"getArchaeologistProfileAddressAtIndex(uint256)\":{\"params\":{\"index\":\"The index of the registered archaeologist\"},\"returns\":{\"_0\":\"address of the archaeologist\"}},\"getArchaeologistProfileAddresses()\":{\"returns\":{\"_0\":\"addresses of registered archaeologists\"}},\"getArchaeologistProfiles(address[])\":{\"params\":{\"addresses\":\"The list of archaeologist addresses\"},\"returns\":{\"_0\":\"The list of archaeologist profiles\"}},\"getArchaeologistSarcophagi(address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose sarcophagi are being returned\"}},\"getCursedBond(address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose cursed bond is being returned\"}},\"getCursedBondPercentage()\":{\"returns\":{\"_0\":\"The cursed bond percentage - cursedBondPercentage\"}},\"getEmbalmerClaimWindow()\":{\"returns\":{\"_0\":\"The embalmer claim window\"}},\"getEmbalmerSarcophagi(address)\":{\"params\":{\"embalmer\":\"The address of the embalmer whose sarcophagi are being returned\"}},\"getExpirationThreshold()\":{\"returns\":{\"_0\":\"The expiration threshold\"}},\"getFreeBond(address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose free bond is being returned\"}},\"getGracePeriod()\":{\"returns\":{\"_0\":\"The resurrection grace period\"}},\"getProtocolFeeBasePercentage()\":{\"returns\":{\"_0\":\"The protocol fee base percentage - protocolFeeBasePercentage\"}},\"getRecipientSarcophagi(address)\":{\"params\":{\"recipient\":\"The address of the recipient whose sarcophagi are being returned\"}},\"getRewards(address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose reward is being returned\"}},\"getSarcophagus(bytes32)\":{\"params\":{\"sarcoId\":\"The identifier of the sarcophagus being returned\"}},\"getSarcophagusArchaeologist(bytes32,address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose data is being returned\",\"sarcoId\":\"The identifier of the sarcophagus whose data is being returned\"}},\"getTotalProtocolFees()\":{\"returns\":{\"_0\":\"The total protocol fees\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getArchaeologistProfile(address)\":{\"notice\":\"Given an archaeologist address, return that archaeologist's profile\"},\"getArchaeologistProfileAddressAtIndex(uint256)\":{\"notice\":\"Given an index (of the full archaeologist array), return the archaeologist address at that index\"},\"getArchaeologistProfileAddresses()\":{\"notice\":\"Return the list of registereed archaeologist addresses.\"},\"getArchaeologistProfiles(address[])\":{\"notice\":\"Gets archaeologist profiles given a list of archaeologist addresses. If an invalid address is included, simply leaves it out of the list.\"},\"getArchaeologistSarcophagi(address)\":{\"notice\":\"Given an archaeologist's address, returns the identifiers of all sarcophagi that the archaeologist has participated in.\"},\"getCursedBond(address)\":{\"notice\":\"Returns the amount of cursed bond stored in the contract for an archaeologist.\"},\"getCursedBondPercentage()\":{\"notice\":\"Get the cursed bond percentage from the contract.\"},\"getEmbalmerClaimWindow()\":{\"notice\":\"Gets the window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\"},\"getEmbalmerSarcophagi(address)\":{\"notice\":\"Given an embalmer's address, returns the identifiers of all sarcophagi that the embalmer has created.\"},\"getExpirationThreshold()\":{\"notice\":\"Gets the expiration threshold after which a sarcophagus must be renegotiated\"},\"getFreeBond(address)\":{\"notice\":\"Returns the amount of free bond stored in the contract for an archaeologist.\"},\"getGracePeriod()\":{\"notice\":\"Gets the grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time passes\"},\"getProtocolFeeBasePercentage()\":{\"notice\":\"Get the protocol fee base percentage from the contract.\"},\"getRecipientSarcophagi(address)\":{\"notice\":\"Given a recipient's address, returns the identifiers of all sarcophagi that the recipient has participated in.\"},\"getRewards(address)\":{\"notice\":\"Returns the amount of rewards stored in the contract for an archaeologist.\"},\"getSarcophagus(bytes32)\":{\"notice\":\"Returns data on the sarcophagus with the supplied id includes aggregate data on cursed archaeologists associated with the sarcophagus     - publishedPrivateKeyCount - the total number of private keys published by archaeologists on the sarcophagus     - hasLockedBond - true if archaeologists still have bond locked in the contract for this sarcophagus\"},\"getSarcophagusArchaeologist(bytes32,address)\":{\"notice\":\"Returns the data stored on a sarcophagus for an archaeologist.\"},\"getTotalProtocolFees()\":{\"notice\":\"Gets the total protocol fees from the contract.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/ViewStateFacet.sol\":\"ViewStateFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"contracts/facets/EmbalmerFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\n\\ncontract EmbalmerFacet {\\n    /// @notice Emitted when a sarcophagus is created\\n    /// @param sarcoId Id of the new sarcophagus\\n    /// @param name Name of the new sarcophagus\\n    /// @param resurrectionTime Resurrection time of the new sarcophagus\\n    /// @param creationTime Creation time as set during negotiation, not the same as blocktime at which event is emitted\\n    /// @param embalmer Address of embalmer\\n    /// @param recipient Address of recipient\\n    /// @param cursedArchaeologists Array of addresses of cursed archaeologists\\n    /// @param totalDiggingFees Total digging fees charged to embalmer to create the sarcophagus\\n    /// @param arweaveTxId arweave tx id for the sarcophagus\\n    event CreateSarcophagus(\\n        bytes32 indexed sarcoId,\\n        string name,\\n        uint256 resurrectionTime,\\n        uint256 creationTime,\\n        address embalmer,\\n        address recipient,\\n        address[] cursedArchaeologists,\\n        uint256 totalDiggingFees,\\n        string arweaveTxId\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is rewrapped\\n    /// @param sarcoId Id of sarcophagus that was rewrapped\\n    /// @param resurrectionTime New resurrection time for the sarcophagus\\n    /// @param totalDiggingFees Total digging fees charged to the embalmer for the rewrap\\n    /// @param rewrapSarcophagusProtocolFees Total protocol fees charged to the embalmer for the rewrap\\n    event RewrapSarcophagus(\\n        bytes32 indexed sarcoId,\\n        uint256 resurrectionTime,\\n        uint256 totalDiggingFees,\\n        uint256 rewrapSarcophagusProtocolFees\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is buried\\n    /// @param sarcoId Id of sarcophagus that was buried\\n    event BurySarcophagus(bytes32 indexed sarcoId);\\n\\n    /// @notice Parameters of a sarcophagus, supplied during sarcophagus creation\\n    struct SarcophagusParams {\\n        string name;\\n        // highest rewrap interval cursed archaeologists have agreed to accept for lifetime of sarcophagus\\n        uint256 maximumRewrapInterval;\\n        // The timestamp beyond which the sarcophagus can no longer be rewrapped\\n        uint256 maximumResurrectionTime;\\n        address recipientAddress;\\n        uint256 resurrectionTime;\\n        uint8 threshold;\\n        uint256 creationTime;\\n    }\\n\\n    /// @notice Parameters of an archaeologist's curse, supplied during sarcophagus creation\\n    struct CurseParams {\\n        bytes publicKey;\\n        address archAddress;\\n        uint256 diggingFeePerSecond;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an id that is already in use\\n    /// @param sarcoId Id that is already in use\\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with expired parameters\\n    /// @param currentTime Timestamp of the failed create attempt\\n    /// @param creationTime Time when the sarcophagus parameters were created\\n    /// @param creationDeadline Deadline for creation of a sarcophagus with the supplied parameters\\n    error SarcophagusParametersExpired(\\n        uint256 currentTime,\\n        uint256 creationTime,\\n        uint256 creationDeadline\\n    );\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with no archaeologists\\n    error NoArchaeologistsProvided();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a shamir secret sharing threshold of 0\\n    error ThresholdCannotBeZero();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with more required archaeologists than total archaeologists\\n    error ThresholdGreaterThanTotalNumberOfArchaeologists(\\n        uint8 threshold,\\n        uint256 totalNumberOfArchaeologists\\n    );\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an archaeologist list that contains the same archaeologist more than once\\n    error ArchaeologistListContainsDuplicate(address archaeologistAddress);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that has already passed\\n    /// @param currentTime Timestamp of the failed rewrap attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a public key that has already been assigned to another sarcophagus\\n    /// @param publicKey the duplicated public key\\n    error DuplicatePublicKey(bytes publicKey);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that exceeds the maximum rewrap interval\\n    /// @param resurrectionTime Resurrection timestamp which is too far in the future\\n    /// @param sarcophagusMaximumRewrapInterval Maximum rewrap interval set for the sarcophagus\\n    /// @param maximumPermissibleResurrectionTime Resurrection timestamp which is too far in the future\\n    error ResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    /// @notice Emitted when the resurrection time defined during sarcohpagus creation or rewrap goes past the max resurrection time\\n    /// @param resurrectionTime The resurrection time defined during the sarcophagus creation or rewrap\\n    /// @param maxResurrectionTime The maximum allowed resurrection time\\n    error ResurrectionTimePastMaxResurrectionTime(\\n        uint256 resurrectionTime,\\n        uint256 maxResurrectionTime\\n    );\\n\\n    error NewResurrectionTimeInPast(uint256 currentTime, uint256 newResurrectionTime);\\n\\n    error NewResurrectionTimeIsZero();\\n\\n    error NewResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    error ResurrectionTimeTooFarPastPreviousResurrectionTime(\\n        uint256 resurrectionTime,\\n        uint256 previousResurrectionTime\\n    );\\n\\n    /// @notice Creates a sarcophagus with the supplied parameters and locks\\n    /// a portion of each archaeologist's freeBond equal to the digging fees calculated for the duration\\n    /// of the sarcophagus until its resurrection time.\\n    ///\\n    /// Verifies that each supplied archaeologist has signed off on the sarcophagus negotiation parameters:\\n    ///    - `publicKey` that matches the private key the archaeologist is responsible for\\n    ///    - `maximumRewrapInterval` to be enforced for the lifetime of the sarcophagus. No new resurrection time for future rewraps may exceed this interval from time of rewrap.\\n    ///    - `creationTime` of sarcophagus\\n    ///    - `diggingFeePerSecond` agreed to be paid to the archaeologist during the lifetime of the sarcophagus. Constant.\\n    ///\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param sarcophagusParams params to set on sarcophagus being created\\n    /// @param selectedArchaeologists the archaeologists the embalmer has selected to curse\\n    /// @param arweaveTxId id of tx storing the sarcophagus payload on arweave\\n    function createSarcophagus(\\n        bytes32 sarcoId,\\n        SarcophagusParams calldata sarcophagusParams,\\n        CurseParams[] calldata selectedArchaeologists,\\n        string calldata arweaveTxId\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Confirm that sarcophagus with supplied id doesn't already exist\\n        if (s.sarcophagi[sarcoId].resurrectionTime > 0) {\\n            revert SarcophagusAlreadyExists(sarcoId);\\n        }\\n\\n        // Ensure too much time hasn't passed since the sarcophagus `creationTime` that has been signed\\n        // off by its cursed archaeologists.\\n        if (block.timestamp > sarcophagusParams.creationTime + s.expirationThreshold) {\\n            revert SarcophagusParametersExpired(\\n                block.timestamp,\\n                sarcophagusParams.creationTime,\\n                sarcophagusParams.creationTime + s.expirationThreshold\\n            );\\n        }\\n\\n        // Confirm that resurrection time is in the future\\n        if (block.timestamp >= sarcophagusParams.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagusParams.resurrectionTime);\\n        }\\n\\n        // Confirm that resurrection or rewrap will occur before the maximumRewrapInterval elapses\\n        if (\\n            block.timestamp + sarcophagusParams.maximumRewrapInterval <\\n            sarcophagusParams.resurrectionTime\\n        ) {\\n            revert ResurrectionTimeTooFarInFuture(\\n                sarcophagusParams.resurrectionTime,\\n                sarcophagusParams.maximumRewrapInterval,\\n                block.timestamp + sarcophagusParams.maximumRewrapInterval\\n            );\\n        }\\n\\n        // Confirm that the resurrection time is less than the max resurrection time\\n        if (sarcophagusParams.resurrectionTime > sarcophagusParams.maximumResurrectionTime) {\\n            revert ResurrectionTimePastMaxResurrectionTime(\\n                sarcophagusParams.resurrectionTime,\\n                sarcophagusParams.maximumResurrectionTime\\n            );\\n        }\\n\\n        // Validate archaeologist and threshold lengths\\n        if (selectedArchaeologists.length == 0) {\\n            revert NoArchaeologistsProvided();\\n        }\\n\\n        if (sarcophagusParams.threshold == 0) {\\n            revert ThresholdCannotBeZero();\\n        }\\n\\n        // Ensure that k <= n in the effective k-of-n shamir secret sharing scheme\\n        // used to distribute keyshares among archaeologists\\n        if (sarcophagusParams.threshold > selectedArchaeologists.length) {\\n            revert ThresholdGreaterThanTotalNumberOfArchaeologists(\\n                sarcophagusParams.threshold,\\n                selectedArchaeologists.length\\n            );\\n        }\\n\\n        // create the sarcophagus\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n        sarcophagus.name = sarcophagusParams.name;\\n        sarcophagus.threshold = sarcophagusParams.threshold;\\n        sarcophagus.resurrectionTime = sarcophagusParams.resurrectionTime;\\n        sarcophagus.previousRewrapTime = sarcophagusParams.creationTime;\\n        sarcophagus.maximumRewrapInterval = sarcophagusParams.maximumRewrapInterval;\\n        sarcophagus.maximumResurrectionTime = sarcophagusParams.maximumResurrectionTime;\\n        sarcophagus.arweaveTxId = arweaveTxId;\\n        sarcophagus.embalmerAddress = msg.sender;\\n        sarcophagus.recipientAddress = sarcophagusParams.recipientAddress;\\n        sarcophagus.cursedArchaeologistAddresses = new address[](selectedArchaeologists.length);\\n        sarcophagus.cursedBondPercentage = s.cursedBondPercentage;\\n\\n        // track total digging fees due upon creation of sarcophagus\\n        uint256 totalDiggingFees = 0;\\n\\n        for (uint256 i = 0; i < selectedArchaeologists.length; i++) {\\n            LibUtils.revertIfArchProfileDoesNotExist(selectedArchaeologists[i].archAddress);\\n\\n            // Confirm archaeologist isn't already cursed on this sarcophagus (no duplicates)\\n            if (\\n                sarcophagus\\n                    .cursedArchaeologists[selectedArchaeologists[i].archAddress]\\n                    .publicKey\\n                    .length != 0\\n            ) {\\n                revert ArchaeologistListContainsDuplicate(selectedArchaeologists[i].archAddress);\\n            }\\n\\n            // Confirm archaeologist is not re-using a key pair\\n            if (\\n                s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] != address(0)\\n            ) {\\n                revert DuplicatePublicKey(selectedArchaeologists[i].publicKey);\\n            }\\n\\n            LibUtils.verifyArchaeologistSignature(\\n                sarcophagusParams.maximumRewrapInterval,\\n                sarcophagusParams.maximumResurrectionTime,\\n                sarcophagusParams.creationTime,\\n                selectedArchaeologists[i]\\n            );\\n\\n            // Curse the archaeologist on this sarcophagus\\n            uint256 diggingFeesDue = LibBonds.curseArchaeologist(\\n                sarcoId,\\n                selectedArchaeologists[i],\\n                i\\n            );\\n\\n            totalDiggingFees += diggingFeesDue;\\n\\n            // \\\"Consume\\\" this public key so it cannot be reused in the future\\n            s.publicKeyToArchaeologistAddress[\\n                selectedArchaeologists[i].publicKey\\n            ] = selectedArchaeologists[i].archAddress;\\n        }\\n\\n        // Add this sarcophagus id to the embalmer's record\\n        s.embalmerSarcophagi[msg.sender].push(sarcoId);\\n\\n        // Add this sarcophagus id to the recipient's record\\n        s.recipientSarcophagi[sarcophagusParams.recipientAddress].push(sarcoId);\\n\\n        // Transfer totalDiggingFees and the protocolFees in SARCO from embalmer to this contract\\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n        s.totalProtocolFees += protocolFees;\\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\\n\\n        emit CreateSarcophagus(\\n            sarcoId,\\n            sarcophagusParams.name,\\n            sarcophagusParams.resurrectionTime,\\n            sarcophagusParams.creationTime,\\n            msg.sender,\\n            sarcophagusParams.recipientAddress,\\n            sarcophagus.cursedArchaeologistAddresses,\\n            totalDiggingFees,\\n            arweaveTxId\\n        );\\n    }\\n\\n    /// @notice Updates the resurrectionTime on a sarcophagus. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param resurrectionTime the new resurrection time\\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        if (resurrectionTime == 0) {\\n            revert NewResurrectionTimeIsZero();\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n\\n        // Confirm resurrection time has not yet passed\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time is in future\\n        if (block.timestamp >= resurrectionTime) {\\n            revert NewResurrectionTimeInPast(block.timestamp, resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time doesn't exceed sarcophagus's maximumRewrapInterval\\n        if (block.timestamp + sarcophagus.maximumRewrapInterval < resurrectionTime) {\\n            revert NewResurrectionTimeTooFarInFuture(\\n                resurrectionTime,\\n                sarcophagus.maximumRewrapInterval,\\n                block.timestamp + sarcophagus.maximumRewrapInterval\\n            );\\n        }\\n\\n        // Confirm that the new resurrection time doesn't exceed the maximumResurrectionTime\\n        if (sarcophagus.maximumResurrectionTime < resurrectionTime) {\\n            revert ResurrectionTimePastMaxResurrectionTime(\\n                resurrectionTime,\\n                sarcophagus.maximumResurrectionTime\\n            );\\n        }\\n\\n        // track total digging fees to be paid by embalmer across all archaeologists on the sarcophagus\\n        uint256 totalDiggingFees = 0;\\n\\n        // pay digging fee to each cursed archaeologist on the sarcophagus that has not been accused\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        uint256 cursedBondPercentage = sarcophagus.cursedBondPercentage;\\n\\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n\\n            if (!cursedArchaeologist.isAccused) {\\n                uint256 prevDiggingFees = cursedArchaeologist.diggingFeePerSecond *\\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n                uint256 newDiggingFees = cursedArchaeologist.diggingFeePerSecond *\\n                    (resurrectionTime - block.timestamp);\\n\\n                // If the new digging fees are greater than the previous digging fees, we need to\\n                // increase the archaeologist's locked bond\\n                if (newDiggingFees > prevDiggingFees) {\\n                    uint256 cursedBondIncrease = ((newDiggingFees - prevDiggingFees) *\\n                        cursedBondPercentage) / 100;\\n\\n                    // If the previous cycle's rewards can't cover the cursed bond increase, revert\\n                    if (cursedBondIncrease > prevDiggingFees) {\\n                        revert ResurrectionTimeTooFarPastPreviousResurrectionTime(\\n                            resurrectionTime,\\n                            sarcophagus.resurrectionTime\\n                        );\\n                    }\\n\\n                    // Increase the archaeologist's cursed bond\\n                    s\\n                        .archaeologistProfiles[archaeologistAddresses[i]]\\n                        .cursedBond += cursedBondIncrease;\\n\\n                    // Rewards are now previous digging fees - difference\\n                    s.archaeologistRewards[archaeologistAddresses[i]] +=\\n                        prevDiggingFees -\\n                        cursedBondIncrease;\\n                } else if (newDiggingFees < prevDiggingFees) {\\n                    uint256 cursedBondDecrease = ((prevDiggingFees - newDiggingFees) *\\n                        cursedBondPercentage) / 100;\\n\\n                    // Decrease archaeologist's cursed bond by the difference\\n                    s\\n                        .archaeologistProfiles[archaeologistAddresses[i]]\\n                        .cursedBond -= cursedBondDecrease;\\n\\n                    // Increase archaeologist's free bond by the difference\\n                    s\\n                        .archaeologistProfiles[archaeologistAddresses[i]]\\n                        .freeBond += cursedBondDecrease;\\n\\n                    // Rewards are equal to the previous digging fees\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\\n                } else {\\n                    // Rewards are equal to the previous digging fees\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\\n                }\\n\\n                // Add digging fees due for the new interval\\n                totalDiggingFees += newDiggingFees;\\n            }\\n        }\\n\\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n\\n        // Add the protocol fee to the total protocol fees in storage\\n        s.totalProtocolFees += protocolFees;\\n\\n        // Update the sarcophagus resurrectionTime and previousRewrapTime\\n        sarcophagus.resurrectionTime = resurrectionTime;\\n        sarcophagus.previousRewrapTime = block.timestamp;\\n\\n        // Transfer the new digging fees and protocol fees from embalmer to contract\\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\\n\\n        emit RewrapSarcophagus(sarcoId, resurrectionTime, totalDiggingFees, protocolFees);\\n    }\\n\\n    /// @notice Terminates a sarcophagus by setting its resurrection time to infinity and returning locked\\n    /// bonds to all innocent cursed archaeologists. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    function burySarcophagus(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n        // Confirm that the current resurrection time is in the future\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // for each archaeologist on the sarcophagus, unlock bond and pay digging fees\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n\\n            // if the archaeologist hasn't been accused transfer them their digging fees and return their locked bond\\n            if (!cursedArchaeologist.isAccused) {\\n                LibBonds.freeArchaeologist(sarcoId, archaeologistAddresses[i]);\\n            }\\n        }\\n\\n        // Set resurrection time to infinity\\n        sarcophagus.resurrectionTime = 2 ** 256 - 1;\\n\\n        emit BurySarcophagus(sarcoId);\\n    }\\n}\\n\",\"keccak256\":\"0xded9cc3f16abd24a19c0de22d20fd4827706e914a0e2de2e45e565c770a46556\",\"license\":\"Unlicense\"},\"contracts/facets/ThirdPartyFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport {LibDiamond} from \\\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\ncontract ThirdPartyFacet {\\n    event AccuseArchaeologist(\\n        bytes32 indexed sarcoId,\\n        address indexed accuser,\\n        uint256 totalSlashedBondDistributed,\\n        uint256 totalDiggingFeesDistributed,\\n        address[] indexed accusedArchAddresses\\n    );\\n\\n    event Clean(bytes32 indexed sarcoId, address indexed cleaner);\\n\\n    /// @notice Clean has been called on a sarcophagus that has already been cleaned\\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a private key on\\n    error SarcophagusAlreadyCleaned(bytes32 sarcoId);\\n\\n    /// @notice Clean has been called before the deadline for archaeologists to publish private keys has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param publishDeadline Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\\n    error TooEarlyForClean(uint256 currentTime, uint256 publishDeadline);\\n\\n    /// @notice Clean has been called by someone other than the admin or embalmer of the sarcophagus\\n    /// @param senderAddress Address of sender\\n    error SenderNotEmbalmerOrAdmin(address senderAddress);\\n\\n    /// @notice Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error EmbalmerClaimWindowPassed(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error TooEarlyForAdminClean(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Emitted when a third party attempts to accuse an archaeologist on a sarcophagus where the resurrection time has already passed\\n    /// @param currentTime Timestamp of the failed accuse attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when accuse is called with an unequal numbers of public keys and signatures\\n    /// @param signatures the number of signatures passed into the accuse call\\n    /// @param publicKeys the number of public keys passed into the accuse call\\n    error DifferentNumberOfSignaturesAndPublicKeys(uint256 signatures, uint256 publicKeys);\\n\\n    /// @notice Emitted when accuse is called with an invalid signature for the supplied sarcoId, paymentAddress, and publicKey\\n    /// @param sarcoId that should have been signed\\n    /// @param paymentAddress payment address that should have been signed\\n    /// @param publicKey publicKey that should be derived from signing key\\n    /// @param signature invalid signature\\n    error InvalidAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes publicKey,\\n        LibTypes.Signature signature\\n    );\\n\\n    /// @notice If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod,\\n    /// their locked bonds and diggingFees may be claimed by either the embalmer or the admin\\n    /// embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will\\n    /// be able to claim remaining locked bond and diggingFees\\n    /// @param sarcoId The identifier of the sarcophagus to clean\\n    function clean(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer or admin\\n        if (msg.sender != sarcophagus.embalmerAddress && msg.sender != LibDiamond.contractOwner()) {\\n            revert SenderNotEmbalmerOrAdmin(msg.sender);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not already been cleaned\\n        if (sarcophagus.isCleaned) {\\n            revert SarcophagusAlreadyCleaned(sarcoId);\\n        }\\n\\n        // Confirm that the resurrectionTime + gracePeriod have passed\\n        if (block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod) {\\n            revert TooEarlyForClean(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\\n        }\\n\\n        // if sender is embalmer, confirm current time is within embalmerClaimWindow\\n        if (\\n            msg.sender == sarcophagus.embalmerAddress &&\\n            block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert EmbalmerClaimWindowPassed(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // if sender is admin, confirm embalmerClaimWindow has passed\\n        if (\\n            msg.sender == LibDiamond.contractOwner() &&\\n            block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert TooEarlyForAdminClean(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // sum of locked bonds and digging fees for all archaeologists that have failed to publish private keys before publish deadline and have not been accused\\n        uint256 totalDiggingFeesAndLockedBonds = 0;\\n\\n        for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]];\\n\\n            // Punish archaeologists that failed to publish their private key in time\\n            if (!cursedArchaeologist.isAccused && cursedArchaeologist.privateKey == 0) {\\n                uint256 diggingFeesDue = cursedArchaeologist.diggingFeePerSecond *\\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n                uint256 cursedBondDue = (diggingFeesDue * sarcophagus.cursedBondPercentage) / 100;\\n                totalDiggingFeesAndLockedBonds += diggingFeesDue + cursedBondDue;\\n\\n                // slash the archaeologist's locked bond for the sarcophagus\\n                LibBonds.decreaseCursedBond(\\n                    sarcophagus.cursedArchaeologistAddresses[i],\\n                    cursedBondDue\\n                );\\n            }\\n        }\\n\\n        // Transfer total slashed locked bonds plus digging fees to the embalmer if they are the caller, otherwise add\\n        // this to the contract's protocol fees\\n        if (msg.sender == sarcophagus.embalmerAddress) {\\n            s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFeesAndLockedBonds);\\n        } else {\\n            s.totalProtocolFees += totalDiggingFeesAndLockedBonds;\\n        }\\n\\n        sarcophagus.isCleaned = true;\\n        emit Clean(sarcoId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id\\n     * and payment address generated with the leaked private keys\\n     * If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be\\n     * split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer\\n     *\\n     * If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus\\n     * state will be updated to Accused and bonds for all remaining unaccused archaeologists will be\\n     * returned\\n     *\\n     * @param sarcoId The identifier of the sarcophagus having leaked private keys\\n     * @param publicKeys an array of public keys corresponding to leaked private keys - order must match order of signatures\\n     * @param signatures an array of signatures of the sarcoId and payment address signed by the leaked private keys - order must match order of publicKeys\\n     * @param paymentAddress the address to which rewards should be sent if successful\\n     */\\n    function accuse(\\n        bytes32 sarcoId,\\n        bytes[] calldata publicKeys,\\n        LibTypes.Signature[] calldata signatures,\\n        address paymentAddress\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // verify that current time is not past resurrection time\\n        if (block.timestamp > sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        if (signatures.length != publicKeys.length) {\\n            revert DifferentNumberOfSignaturesAndPublicKeys(signatures.length, publicKeys.length);\\n        }\\n\\n        address[] memory accusedArchAddresses = new address[](signatures.length);\\n\\n        // track the combined locked bond across all archaeologists being accused in this call\\n        uint256 totalCursedBond = 0;\\n        uint256 accusalCount = 0;\\n        for (uint256 i = 0; i < signatures.length; i++) {\\n            if (\\n                !LibUtils.verifyAccusalSignature(\\n                    sarcoId,\\n                    paymentAddress,\\n                    publicKeys[i],\\n                    signatures[i]\\n                )\\n            ) {\\n                revert InvalidAccusalSignature(\\n                    sarcoId,\\n                    paymentAddress,\\n                    publicKeys[i],\\n                    signatures[i]\\n                );\\n            }\\n\\n            // look up the archaeologist responsible for the publicKey\\n            address accusedArchaeologistAddress = s.publicKeyToArchaeologistAddress[publicKeys[i]];\\n            LibTypes.CursedArchaeologist storage accusedArchaeologist = sarcophagus\\n                .cursedArchaeologists[accusedArchaeologistAddress];\\n\\n            // verify the accused archaeologist is cursed on the sarcophagus\\n            if (accusedArchaeologist.publicKey.length == 0) {\\n                revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\\n            }\\n\\n            // if the archaeologist has already been accused on this sarcophagus break without taking action\\n            if (accusedArchaeologist.isAccused) {\\n                break;\\n            }\\n\\n            // mark the archaeologist on the sarcophagus as having been accused\\n            accusedArchaeologist.isAccused = true;\\n            accusedArchAddresses[accusalCount++] = accusedArchaeologistAddress;\\n\\n            uint256 cursedBondDue = ((accusedArchaeologist.diggingFeePerSecond *\\n                (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime)) *\\n                sarcophagus.cursedBondPercentage) / 100;\\n\\n            totalCursedBond += cursedBondDue;\\n\\n            // Slash the offending archaeologists bond\\n            LibBonds.decreaseCursedBond(accusedArchaeologistAddress, cursedBondDue);\\n        }\\n\\n        // if none of the accusals were valid because the archaeologists have all already been accused, return without taking action\\n        if (accusalCount == 0) {\\n            return;\\n        }\\n\\n        // the sarcophagus is compromised if the current call has successfully accused the sss threshold of archaeologists\\n        if (accusalCount >= sarcophagus.threshold) {\\n            sarcophagus.isCompromised = true;\\n        } else {\\n            // if the current call hasn't resulted in at least sss threshold archaeologists being accused\\n            // check if total number of historical accusals on sarcophagus is greater than threshold\\n            uint256 totalAccusals = 0;\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                if (\\n                    sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    totalAccusals++;\\n                }\\n            }\\n            // the sarcophagus is compromised if k or more archaeologists have been accused over the lifetime of the sarcophagus\\n            if (totalAccusals >= sarcophagus.threshold) {\\n                sarcophagus.isCompromised = true;\\n            }\\n        }\\n\\n        // if k or more archaeologists have been accused over the lifetime of the sarcophagus, funds should\\n        // be returned to the remaining well behaved archaeologists\\n        if (sarcophagus.isCompromised) {\\n            // iterate through all archaeologist addresses on the sarcophagus\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                // if the archaeologist has never been accused, release their locked bond back to them\\n                if (\\n                    !sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    LibBonds.freeArchaeologist(\\n                        sarcoId,\\n                        sarcophagus.cursedArchaeologistAddresses[i]\\n                    );\\n                }\\n            }\\n        }\\n\\n        uint256 halfTotalCursedBond = totalCursedBond / 2;\\n        uint256 totalDiggingFees = totalCursedBond / (sarcophagus.cursedBondPercentage / 100);\\n        // transfer the cursed half, plus the current digging fees, to the embalmer\\n        s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFees + halfTotalCursedBond);\\n\\n        // transfer the other half of the cursed bond to the transaction caller\\n        s.sarcoToken.transfer(paymentAddress, halfTotalCursedBond);\\n\\n        emit AccuseArchaeologist(\\n            sarcoId,\\n            msg.sender,\\n            totalCursedBond,\\n            totalDiggingFees,\\n            accusedArchAddresses\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x1f62b0e9efa8f03c5b25e006f0586ac422fa411fc6e30255c6712251abc87215\",\"license\":\"Unlicense\"},\"contracts/facets/ViewStateFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport \\\"../libraries/LibUtils.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\n\\ncontract ViewStateFacet {\\n    /// @notice Gets the total protocol fees from the contract.\\n    /// @return The total protocol fees\\n    function getTotalProtocolFees() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.totalProtocolFees;\\n    }\\n\\n    /// @notice Get the protocol fee base percentage from the contract.\\n    /// @return The protocol fee base percentage - protocolFeeBasePercentage\\n    function getProtocolFeeBasePercentage() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.protocolFeeBasePercentage;\\n    }\\n\\n    /// @notice Get the cursed bond percentage from the contract.\\n    /// @return The cursed bond percentage - cursedBondPercentage\\n    function getCursedBondPercentage() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.cursedBondPercentage;\\n    }\\n\\n    /// @notice Gets archaeologist profiles given a list of archaeologist addresses.\\n    /// If an invalid address is included, simply leaves it out of the list.\\n    /// @param addresses The list of archaeologist addresses\\n    /// @return The list of archaeologist profiles\\n    function getArchaeologistProfiles(\\n        address[] memory addresses\\n    ) external view returns (LibTypes.ArchaeologistProfile[] memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.ArchaeologistProfile[] memory profiles = new LibTypes.ArchaeologistProfile[](\\n            addresses.length\\n        );\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            // Skip unregistered archaeologists\\n            if (s.archaeologistProfiles[addresses[i]].maximumRewrapInterval == 0) {\\n                continue;\\n            }\\n            profiles[i] = s.archaeologistProfiles[addresses[i]];\\n        }\\n\\n        return profiles;\\n    }\\n\\n    /// @notice Gets the grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time passes\\n    /// @return The resurrection grace period\\n    function getGracePeriod() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.gracePeriod;\\n    }\\n\\n    /// @notice Gets the window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\\n    /// @return The embalmer claim window\\n    function getEmbalmerClaimWindow() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.embalmerClaimWindow;\\n    }\\n\\n    /// @notice Gets the expiration threshold after which a sarcophagus must be renegotiated\\n    /// @return The expiration threshold\\n    function getExpirationThreshold() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.expirationThreshold;\\n    }\\n\\n    /// @notice Given an archaeologist address, return that archaeologist's\\n    /// profile\\n    /// @param archaeologist The archaeologist account's address\\n    /// @return the Archaeologist object\\n    function getArchaeologistProfile(\\n        address archaeologist\\n    ) external view returns (LibTypes.ArchaeologistProfile memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibUtils.revertIfArchProfileDoesNotExist(archaeologist);\\n        return s.archaeologistProfiles[archaeologist];\\n    }\\n\\n    /// @notice Return the list of registereed archaeologist addresses.\\n    /// @return addresses of registered archaeologists\\n    function getArchaeologistProfileAddresses() external view returns (address[] memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistProfileAddresses;\\n    }\\n\\n    /// @notice Given an index (of the full archaeologist array), return the\\n    /// archaeologist address at that index\\n    /// @param index The index of the registered archaeologist\\n    /// @return address of the archaeologist\\n    function getArchaeologistProfileAddressAtIndex(uint256 index) external view returns (address) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistProfileAddresses[index];\\n    }\\n\\n    /// @notice Returns the amount of free bond stored in the contract for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being returned\\n    function getFreeBond(address archaeologist) external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistProfiles[archaeologist].freeBond;\\n    }\\n\\n    /// @notice Returns the amount of rewards stored in the contract for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// reward is being returned\\n    function getRewards(address archaeologist) external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistRewards[archaeologist];\\n    }\\n\\n    /// @notice Returns the amount of cursed bond stored in the contract for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// cursed bond is being returned\\n    function getCursedBond(address archaeologist) external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistProfiles[archaeologist].cursedBond;\\n    }\\n\\n    // Only used in the ViewStateFacet to return statistics data.\\n    // Contains a list of sarcoIds for each category. We could simply return the counts of the\\n    // arrays but we are already storing the lists of sarcoIds so we may as well use them.\\n    struct ArchaeologistStatistics {\\n        uint256 successes;\\n        uint256 accusals;\\n        uint256 failures;\\n    }\\n\\n    struct SarcophagusResponse {\\n        uint256 resurrectionTime;\\n        uint256 previousRewrapTime;\\n        bool isCompromised;\\n        bool isCleaned;\\n        string name;\\n        uint8 threshold;\\n        uint256 maximumRewrapInterval;\\n        uint256 maximumResurrectionTime;\\n        uint256 cursedBondPercentage;\\n        string arweaveTxId;\\n        address embalmerAddress;\\n        address recipientAddress;\\n        address[] archaeologistAddresses;\\n        uint8 publishedPrivateKeyCount;\\n        bool hasLockedBond;\\n    }\\n\\n    /// @notice Returns data on the sarcophagus with the supplied id\\n    /// includes aggregate data on cursed archaeologists associated with the sarcophagus\\n    ///     - publishedPrivateKeyCount - the total number of private keys published by archaeologists on the sarcophagus\\n    ///     - hasLockedBond - true if archaeologists still have bond locked in the contract for this sarcophagus\\n    /// @param sarcoId The identifier of the sarcophagus being returned\\n    function getSarcophagus(bytes32 sarcoId) external view returns (SarcophagusResponse memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        uint8 publishedPrivateKeyCount = 0;\\n        bool hasLockedBond = false;\\n        for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n            // archaeologist has published a private key\\n            if (\\n                sarcophagus\\n                    .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                    .privateKey != 0\\n            ) {\\n                publishedPrivateKeyCount++;\\n            } else if (\\n                !sarcophagus\\n                    .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                    .isAccused &&\\n                !sarcophagus.isCompromised &&\\n                !sarcophagus.isCleaned &&\\n                sarcophagus.resurrectionTime != 2 ** 256 - 1\\n            ) {\\n                // if the sarcophagus is not compromised, buried, or cleaned and\\n                // one or more unaccused archaeologists hasn't published a private key there is locked bond on the sarcophagus\\n                hasLockedBond = true;\\n            }\\n        }\\n\\n        return\\n            SarcophagusResponse({\\n                resurrectionTime: sarcophagus.resurrectionTime,\\n                previousRewrapTime: sarcophagus.previousRewrapTime,\\n                isCompromised: sarcophagus.isCompromised,\\n                isCleaned: sarcophagus.isCleaned,\\n                name: sarcophagus.name,\\n                threshold: sarcophagus.threshold,\\n                maximumRewrapInterval: sarcophagus.maximumRewrapInterval,\\n                maximumResurrectionTime: sarcophagus.maximumResurrectionTime,\\n                cursedBondPercentage: sarcophagus.cursedBondPercentage,\\n                arweaveTxId: sarcophagus.arweaveTxId,\\n                embalmerAddress: sarcophagus.embalmerAddress,\\n                recipientAddress: sarcophagus.recipientAddress,\\n                archaeologistAddresses: sarcophagus.cursedArchaeologistAddresses,\\n                publishedPrivateKeyCount: publishedPrivateKeyCount,\\n                hasLockedBond: hasLockedBond\\n            });\\n    }\\n\\n    /// @notice Given an embalmer's address, returns the identifiers of all\\n    /// sarcophagi that the embalmer has created.\\n    /// @param embalmer The address of the embalmer whose sarcophagi are being\\n    /// returned\\n    function getEmbalmerSarcophagi(address embalmer) external view returns (bytes32[] memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.embalmerSarcophagi[embalmer];\\n    }\\n\\n    /// @notice Given an archaeologist's address, returns the identifiers of all\\n    /// sarcophagi that the archaeologist has participated in.\\n    /// @param archaeologist The address of the archaeologist whose sarcophagi\\n    /// are being returned\\n    function getArchaeologistSarcophagi(\\n        address archaeologist\\n    ) external view returns (bytes32[] memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistSarcophagi[archaeologist];\\n    }\\n\\n    /// @notice Given a recipient's address, returns the identifiers of all\\n    /// sarcophagi that the recipient has participated in.\\n    /// @param recipient The address of the recipient whose sarcophagi are being\\n    /// returned\\n    function getRecipientSarcophagi(address recipient) external view returns (bytes32[] memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.recipientSarcophagi[recipient];\\n    }\\n\\n    /// @notice Returns the data stored on a sarcophagus for an archaeologist.\\n    /// @param sarcoId The identifier of the sarcophagus whose data is being\\n    /// returned\\n    /// @param archaeologist The address of the archaeologist whose data is\\n    /// being returned\\n    function getSarcophagusArchaeologist(\\n        bytes32 sarcoId,\\n        address archaeologist\\n    ) external view returns (LibTypes.CursedArchaeologist memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.sarcophagi[sarcoId].cursedArchaeologists[archaeologist];\\n    }\\n}\\n\",\"keccak256\":\"0x7a99fb82fffe3f10efa64020f0c5f347cbbf18d08751dcb1fb23777270c354d2\",\"license\":\"Unlicense\"},\"contracts/libraries/LibBonds.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"./LibErrors.sol\\\";\\n\\nimport \\\"../facets/EmbalmerFacet.sol\\\";\\n\\nlibrary LibBonds {\\n    /// @notice Decreases the amount stored in the freeBond mapping for an\\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\\n    /// the amount.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being decreased\\n    /// @param amount The amount to decrease the free bond by\\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current free bond\\n        if (amount > s.archaeologistProfiles[archaeologist].freeBond) {\\n            revert LibErrors.NotEnoughFreeBond(\\n                s.archaeologistProfiles[archaeologist].freeBond,\\n                amount\\n            );\\n        }\\n\\n        // Decrease the free bond amount\\n        s.archaeologistProfiles[archaeologist].freeBond -= amount;\\n    }\\n\\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\\n    /// archaeologist, without respectively increasing their free bond.\\n    /// @param archaeologist The address of the archaeologist\\n    /// @param amount The amount to slash\\n    function decreaseCursedBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current cursed bond\\n        if (amount > s.archaeologistProfiles[archaeologist].cursedBond) {\\n            revert LibErrors.NotEnoughCursedBond(\\n                s.archaeologistProfiles[archaeologist].cursedBond,\\n                amount\\n            );\\n        }\\n\\n        s.archaeologistProfiles[archaeologist].cursedBond -= amount;\\n    }\\n\\n    /// @notice Bonds the archaeologist to a sarcophagus.\\n    /// This does the following:\\n    ///   - adds the archaeologist's curse params and address to the sarcophagus\\n    ///   - calculates digging fees to be locked and later paid to archaeologist\\n    ///   - locks this amount from archaeologist's free bond; increases cursedBond by same\\n    ///   - Adds the sarcophagus' id to the archaeologist's record of bonded sarcophagi\\n    /// @param sarcoId Id of the sarcophagus with which to curse the archaeologist\\n    /// @param archaeologist The archaologist to curse, with associated parameters of the curse\\n    ///\\n    /// @return the amount of digging fees due the embalmer for this curse\\n    function curseArchaeologist(\\n        bytes32 sarcoId,\\n        EmbalmerFacet.CurseParams calldata archaeologist,\\n        uint256 index\\n    ) internal returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        sarcophagus.cursedArchaeologists[archaeologist.archAddress] = LibTypes.CursedArchaeologist({\\n            publicKey: archaeologist.publicKey,\\n            privateKey: 0,\\n            isAccused: false,\\n            diggingFeePerSecond: archaeologist.diggingFeePerSecond\\n        });\\n        sarcophagus.cursedArchaeologistAddresses[index] = archaeologist.archAddress;\\n\\n        // Calculate digging fees due for this time period (creationTime/previousRewrapTime -> resurrectionTime)\\n        uint256 diggingFeesDue = archaeologist.diggingFeePerSecond *\\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n        // Use cursed bond percentage to determine how much bond to lock up\\n        uint256 bondToCurse = (diggingFeesDue * s.cursedBondPercentage) / 100;\\n\\n        decreaseFreeBond(archaeologist.archAddress, bondToCurse);\\n        s.archaeologistProfiles[archaeologist.archAddress].cursedBond += bondToCurse;\\n\\n        s.archaeologistSarcophagi[archaeologist.archAddress].push(sarcoId);\\n\\n        return diggingFeesDue;\\n    }\\n\\n    /// @notice Calculates and unlocks an archaeologist's cursed bond. Pays due digging fees to the archaeologist.\\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\\n    /// @param archaeologistAddress the address of the archaeologist to free\\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\\n            .sarcophagi[sarcoId]\\n            .cursedArchaeologists[archaeologistAddress];\\n\\n        uint256 diggingFeeAmount = cursedArchaeologist.diggingFeePerSecond *\\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n        uint256 cursedBondAmount = diggingFeeAmount * sarcophagus.cursedBondPercentage / 100;\\n\\n        decreaseCursedBond(archaeologistAddress, cursedBondAmount);\\n        s.archaeologistProfiles[archaeologistAddress].freeBond += cursedBondAmount;\\n        s.archaeologistRewards[archaeologistAddress] += diggingFeeAmount;\\n    }\\n}\\n\",\"keccak256\":\"0xb5473904e43e2e8ef1e4dec6f2665ce1820ee9ae672d17a32b30ab676224822f\",\"license\":\"Unlicense\"},\"contracts/libraries/LibErrors.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title A collection of Errors\\n * @notice This library defines all of the Errors that the Sarcophagus system\\n * uses.\\n */\\nlibrary LibErrors {\\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\\n\\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\\n\\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\\n\\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\\n\\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\\n\\n    error SarcophagusInactive(bytes32 sarcoId);\\n\\n    error SarcophagusCompromised(bytes32 sarcoId);\\n\\n    error SenderNotEmbalmer(address sender, address embalmer);\\n\\n    error InvalidSignature(\\n        // address recovered from signature via ecrecover\\n        address recoveredAddress,\\n        // address we expected to have signed the data\\n        address expectedAddress\\n    );\\n}\\n\",\"keccak256\":\"0xe2e2e99c7e608571b8d072ceacc037b744ca637ad66633af1c2f10e935eb8567\",\"license\":\"Unlicense\"},\"contracts/libraries/LibTypes.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title Types shared across facets for the Sarcophagus diamond\\n */\\nlibrary LibTypes {\\n    struct Sarcophagus {\\n        // Also used for existence checks -- does not exist if 0\\n        uint256 resurrectionTime;\\n        uint256 previousRewrapTime;\\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\\n        bool isCompromised;\\n        bool isCleaned;\\n        uint8 threshold;\\n        string name;\\n        uint256 maximumRewrapInterval;\\n        uint256 maximumResurrectionTime;\\n        string arweaveTxId;\\n        address embalmerAddress;\\n        address recipientAddress;\\n        address[] cursedArchaeologistAddresses;\\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\\n        uint256 cursedBondPercentage;\\n    }\\n\\n    struct CursedArchaeologist {\\n        uint256 diggingFeePerSecond;\\n        // Also used for publish checks -- has not published if 0\\n        bytes32 privateKey;\\n        // Also used for curse checks -- is not bonded if length is 0\\n        bytes publicKey;\\n        bool isAccused;\\n    }\\n\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    struct ArchaeologistProfile {\\n        // Also used for existence checks -- does not exist if 0\\n        uint256 maximumRewrapInterval;\\n        uint256 maximumResurrectionTime;\\n        string peerId;\\n        uint256 minimumDiggingFeePerSecond;\\n        uint256 freeBond;\\n        uint256 cursedBond;\\n    }\\n}\\n\",\"keccak256\":\"0xb6ded0e9a252560ab14a589c47df996bcf1f0b9cd4910aa1bf0da6fd01c99232\",\"license\":\"Unlicense\"},\"contracts/libraries/LibUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport \\\"../facets/ThirdPartyFacet.sol\\\";\\nimport \\\"./LibTypes.sol\\\";\\nimport \\\"../facets/EmbalmerFacet.sol\\\";\\n\\n/**\\n * @title Utility functions used within the Sarcophagus system\\n * @notice This library implements various functions that are used throughout\\n * Sarcophagus, mainly to DRY up the codebase\\n * @dev these functions are all stateless, public, pure/view\\n */\\nlibrary LibUtils {\\n    /**\\n     * @notice The archaeologist needs to sign off on two pieces of data\\n     * to guarantee their unrwap will be successful\\n     *\\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\\n     * @param curseParams parameters of curse signed by archaeologist\\n     */\\n    function verifyArchaeologistSignature(\\n        uint256 agreedMaximumRewrapInterval,\\n        uint256 maximumResurrectionTime,\\n        uint256 timestamp,\\n        EmbalmerFacet.CurseParams calldata curseParams\\n    ) internal pure {\\n        // Hash the hash of the data payload\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encode(\\n                        curseParams.publicKey,\\n                        agreedMaximumRewrapInterval,\\n                        maximumResurrectionTime,\\n                        curseParams.diggingFeePerSecond,\\n                        timestamp\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Generate the address from the signature.\\n        // ecrecover should always return a valid address.\\n        address recoveredAddress = ecrecover(\\n            messageHash,\\n            curseParams.v,\\n            curseParams.r,\\n            curseParams.s\\n        );\\n\\n        if (recoveredAddress != curseParams.archAddress) {\\n            revert LibErrors.InvalidSignature(recoveredAddress, curseParams.archAddress);\\n        }\\n    }\\n\\n    /// @notice Verifies that a signature and public key were created from the same private key\\n    /// @param sarcoId the sarcoId that was signed\\n    /// @param paymentAddress the payment address that was signed\\n    /// @param publicKey an uncompressed 65 byte secp256k1 public key\\n    /// @param signature signature on the sarco id and payment address\\n    /// @return true if the signature was signed by the private key corresponding to the supplied public key\\n    function verifyAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes calldata publicKey,\\n        LibTypes.Signature calldata signature\\n    ) internal pure returns (bool) {\\n        // removes the 0x04 prefix from an uncompressed public key\\n        bytes memory truncatedPublicKey = new bytes(publicKey.length - 1);\\n        for (uint256 i = 1; i < publicKey.length; i++) {\\n            truncatedPublicKey[i - 1] = publicKey[i];\\n        }\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(abi.encode(sarcoId, paymentAddress))\\n            )\\n        );\\n        // Use ecrecover to get the address that signed the message\\n        address signingAddress = ecrecover(messageHash, signature.v, signature.r, signature.s);\\n\\n        address publicKeyAddress = address(\\n            uint160(\\n                uint256(keccak256(truncatedPublicKey)) &\\n                    0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n            )\\n        );\\n\\n        return signingAddress == publicKeyAddress;\\n    }\\n\\n    /// @notice Checks if an archaeologist profile exists and\\n    /// reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check existence of\\n    function revertIfArchProfileExists(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval != 0) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Checks if an archaeologist profile doesn't exist and reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check lack of existence of\\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval == 0) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\\n    /// @param totalDiggingFees to be paid. Protocol fee is a percentage of this\\n    /// @return The protocol fees amount\\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 100;\\n    }\\n}\\n\",\"keccak256\":\"0xfb87b9c1495d1044d9bf70a5a67bcc6e798b6584159a3df9c5a0ab297c693612\",\"license\":\"Unlicense\"},\"contracts/storage/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\n/**\\n * Global diamond storage struct to be shared across facets\\n * TODO: Implement diamond storage pattern and consider splitting storage into facet specific structs\\n */\\nstruct AppStorage {\\n    // SARCO token contract\\n    IERC20 sarcoToken;\\n    // total protocol fees available to be withdrawn by the admin\\n    uint256 totalProtocolFees;\\n    /**\\n     * Protocol level admin configurations\\n     */\\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap\\n    uint256 protocolFeeBasePercentage;\\n    // % of digging fees archaeologists must have locked up per curse in cursed bond\\n    uint256 cursedBondPercentage;\\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time\\n    uint256 gracePeriod;\\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated\\n    uint256 expirationThreshold;\\n    // window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\\n    uint256 embalmerClaimWindow;\\n    // registered archaeologist addresses\\n    address[] archaeologistProfileAddresses;\\n    /**\\n     * Ownership mappings\\n     */\\n    // embalmer address => ids of sarcophagi they've created\\n    mapping(address => bytes32[]) embalmerSarcophagi;\\n    // archaeologist address =>  ids of sarcophagi they're protecting\\n    mapping(address => bytes32[]) archaeologistSarcophagi;\\n    // recipient address =>  ids of sarcophagi they're recipient on\\n    mapping(address => bytes32[]) recipientSarcophagi;\\n    // public key => archaeologist address\\n    mapping(bytes => address) publicKeyToArchaeologistAddress;\\n    // sarcophagus id => sarcophagus object\\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\\n    // archaeologist address => profile\\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\\n    // current balance of rewards available for the archaeologist to withdraw\\n    mapping(address => uint256) archaeologistRewards;\\n}\\n\\nlibrary LibAppStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"sarcophagus.storage.SarcophagusGoerliTest\\\");\\n\\n    function getAppStorage() internal pure returns (AppStorage storage s) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2afdc926b9a4dbe3e84abd27ab6111094c8a5265efa0a9bc3f67cab77f9cd4b3\",\"license\":\"Unlicense\"},\"hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x2205345e83eb86f5281f159a9215a096cb6d404782619f9b8e9d7a4a46c32a37\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506120e9806100206000396000f3fe608060405234801561001057600080fd5b50600436106101165760003560e01c80639c545639116100a2578063dbd1838811610071578063dbd1838814610331578063dc231f431461034f578063dcfcb9011461037f578063de116f061461039d578063ef60e4e7146103cd57610116565b80639c545639146102955780639fdaded1146102b3578063a9328dcc146102d1578063c34e9bff1461030157610116565b806357babbaf116100e957806357babbaf146101b757806379ee54f7146101e75780637aa9fd2f1461021757806387927ce6146102355780638fbd55d21461026557610116565b806331baea671461011b5780633fbb89301461013957806342e10bc8146101575780634d0b676714610187575b600080fd5b6101236103fd565b604051610130919061143e565b60405180910390f35b610141610415565b60405161014e9190611549565b60405180910390f35b610171600480360381019061016c91906115ab565b6104b2565b60405161017e9190611709565b60405180910390f35b6101a1600480360381019061019c91906115ab565b6105e7565b6040516101ae91906117f3565b60405180910390f35b6101d160048036038101906101cc9190611841565b61068d565b6040516101de919061187d565b60405180910390f35b61020160048036038101906101fc91906115ab565b6106e3565b60405161020e919061143e565b60405180910390f35b61021f61073a565b60405161022c919061143e565b60405180910390f35b61024f600480360381019061024a91906115ab565b610752565b60405161025c919061143e565b60405180910390f35b61027f600480360381019061027a91906115ab565b6107ac565b60405161028c919061143e565b60405180910390f35b61029d610806565b6040516102aa919061143e565b60405180910390f35b6102bb61081e565b6040516102c8919061143e565b60405180910390f35b6102eb60048036038101906102e691906119e0565b610836565b6040516102f89190611b74565b60405180910390f35b61031b600480360381019061031691906115ab565b610a77565b60405161032891906117f3565b60405180910390f35b610339610b1d565b604051610346919061143e565b60405180910390f35b61036960048036038101906103649190611bc2565b610b35565b6040516103769190611cd5565b60405180910390f35b610387610c73565b604051610394919061143e565b60405180910390f35b6103b760048036038101906103b29190611cf7565b610c8b565b6040516103c49190611f00565b60405180910390f35b6103e760048036038101906103e291906115ab565b6111a5565b6040516103f491906117f3565b60405180910390f35b60008061040861124b565b9050806006015491505090565b6060600061042161124b565b9050806007018054806020026020016040519081016040528092919081815260200182805480156104a757602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001906001019080831161045d575b505050505091505090565b6104ba611314565b60006104c461124b565b90506104cf83611278565b80600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060c0016040529081600082015481526020016001820154815260200160028201805461053f90611f51565b80601f016020809104026020016040519081016040528092919081815260200182805461056b90611f51565b80156105b85780601f1061058d576101008083540402835291602001916105b8565b820191906000526020600020905b81548152906001019060200180831161059b57829003601f168201915b505050505081526020016003820154815260200160048201548152602001600582015481525050915050919050565b606060006105f361124b565b905080600a0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561068057602002820191906000526020600020905b81548152602001906001019080831161066c575b5050505050915050919050565b60008061069861124b565b90508060070183815481106106b0576106af611f82565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b6000806106ee61124b565b905080600e0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054915050919050565b60008061074561124b565b9050806005015491505090565b60008061075d61124b565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154915050919050565b6000806107b761124b565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154915050919050565b60008061081161124b565b9050806001015491505090565b60008061082961124b565b9050806002015491505090565b6060600061084261124b565b90506000835167ffffffffffffffff8111156108615761086061189d565b5b60405190808252806020026020018201604052801561089a57816020015b610887611314565b81526020019060019003908161087f5790505b50905060005b8451811015610a6c57600083600d0160008784815181106108c4576108c3611f82565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001540315610a595782600d01600086838151811061092957610928611f82565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060c0016040529081600082015481526020016001820154815260200160028201805461099a90611f51565b80601f01602080910402602001604051908101604052809291908181526020018280546109c690611f51565b8015610a135780601f106109e857610100808354040283529160200191610a13565b820191906000526020600020905b8154815290600101906020018083116109f657829003601f168201915b505050505081526020016003820154815260200160048201548152602001600582015481525050828281518110610a4d57610a4c611f82565b5b60200260200101819052505b8080610a6490611fe0565b9150506108a0565b508092505050919050565b60606000610a8361124b565b90508060080160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015610b1057602002820191906000526020600020905b815481526020019060010190808311610afc575b5050505050915050919050565b600080610b2861124b565b9050806004015491505090565b610b3d61134a565b6000610b4761124b565b905080600c016000858152602001908152602001600020600a0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060800160405290816000820154815260200160018201548152602001600282018054610bcd90611f51565b80601f0160208091040260200160405190810160405280929190818152602001828054610bf990611f51565b8015610c465780601f10610c1b57610100808354040283529160200191610c46565b820191906000526020600020905b815481529060010190602001808311610c2957829003601f168201915b505050505081526020016003820160009054906101000a900460ff16151515158152505091505092915050565b600080610c7e61124b565b9050806003015491505090565b610c93611377565b6000610c9d61124b565b9050600081600c01600085815260200190815260200160002090506000816000015403610d0157836040517f018da688000000000000000000000000000000000000000000000000000000008152600401610cf89190612037565b60405180910390fd5b60008060005b8360090180549050811015610ece576000801b84600a016000866009018481548110610d3657610d35611f82565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001015414610db7578280610daf90612052565b935050610ebb565b83600a016000856009018381548110610dd357610dd2611f82565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160009054906101000a900460ff16158015610e6557508360020160009054906101000a900460ff16155b8015610e8057508360020160019054906101000a900460ff16155b8015610eb057507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff846000015414155b15610eba57600191505b5b8080610ec690611fe0565b915050610d07565b50604051806101e0016040528084600001548152602001846001015481526020018460020160009054906101000a900460ff16151581526020018460020160019054906101000a900460ff1615158152602001846003018054610f3090611f51565b80601f0160208091040260200160405190810160405280929190818152602001828054610f5c90611f51565b8015610fa95780601f10610f7e57610100808354040283529160200191610fa9565b820191906000526020600020905b815481529060010190602001808311610f8c57829003601f168201915b505050505081526020018460020160029054906101000a900460ff1660ff168152602001846004015481526020018460050154815260200184600b01548152602001846006018054610ffa90611f51565b80601f016020809104026020016040519081016040528092919081815260200182805461102690611f51565b80156110735780601f1061104857610100808354040283529160200191611073565b820191906000526020600020905b81548152906001019060200180831161105657829003601f168201915b505050505081526020018460070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018460080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018460090180548060200260200160405190810160405280929190818152602001828054801561118157602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611137575b505050505081526020018360ff168152602001821515815250945050505050919050565b606060006111b161124b565b90508060090160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561123e57602002820191906000526020600020905b81548152602001906001019080831161122a575b5050505050915050919050565b6000807f1464b352a39efde2dd07892d0f2f274ce8052e8749182fc4ead14ba82366194490508091505090565b600061128261124b565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015403611310576001826040517f2eeb357100000000000000000000000000000000000000000000000000000000815260040161130792919061208a565b60405180910390fd5b5050565b6040518060c001604052806000815260200160008152602001606081526020016000815260200160008152602001600081525090565b60405180608001604052806000815260200160008019168152602001606081526020016000151581525090565b604051806101e00160405280600081526020016000815260200160001515815260200160001515815260200160608152602001600060ff16815260200160008152602001600081526020016000815260200160608152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160608152602001600060ff1681526020016000151581525090565b6000819050919050565b61143881611425565b82525050565b6000602082019050611453600083018461142f565b92915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006114b082611485565b9050919050565b6114c0816114a5565b82525050565b60006114d283836114b7565b60208301905092915050565b6000602082019050919050565b60006114f682611459565b6115008185611464565b935061150b83611475565b8060005b8381101561153c57815161152388826114c6565b975061152e836114de565b92505060018101905061150f565b5085935050505092915050565b6000602082019050818103600083015261156381846114eb565b905092915050565b6000604051905090565b600080fd5b600080fd5b611588816114a5565b811461159357600080fd5b50565b6000813590506115a58161157f565b92915050565b6000602082840312156115c1576115c0611575565b5b60006115cf84828501611596565b91505092915050565b6115e181611425565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611621578082015181840152602081019050611606565b83811115611630576000848401525b50505050565b6000601f19601f8301169050919050565b6000611652826115e7565b61165c81856115f2565b935061166c818560208601611603565b61167581611636565b840191505092915050565b600060c08301600083015161169860008601826115d8565b5060208301516116ab60208601826115d8565b50604083015184820360408601526116c38282611647565b91505060608301516116d860608601826115d8565b5060808301516116eb60808601826115d8565b5060a08301516116fe60a08601826115d8565b508091505092915050565b600060208201905081810360008301526117238184611680565b905092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000819050919050565b61176a81611757565b82525050565b600061177c8383611761565b60208301905092915050565b6000602082019050919050565b60006117a08261172b565b6117aa8185611736565b93506117b583611747565b8060005b838110156117e65781516117cd8882611770565b97506117d883611788565b9250506001810190506117b9565b5085935050505092915050565b6000602082019050818103600083015261180d8184611795565b905092915050565b61181e81611425565b811461182957600080fd5b50565b60008135905061183b81611815565b92915050565b60006020828403121561185757611856611575565b5b60006118658482850161182c565b91505092915050565b611877816114a5565b82525050565b6000602082019050611892600083018461186e565b92915050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6118d582611636565b810181811067ffffffffffffffff821117156118f4576118f361189d565b5b80604052505050565b600061190761156b565b905061191382826118cc565b919050565b600067ffffffffffffffff8211156119335761193261189d565b5b602082029050602081019050919050565b600080fd5b600061195c61195784611918565b6118fd565b9050808382526020820190506020840283018581111561197f5761197e611944565b5b835b818110156119a857806119948882611596565b845260208401935050602081019050611981565b5050509392505050565b600082601f8301126119c7576119c6611898565b5b81356119d7848260208601611949565b91505092915050565b6000602082840312156119f6576119f5611575565b5b600082013567ffffffffffffffff811115611a1457611a1361157a565b5b611a20848285016119b2565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600060c083016000830151611a6d60008601826115d8565b506020830151611a8060208601826115d8565b5060408301518482036040860152611a988282611647565b9150506060830151611aad60608601826115d8565b506080830151611ac060808601826115d8565b5060a0830151611ad360a08601826115d8565b508091505092915050565b6000611aea8383611a55565b905092915050565b6000602082019050919050565b6000611b0a82611a29565b611b148185611a34565b935083602082028501611b2685611a45565b8060005b85811015611b625784840389528151611b438582611ade565b9450611b4e83611af2565b925060208a01995050600181019050611b2a565b50829750879550505050505092915050565b60006020820190508181036000830152611b8e8184611aff565b905092915050565b611b9f81611757565b8114611baa57600080fd5b50565b600081359050611bbc81611b96565b92915050565b60008060408385031215611bd957611bd8611575565b5b6000611be785828601611bad565b9250506020611bf885828601611596565b9150509250929050565b600081519050919050565b600082825260208201905092915050565b6000611c2982611c02565b611c338185611c0d565b9350611c43818560208601611603565b611c4c81611636565b840191505092915050565b60008115159050919050565b611c6c81611c57565b82525050565b6000608083016000830151611c8a60008601826115d8565b506020830151611c9d6020860182611761565b5060408301518482036040860152611cb58282611c1e565b9150506060830151611cca6060860182611c63565b508091505092915050565b60006020820190508181036000830152611cef8184611c72565b905092915050565b600060208284031215611d0d57611d0c611575565b5b6000611d1b84828501611bad565b91505092915050565b600060ff82169050919050565b611d3a81611d24565b82525050565b600082825260208201905092915050565b6000611d5c82611459565b611d668185611d40565b9350611d7183611475565b8060005b83811015611da2578151611d8988826114c6565b9750611d94836114de565b925050600181019050611d75565b5085935050505092915050565b60006101e083016000830151611dc860008601826115d8565b506020830151611ddb60208601826115d8565b506040830151611dee6040860182611c63565b506060830151611e016060860182611c63565b5060808301518482036080860152611e198282611647565b91505060a0830151611e2e60a0860182611d31565b5060c0830151611e4160c08601826115d8565b5060e0830151611e5460e08601826115d8565b50610100830151611e696101008601826115d8565b50610120830151848203610120860152611e838282611647565b915050610140830151611e9a6101408601826114b7565b50610160830151611eaf6101608601826114b7565b50610180830151848203610180860152611ec98282611d51565b9150506101a0830151611ee06101a0860182611d31565b506101c0830151611ef56101c0860182611c63565b508091505092915050565b60006020820190508181036000830152611f1a8184611daf565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611f6957607f821691505b602082108103611f7c57611f7b611f22565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611feb82611425565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361201d5761201c611fb1565b5b600182019050919050565b61203181611757565b82525050565b600060208201905061204c6000830184612028565b92915050565b600061205d82611d24565b915060ff82036120705761206f611fb1565b5b600182019050919050565b61208481611c57565b82525050565b600060408201905061209f600083018561207b565b6120ac602083018461186e565b939250505056fea26469706673582212200611af5f160b54f6f79ad820f85a299bb6d094a6c4d4ecdd51629cf72c2789c264736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101165760003560e01c80639c545639116100a2578063dbd1838811610071578063dbd1838814610331578063dc231f431461034f578063dcfcb9011461037f578063de116f061461039d578063ef60e4e7146103cd57610116565b80639c545639146102955780639fdaded1146102b3578063a9328dcc146102d1578063c34e9bff1461030157610116565b806357babbaf116100e957806357babbaf146101b757806379ee54f7146101e75780637aa9fd2f1461021757806387927ce6146102355780638fbd55d21461026557610116565b806331baea671461011b5780633fbb89301461013957806342e10bc8146101575780634d0b676714610187575b600080fd5b6101236103fd565b604051610130919061143e565b60405180910390f35b610141610415565b60405161014e9190611549565b60405180910390f35b610171600480360381019061016c91906115ab565b6104b2565b60405161017e9190611709565b60405180910390f35b6101a1600480360381019061019c91906115ab565b6105e7565b6040516101ae91906117f3565b60405180910390f35b6101d160048036038101906101cc9190611841565b61068d565b6040516101de919061187d565b60405180910390f35b61020160048036038101906101fc91906115ab565b6106e3565b60405161020e919061143e565b60405180910390f35b61021f61073a565b60405161022c919061143e565b60405180910390f35b61024f600480360381019061024a91906115ab565b610752565b60405161025c919061143e565b60405180910390f35b61027f600480360381019061027a91906115ab565b6107ac565b60405161028c919061143e565b60405180910390f35b61029d610806565b6040516102aa919061143e565b60405180910390f35b6102bb61081e565b6040516102c8919061143e565b60405180910390f35b6102eb60048036038101906102e691906119e0565b610836565b6040516102f89190611b74565b60405180910390f35b61031b600480360381019061031691906115ab565b610a77565b60405161032891906117f3565b60405180910390f35b610339610b1d565b604051610346919061143e565b60405180910390f35b61036960048036038101906103649190611bc2565b610b35565b6040516103769190611cd5565b60405180910390f35b610387610c73565b604051610394919061143e565b60405180910390f35b6103b760048036038101906103b29190611cf7565b610c8b565b6040516103c49190611f00565b60405180910390f35b6103e760048036038101906103e291906115ab565b6111a5565b6040516103f491906117f3565b60405180910390f35b60008061040861124b565b9050806006015491505090565b6060600061042161124b565b9050806007018054806020026020016040519081016040528092919081815260200182805480156104a757602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001906001019080831161045d575b505050505091505090565b6104ba611314565b60006104c461124b565b90506104cf83611278565b80600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060c0016040529081600082015481526020016001820154815260200160028201805461053f90611f51565b80601f016020809104026020016040519081016040528092919081815260200182805461056b90611f51565b80156105b85780601f1061058d576101008083540402835291602001916105b8565b820191906000526020600020905b81548152906001019060200180831161059b57829003601f168201915b505050505081526020016003820154815260200160048201548152602001600582015481525050915050919050565b606060006105f361124b565b905080600a0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561068057602002820191906000526020600020905b81548152602001906001019080831161066c575b5050505050915050919050565b60008061069861124b565b90508060070183815481106106b0576106af611f82565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b6000806106ee61124b565b905080600e0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054915050919050565b60008061074561124b565b9050806005015491505090565b60008061075d61124b565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154915050919050565b6000806107b761124b565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154915050919050565b60008061081161124b565b9050806001015491505090565b60008061082961124b565b9050806002015491505090565b6060600061084261124b565b90506000835167ffffffffffffffff8111156108615761086061189d565b5b60405190808252806020026020018201604052801561089a57816020015b610887611314565b81526020019060019003908161087f5790505b50905060005b8451811015610a6c57600083600d0160008784815181106108c4576108c3611f82565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001540315610a595782600d01600086838151811061092957610928611f82565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060c0016040529081600082015481526020016001820154815260200160028201805461099a90611f51565b80601f01602080910402602001604051908101604052809291908181526020018280546109c690611f51565b8015610a135780601f106109e857610100808354040283529160200191610a13565b820191906000526020600020905b8154815290600101906020018083116109f657829003601f168201915b505050505081526020016003820154815260200160048201548152602001600582015481525050828281518110610a4d57610a4c611f82565b5b60200260200101819052505b8080610a6490611fe0565b9150506108a0565b508092505050919050565b60606000610a8361124b565b90508060080160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015610b1057602002820191906000526020600020905b815481526020019060010190808311610afc575b5050505050915050919050565b600080610b2861124b565b9050806004015491505090565b610b3d61134a565b6000610b4761124b565b905080600c016000858152602001908152602001600020600a0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060800160405290816000820154815260200160018201548152602001600282018054610bcd90611f51565b80601f0160208091040260200160405190810160405280929190818152602001828054610bf990611f51565b8015610c465780601f10610c1b57610100808354040283529160200191610c46565b820191906000526020600020905b815481529060010190602001808311610c2957829003601f168201915b505050505081526020016003820160009054906101000a900460ff16151515158152505091505092915050565b600080610c7e61124b565b9050806003015491505090565b610c93611377565b6000610c9d61124b565b9050600081600c01600085815260200190815260200160002090506000816000015403610d0157836040517f018da688000000000000000000000000000000000000000000000000000000008152600401610cf89190612037565b60405180910390fd5b60008060005b8360090180549050811015610ece576000801b84600a016000866009018481548110610d3657610d35611f82565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001015414610db7578280610daf90612052565b935050610ebb565b83600a016000856009018381548110610dd357610dd2611f82565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160009054906101000a900460ff16158015610e6557508360020160009054906101000a900460ff16155b8015610e8057508360020160019054906101000a900460ff16155b8015610eb057507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff846000015414155b15610eba57600191505b5b8080610ec690611fe0565b915050610d07565b50604051806101e0016040528084600001548152602001846001015481526020018460020160009054906101000a900460ff16151581526020018460020160019054906101000a900460ff1615158152602001846003018054610f3090611f51565b80601f0160208091040260200160405190810160405280929190818152602001828054610f5c90611f51565b8015610fa95780601f10610f7e57610100808354040283529160200191610fa9565b820191906000526020600020905b815481529060010190602001808311610f8c57829003601f168201915b505050505081526020018460020160029054906101000a900460ff1660ff168152602001846004015481526020018460050154815260200184600b01548152602001846006018054610ffa90611f51565b80601f016020809104026020016040519081016040528092919081815260200182805461102690611f51565b80156110735780601f1061104857610100808354040283529160200191611073565b820191906000526020600020905b81548152906001019060200180831161105657829003601f168201915b505050505081526020018460070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018460080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018460090180548060200260200160405190810160405280929190818152602001828054801561118157602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611137575b505050505081526020018360ff168152602001821515815250945050505050919050565b606060006111b161124b565b90508060090160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561123e57602002820191906000526020600020905b81548152602001906001019080831161122a575b5050505050915050919050565b6000807f1464b352a39efde2dd07892d0f2f274ce8052e8749182fc4ead14ba82366194490508091505090565b600061128261124b565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015403611310576001826040517f2eeb357100000000000000000000000000000000000000000000000000000000815260040161130792919061208a565b60405180910390fd5b5050565b6040518060c001604052806000815260200160008152602001606081526020016000815260200160008152602001600081525090565b60405180608001604052806000815260200160008019168152602001606081526020016000151581525090565b604051806101e00160405280600081526020016000815260200160001515815260200160001515815260200160608152602001600060ff16815260200160008152602001600081526020016000815260200160608152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160608152602001600060ff1681526020016000151581525090565b6000819050919050565b61143881611425565b82525050565b6000602082019050611453600083018461142f565b92915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006114b082611485565b9050919050565b6114c0816114a5565b82525050565b60006114d283836114b7565b60208301905092915050565b6000602082019050919050565b60006114f682611459565b6115008185611464565b935061150b83611475565b8060005b8381101561153c57815161152388826114c6565b975061152e836114de565b92505060018101905061150f565b5085935050505092915050565b6000602082019050818103600083015261156381846114eb565b905092915050565b6000604051905090565b600080fd5b600080fd5b611588816114a5565b811461159357600080fd5b50565b6000813590506115a58161157f565b92915050565b6000602082840312156115c1576115c0611575565b5b60006115cf84828501611596565b91505092915050565b6115e181611425565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611621578082015181840152602081019050611606565b83811115611630576000848401525b50505050565b6000601f19601f8301169050919050565b6000611652826115e7565b61165c81856115f2565b935061166c818560208601611603565b61167581611636565b840191505092915050565b600060c08301600083015161169860008601826115d8565b5060208301516116ab60208601826115d8565b50604083015184820360408601526116c38282611647565b91505060608301516116d860608601826115d8565b5060808301516116eb60808601826115d8565b5060a08301516116fe60a08601826115d8565b508091505092915050565b600060208201905081810360008301526117238184611680565b905092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000819050919050565b61176a81611757565b82525050565b600061177c8383611761565b60208301905092915050565b6000602082019050919050565b60006117a08261172b565b6117aa8185611736565b93506117b583611747565b8060005b838110156117e65781516117cd8882611770565b97506117d883611788565b9250506001810190506117b9565b5085935050505092915050565b6000602082019050818103600083015261180d8184611795565b905092915050565b61181e81611425565b811461182957600080fd5b50565b60008135905061183b81611815565b92915050565b60006020828403121561185757611856611575565b5b60006118658482850161182c565b91505092915050565b611877816114a5565b82525050565b6000602082019050611892600083018461186e565b92915050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6118d582611636565b810181811067ffffffffffffffff821117156118f4576118f361189d565b5b80604052505050565b600061190761156b565b905061191382826118cc565b919050565b600067ffffffffffffffff8211156119335761193261189d565b5b602082029050602081019050919050565b600080fd5b600061195c61195784611918565b6118fd565b9050808382526020820190506020840283018581111561197f5761197e611944565b5b835b818110156119a857806119948882611596565b845260208401935050602081019050611981565b5050509392505050565b600082601f8301126119c7576119c6611898565b5b81356119d7848260208601611949565b91505092915050565b6000602082840312156119f6576119f5611575565b5b600082013567ffffffffffffffff811115611a1457611a1361157a565b5b611a20848285016119b2565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600060c083016000830151611a6d60008601826115d8565b506020830151611a8060208601826115d8565b5060408301518482036040860152611a988282611647565b9150506060830151611aad60608601826115d8565b506080830151611ac060808601826115d8565b5060a0830151611ad360a08601826115d8565b508091505092915050565b6000611aea8383611a55565b905092915050565b6000602082019050919050565b6000611b0a82611a29565b611b148185611a34565b935083602082028501611b2685611a45565b8060005b85811015611b625784840389528151611b438582611ade565b9450611b4e83611af2565b925060208a01995050600181019050611b2a565b50829750879550505050505092915050565b60006020820190508181036000830152611b8e8184611aff565b905092915050565b611b9f81611757565b8114611baa57600080fd5b50565b600081359050611bbc81611b96565b92915050565b60008060408385031215611bd957611bd8611575565b5b6000611be785828601611bad565b9250506020611bf885828601611596565b9150509250929050565b600081519050919050565b600082825260208201905092915050565b6000611c2982611c02565b611c338185611c0d565b9350611c43818560208601611603565b611c4c81611636565b840191505092915050565b60008115159050919050565b611c6c81611c57565b82525050565b6000608083016000830151611c8a60008601826115d8565b506020830151611c9d6020860182611761565b5060408301518482036040860152611cb58282611c1e565b9150506060830151611cca6060860182611c63565b508091505092915050565b60006020820190508181036000830152611cef8184611c72565b905092915050565b600060208284031215611d0d57611d0c611575565b5b6000611d1b84828501611bad565b91505092915050565b600060ff82169050919050565b611d3a81611d24565b82525050565b600082825260208201905092915050565b6000611d5c82611459565b611d668185611d40565b9350611d7183611475565b8060005b83811015611da2578151611d8988826114c6565b9750611d94836114de565b925050600181019050611d75565b5085935050505092915050565b60006101e083016000830151611dc860008601826115d8565b506020830151611ddb60208601826115d8565b506040830151611dee6040860182611c63565b506060830151611e016060860182611c63565b5060808301518482036080860152611e198282611647565b91505060a0830151611e2e60a0860182611d31565b5060c0830151611e4160c08601826115d8565b5060e0830151611e5460e08601826115d8565b50610100830151611e696101008601826115d8565b50610120830151848203610120860152611e838282611647565b915050610140830151611e9a6101408601826114b7565b50610160830151611eaf6101608601826114b7565b50610180830151848203610180860152611ec98282611d51565b9150506101a0830151611ee06101a0860182611d31565b506101c0830151611ef56101c0860182611c63565b508091505092915050565b60006020820190508181036000830152611f1a8184611daf565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611f6957607f821691505b602082108103611f7c57611f7b611f22565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611feb82611425565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361201d5761201c611fb1565b5b600182019050919050565b61203181611757565b82525050565b600060208201905061204c6000830184612028565b92915050565b600061205d82611d24565b915060ff82036120705761206f611fb1565b5b600182019050919050565b61208481611c57565b82525050565b600060408201905061209f600083018561207b565b6120ac602083018461186e565b939250505056fea26469706673582212200611af5f160b54f6f79ad820f85a299bb6d094a6c4d4ecdd51629cf72c2789c264736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getArchaeologistProfile(address)": {
        "params": {
          "archaeologist": "The archaeologist account's address"
        },
        "returns": {
          "_0": "the Archaeologist object"
        }
      },
      "getArchaeologistProfileAddressAtIndex(uint256)": {
        "params": {
          "index": "The index of the registered archaeologist"
        },
        "returns": {
          "_0": "address of the archaeologist"
        }
      },
      "getArchaeologistProfileAddresses()": {
        "returns": {
          "_0": "addresses of registered archaeologists"
        }
      },
      "getArchaeologistProfiles(address[])": {
        "params": {
          "addresses": "The list of archaeologist addresses"
        },
        "returns": {
          "_0": "The list of archaeologist profiles"
        }
      },
      "getArchaeologistSarcophagi(address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose sarcophagi are being returned"
        }
      },
      "getCursedBond(address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose cursed bond is being returned"
        }
      },
      "getCursedBondPercentage()": {
        "returns": {
          "_0": "The cursed bond percentage - cursedBondPercentage"
        }
      },
      "getEmbalmerClaimWindow()": {
        "returns": {
          "_0": "The embalmer claim window"
        }
      },
      "getEmbalmerSarcophagi(address)": {
        "params": {
          "embalmer": "The address of the embalmer whose sarcophagi are being returned"
        }
      },
      "getExpirationThreshold()": {
        "returns": {
          "_0": "The expiration threshold"
        }
      },
      "getFreeBond(address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose free bond is being returned"
        }
      },
      "getGracePeriod()": {
        "returns": {
          "_0": "The resurrection grace period"
        }
      },
      "getProtocolFeeBasePercentage()": {
        "returns": {
          "_0": "The protocol fee base percentage - protocolFeeBasePercentage"
        }
      },
      "getRecipientSarcophagi(address)": {
        "params": {
          "recipient": "The address of the recipient whose sarcophagi are being returned"
        }
      },
      "getRewards(address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose reward is being returned"
        }
      },
      "getSarcophagus(bytes32)": {
        "params": {
          "sarcoId": "The identifier of the sarcophagus being returned"
        }
      },
      "getSarcophagusArchaeologist(bytes32,address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose data is being returned",
          "sarcoId": "The identifier of the sarcophagus whose data is being returned"
        }
      },
      "getTotalProtocolFees()": {
        "returns": {
          "_0": "The total protocol fees"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getArchaeologistProfile(address)": {
        "notice": "Given an archaeologist address, return that archaeologist's profile"
      },
      "getArchaeologistProfileAddressAtIndex(uint256)": {
        "notice": "Given an index (of the full archaeologist array), return the archaeologist address at that index"
      },
      "getArchaeologistProfileAddresses()": {
        "notice": "Return the list of registereed archaeologist addresses."
      },
      "getArchaeologistProfiles(address[])": {
        "notice": "Gets archaeologist profiles given a list of archaeologist addresses. If an invalid address is included, simply leaves it out of the list."
      },
      "getArchaeologistSarcophagi(address)": {
        "notice": "Given an archaeologist's address, returns the identifiers of all sarcophagi that the archaeologist has participated in."
      },
      "getCursedBond(address)": {
        "notice": "Returns the amount of cursed bond stored in the contract for an archaeologist."
      },
      "getCursedBondPercentage()": {
        "notice": "Get the cursed bond percentage from the contract."
      },
      "getEmbalmerClaimWindow()": {
        "notice": "Gets the window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys"
      },
      "getEmbalmerSarcophagi(address)": {
        "notice": "Given an embalmer's address, returns the identifiers of all sarcophagi that the embalmer has created."
      },
      "getExpirationThreshold()": {
        "notice": "Gets the expiration threshold after which a sarcophagus must be renegotiated"
      },
      "getFreeBond(address)": {
        "notice": "Returns the amount of free bond stored in the contract for an archaeologist."
      },
      "getGracePeriod()": {
        "notice": "Gets the grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time passes"
      },
      "getProtocolFeeBasePercentage()": {
        "notice": "Get the protocol fee base percentage from the contract."
      },
      "getRecipientSarcophagi(address)": {
        "notice": "Given a recipient's address, returns the identifiers of all sarcophagi that the recipient has participated in."
      },
      "getRewards(address)": {
        "notice": "Returns the amount of rewards stored in the contract for an archaeologist."
      },
      "getSarcophagus(bytes32)": {
        "notice": "Returns data on the sarcophagus with the supplied id includes aggregate data on cursed archaeologists associated with the sarcophagus     - publishedPrivateKeyCount - the total number of private keys published by archaeologists on the sarcophagus     - hasLockedBond - true if archaeologists still have bond locked in the contract for this sarcophagus"
      },
      "getSarcophagusArchaeologist(bytes32,address)": {
        "notice": "Returns the data stored on a sarcophagus for an archaeologist."
      },
      "getTotalProtocolFees()": {
        "notice": "Gets the total protocol fees from the contract."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}