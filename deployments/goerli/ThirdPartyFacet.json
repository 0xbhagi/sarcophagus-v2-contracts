{
  "address": "0x573f94101a71DBe41abEDf8BCF85f0dE2068d20e",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "ArchaeologistNotOnSarcophagus",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "cursedBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "NotEnoughCursedBond",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusCompromised",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusInactive",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SarcophagusIsUnwrappable",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "accuser",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "accuserBondReward",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "embalmerBondReward",
          "type": "uint256"
        }
      ],
      "name": "AccuseArchaeologist",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "cleaner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "cleanerBondReward",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "embalmerBondReward",
          "type": "uint256"
        }
      ],
      "name": "CleanUpSarcophagus",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32[]",
          "name": "keyShareHashes",
          "type": "bytes32[]"
        },
        {
          "internalType": "address",
          "name": "paymentAddress",
          "type": "address"
        }
      ],
      "name": "accuse",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "args": [],
  "numDeployments": 4,
  "solcInputHash": "24da3a57fc1d823ed9295677fe86dbd6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"ArchaeologistNotOnSarcophagus\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cursedBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotEnoughCursedBond\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusCompromised\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusInactive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SarcophagusIsUnwrappable\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accuser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accuserBondReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"embalmerBondReward\",\"type\":\"uint256\"}],\"name\":\"AccuseArchaeologist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cleaner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cleanerBondReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"embalmerBondReward\",\"type\":\"uint256\"}],\"name\":\"CleanUpSarcophagus\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"keyShareHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"}],\"name\":\"accuse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"accuse(bytes32,bytes32[],address)\":{\"params\":{\"keyShareHashes\":\"hashes of the leaked key shares\",\"paymentAddress\":\"the address to which rewards should be sent if successful\",\"sarcoId\":\"The identifier of the sarcophagus having leaked shares\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"accuse(bytes32,bytes32[],address)\":{\"notice\":\"Accuse one or more archaeologists of leaking key shares by submitting the hashes of the leaked shares If the archaeologists responsible for those shares haven't already been accused, their locked bond will be split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus state will be updated to Accused and bonds for all remaining unaccused archaeologists will be returned\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/ThirdPartyFacet.sol\":\"ThirdPartyFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"contracts/facets/ThirdPartyFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport {AppStorage} from \\\"../storage/LibAppStorage.sol\\\";\\n\\ncontract ThirdPartyFacet {\\n    AppStorage internal s;\\n\\n    event AccuseArchaeologist(\\n        bytes32 indexed sarcoId,\\n        address indexed accuser,\\n        uint256 accuserBondReward,\\n        uint256 embalmerBondReward\\n    );\\n\\n    event CleanUpSarcophagus(\\n        bytes32 indexed sarcoId,\\n        address indexed cleaner,\\n        uint256 cleanerBondReward,\\n        uint256 embalmerBondReward\\n    );\\n\\n    /// @notice Close a sarcophagus that has not been unwrapped within its grace period\\n    /// @param sarcoId The identifier of the sarcophagus to clean\\n    /// @param paymentAddress The address to which rewards will be sent\\n//    function clean(bytes32 sarcoId, address paymentAddress) external {\\n//        LibUtils.revertIfNotExistOrInactive(sarcoId);\\n//\\n//        LibTypes.Sarcophagus storage sarco = s.sarcophagi[sarcoId];\\n//\\n//        // Make sure the sarco is cleanable\\n//        if (block.timestamp < s.gracePeriod + sarco.resurrectionTime) {\\n//            revert LibErrors.SarcophagusNotCleanable();\\n//        }\\n//\\n//        // Figure out which archaeoligists did not fulfil their duties;\\n//        // accumulate their digging fees\\n//        address[] memory archAddresses = sarco.archaeologists;\\n//\\n//        uint256 totalDiggingFee;\\n//\\n//        for (uint256 i = 0; i < archAddresses.length; i++) {\\n//            // todo: consider skipping this mapping and just retrieving the keyshares\\n//            bool didNotUnwrap = s.archaeologistSarcoSuccesses[archAddresses[i]][sarcoId] == false;\\n//\\n//            if (didNotUnwrap) {\\n//                LibTypes.ArchaeologistStorage memory defaulter = s.sarcophagusArchaeologists[\\n//                    sarcoId\\n//                ][archAddresses[i]];\\n//\\n//                totalDiggingFee += defaulter.diggingFee;\\n//\\n//                // decrease the defaulter's cursed bond\\n//                LibBonds.decreaseCursedBond(archAddresses[i], defaulter.diggingFee);\\n//\\n//                // Save the failure to unwrap against the archaeologist\\n//                s.archaeologistCleanups[archAddresses[i]].push(sarcoId);\\n//            }\\n//        }\\n//\\n//        (uint256 cleanerBondReward, uint256 embalmerBondReward) = _distributeLoot(\\n//            paymentAddress,\\n//            sarco,\\n//            totalDiggingFee\\n//        );\\n//\\n//        sarco.state = LibTypes.SarcophagusState.Cleaned;\\n//\\n//        emit CleanUpSarcophagus(sarcoId, msg.sender, cleanerBondReward, embalmerBondReward);\\n//    }\\n\\n    /**\\n     * @notice Accuse one or more archaeologists of leaking key shares by submitting the hashes of the leaked shares\\n     * If the archaeologists responsible for those shares haven't already been accused, their locked bond will be\\n     * split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer\\n     *\\n     * If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus state will be updated to Accused\\n     * and bonds for all remaining unaccused archaeologists will be returned\\n     *\\n     * @param sarcoId The identifier of the sarcophagus having leaked shares\\n     * @param keyShareHashes hashes of the leaked key shares\\n     * @param paymentAddress the address to which rewards should be sent if successful\\n     */\\n    function accuse(\\n        bytes32 sarcoId,\\n        bytes32[] calldata keyShareHashes,\\n        address paymentAddress\\n    ) external {\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // verify that current time is not past resurrection time\\n        if (block.timestamp > sarcophagus.resurrectionTime) {\\n            revert LibErrors.SarcophagusIsUnwrappable();\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2**256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // build an array of the addresses of the archaeologists currently being accused\\n        address[] memory accusedArchAddresses = new address[](keyShareHashes.length);\\n\\n        // track the combined locked bond across all archaeologists being accused in this call\\n        // locked bond will be equal to the amount of diggingFees allocated by the embalmer to pay the archaeologist\\n        uint256 totalDiggingFees = 0;\\n        uint256 accusalCount = 0;\\n        for (uint256 i = 0; i < keyShareHashes.length; i++) {\\n            // generate the double hash of the key share\\n            bytes32 doubleHashedKeyShare = keccak256(abi.encode(keyShareHashes[i]));\\n\\n            // look up the archaeologist responsible for the key share\\n            address accusedArchaeologistAddress = s.doubleHashedShardArchaeologists[doubleHashedKeyShare];\\n            LibTypes.CursedArchaeologist storage accusedArchaeologist = sarcophagus.cursedArchaeologists[accusedArchaeologistAddress];\\n\\n            // verify the accused archaeologist is cursed on the sarcophagus\\n            if (accusedArchaeologist.doubleHashedKeyShare == 0) {\\n                revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\\n            }\\n\\n            // if the archaeologist has already been accused on this sarcophagus break without taking action\\n            if (accusedArchaeologist.isAccused) {\\n                break;\\n            }\\n\\n            // mark the archaeologist on the sarcophagus as having been accused\\n            accusedArchaeologist.isAccused = true;\\n            accusedArchAddresses[accusalCount++] = accusedArchaeologistAddress;\\n\\n            // track the sum of all digging fees for all accused archaeologists\\n            totalDiggingFees += accusedArchaeologist.diggingFee;\\n\\n            // slash the accused archaeologist's bond\\n            LibBonds.decreaseCursedBond(accusedArchaeologistAddress, accusedArchaeologist.diggingFee);\\n\\n            // Save the accusal against the archaeologist\\n            s.archaeologistAccusals[accusedArchaeologistAddress].push(sarcoId);\\n        }\\n\\n        // if none of the accusals were valid because the archaeologists have all already been accused, return without taking action\\n        if (accusalCount == 0) {\\n            return;\\n        }\\n\\n        // the sarcophagus is compromised if the current call has successfully accused the sss threshold of archaeologists\\n        if (accusalCount >= sarcophagus.threshold) {\\n            sarcophagus.isCompromised = true;\\n        } else {\\n            // if the current call hasn't resulted in at least sss threshold archaeologists being accused\\n            // check if total number of historical accusals on sarcophagus is greater than threshold\\n            uint256 totalAccusals = 0;\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                if (sarcophagus.cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]].isAccused) {\\n                    totalAccusals++;\\n                }\\n            }\\n            // the sarcophagus is compromised if k or more archaeologists have been accused over the lifetime of the sarcophagus\\n            if (totalAccusals >= sarcophagus.threshold) {\\n                sarcophagus.isCompromised = true;\\n            }\\n        }\\n\\n        // if k or more archaeologists have been accused over the lifetime of the sarcophagus, funds should\\n        // be returned to the remaining well behaved archaeologists\\n        if (sarcophagus.isCompromised) {\\n            // iterate through all archaeologist addresses on the sarcophagus\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                // if the archaeologist has never been accused, release their locked bond back to them\\n                if (!sarcophagus.cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]].isAccused) {\\n                    LibBonds.freeArchaeologist(sarcoId, sarcophagus.cursedArchaeologistAddresses[i]);\\n                }\\n            }\\n        }\\n\\n        // refund the diggingFees allocated by the embalmer to the accused archaeologists\\n        // split the total bond being slashed between the embalmer and the payment address\\n        (uint256 accuserBondReward, uint256 embalmerBondReward) = _distributeLoot(\\n            paymentAddress,\\n            sarcophagus,\\n            totalDiggingFees\\n        );\\n\\n        emit AccuseArchaeologist(sarcoId, msg.sender, accuserBondReward, embalmerBondReward);\\n    }\\n\\n    /**\\n     * @notice Takes a sarcophagus's digging fee, splits it in half, and sends\\n     * to paymentAddress and embalmer\\n     * @param paymentAddress payment address for the transaction caller\\n     * @param sarc the sarcophagus to operate on\\n     * @param totalDiggingFee the sum of digging fees of all archs that failed to fulfil their duties\\n     * @return halfToSender the amount of SARCO token going to transaction\\n     * sender\\n     * @return halfToEmbalmer the amount of SARCO token going to embalmer\\n     */\\n    function _distributeLoot(\\n        address paymentAddress,\\n        LibTypes.Sarcophagus storage sarc,\\n        uint256 totalDiggingFee\\n    ) private returns (uint256, uint256) {\\n        // split the sarcophagus's cursed bond into two halves\\n        uint256 halfToEmbalmer = totalDiggingFee / 2;\\n        uint256 halfToSender = totalDiggingFee - halfToEmbalmer;\\n\\n        // transfer the cursed half, plus digging fee to the\\n        // embalmer\\n        s.sarcoToken.transfer(sarc.embalmerAddress, totalDiggingFee + halfToEmbalmer);\\n\\n        // transfer the other half of the cursed bond to the transaction caller\\n        s.sarcoToken.transfer(paymentAddress, halfToSender);\\n\\n        return (halfToSender, halfToEmbalmer);\\n    }\\n\\n    function _hashHelper(bytes memory data) private pure returns (bytes32) {\\n        return keccak256(data);\\n    }\\n}\\n\",\"keccak256\":\"0xdad80b9fd3a4311ead53d2e448664442a961c3e5f90df6d679c1fba2ff116e0f\",\"license\":\"Unlicense\"},\"contracts/libraries/LibBonds.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\n\\nlibrary LibBonds {\\n    /// @notice Decreases the amount stored in the freeBond mapping for an\\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\\n    /// the amount.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being decreased\\n    /// @param amount The amount to decrease the free bond by\\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current free bond\\n        if (amount > s.archaeologistProfiles[archaeologist].freeBond) {\\n            revert LibErrors.NotEnoughFreeBond(\\n                s.archaeologistProfiles[archaeologist].freeBond,\\n                amount\\n            );\\n        }\\n\\n        // Decrease the free bond amount\\n        s.archaeologistProfiles[archaeologist].freeBond -= amount;\\n    }\\n\\n    /// @notice Increases the amount stored in the freeBond mapping for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being decreased\\n    /// @param amount The amount to decrease the free bond by\\n    function increaseFreeBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Increase the free bond amount\\n        s.archaeologistProfiles[archaeologist].freeBond += amount;\\n    }\\n\\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\\n    /// archaeologist. Reverts if the archaeologist's cursed bond is lower than\\n    /// the amount.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// cursed bond is being decreased\\n    /// @param amount The amount to decrease the cursed bond by\\n    function decreaseCursedBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current cursed bond\\n        if (amount > s.archaeologistProfiles[archaeologist].cursedBond) {\\n            revert LibErrors.NotEnoughCursedBond(\\n                s.archaeologistProfiles[archaeologist].cursedBond,\\n                amount\\n            );\\n        }\\n\\n        // Decrease the cursed bond amount\\n        s.archaeologistProfiles[archaeologist].cursedBond -= amount;\\n    }\\n\\n    /// @notice Increases the amount stored in the cursedBond mapping for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// cursed bond is being decreased\\n    /// @param amount The amount to decrease the cursed bond by\\n    function increaseCursedBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Increase the cursed bond amount\\n        s.archaeologistProfiles[archaeologist].cursedBond += amount;\\n    }\\n\\n    /// @notice Locks up the archaeologist's bond, decreasing the\\n    /// archaeologist's free bond by an amount and increasing the\\n    /// archaeologist's cursed bond by the same amount.\\n    /// @param archaeologist The address of the archaeologist\\n    /// @param amount The amount to lock up\\n    function lockUpBond(address archaeologist, uint256 amount) internal {\\n        // Decrease the free bond amount\\n        decreaseFreeBond(archaeologist, amount);\\n\\n        // Increase the cursed bond amount\\n        increaseCursedBond(archaeologist, amount);\\n    }\\n\\n    /// @notice Unlocks the archaeologist's bond, increasing the\\n    /// archaeologist's free bond by an amount and decreasing the\\n    /// archaeologist's cursed bond by the same amount.\\n    /// @param archaeologist The address of the archaeologist\\n    /// @param amount The amount to unlock\\n    function unlockBond(address archaeologist, uint256 amount) internal {\\n        // Decrease the cursed bond amount\\n        decreaseCursedBond(archaeologist, amount);\\n\\n        // Increase the free bond amount\\n        increaseFreeBond(archaeologist, amount);\\n    }\\n\\n\\n    /// @notice Calculates an archaeologist's cursed bond and frees them\\n    /// (unlocks the cursed bond).\\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\\n    /// @param archaeologistAddress the address of the archaeologist to free\\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\\n            .sarcophagi[sarcoId]\\n            .cursedArchaeologists[archaeologistAddress];\\n\\n        // Free up the archaeologist's locked bond\\n        unlockBond(archaeologistAddress, cursedArchaeologist.diggingFee);\\n    }\\n}\\n\",\"keccak256\":\"0xc74cba3d575a7d40f467c7e0601e31c829a8b2b658c4234692c609e189637478\",\"license\":\"Unlicense\"},\"contracts/libraries/LibErrors.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title A collection of Errors\\n * @notice This library defines all of the Errors that the Sarcophagus system\\n * uses.\\n */\\nlibrary LibErrors {\\n    error AccuseNotEnoughProof(uint256 shardsProvided, uint8 minShards);\\n\\n    error AccuseIncorrectProof();\\n\\n    error ArchaeologistAlreadyUnwrapped(address archaeologist);\\n\\n    error ArchaeologistListNotUnique(address archaeologistAddress);\\n\\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\\n\\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\\n\\n    error DiggingFeeTooLow(uint256 diggingFee, address archaeologist);\\n\\n    error MinShardsGreaterThanArchaeologists(uint8 minShards);\\n\\n    error MinShardsZero();\\n\\n    error MaxResurrectionIntervalIsZero();\\n\\n    error NewResurrectionTimeInPast(uint256 newResurrectionTime);\\n\\n    error NewResurrectionTimeTooLarge(uint256 newResurrectionTime);\\n\\n    error NoArchaeologistsProvided();\\n\\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\\n\\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\\n\\n    error NotEnoughReward(uint256 reward, uint256 amount);\\n\\n    error ResurrectionTimeInPast(uint256 resurrectionTime);\\n\\n    error ResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval\\n    );\\n\\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\\n\\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\\n\\n    error SarcophagusInactive(bytes32 sarcoId);\\n\\n    error SarcophagusCompromised(bytes32 sarcoId);\\n\\n    error SenderNotEmbalmer(address sender, address embalmer);\\n\\n    error InvalidSignature(\\n        // address recovered from signature via ecrecover\\n        address recoveredAddress,\\n        // address we expected to have signed the data\\n        address expectedAddress\\n    );\\n\\n    error SignerNotArchaeologistOnSarcophagus(bytes32 sarcoId, address signer);\\n\\n    // Used when an attempt is made to accuse or rewrap after the resurrection time has already passed (so it's actually time to unwrap it)\\n    error SarcophagusIsUnwrappable();\\n\\n    // Used when an attempt is made to clean a sarcophagus before the grace period after the resurrection time has passed\\n    error SarcophagusNotCleanable();\\n\\n    error TooEarlyToUnwrap(uint256 resurrectionTime, uint256 currentTime);\\n\\n    error TooLateToUnwrap(uint256 resurrectionTime, uint256 gracePeriod, uint256 currentTime);\\n\\n    error UnencryptedShardHashMismatch(bytes rawKeyShare, bytes32 doubleHashedKeyShare);\\n\\n    error SarcophagusParametersExpired(uint256 timestamp);\\n}\\n\",\"keccak256\":\"0x6a14d37610938005085d1a3203c15a12d66303c063620bb9bc12172be9579eb5\",\"license\":\"Unlicense\"},\"contracts/libraries/LibTypes.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title Types shared across facets for the Sarcophagus diamond\\n */\\nlibrary LibTypes {\\n    struct Sarcophagus {\\n        // never zero - use for existence checks\\n        uint256 resurrectionTime;\\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\\n        bool isCompromised;\\n        string name;\\n        uint8 threshold;\\n        uint256 maximumRewrapInterval;\\n        string[2] arweaveTxIds;\\n        address embalmerAddress;\\n        address recipientAddress;\\n        address[] cursedArchaeologistAddresses;\\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\\n    }\\n\\n    struct CursedArchaeologist {\\n        // never zero - use for existence checks\\n        bytes32 doubleHashedKeyShare;\\n        bool isAccused;\\n        uint256 diggingFee;\\n        bytes rawKeyShare;\\n    }\\n\\n    struct ArchaeologistProfile {\\n        bool exists; // todo: use peerid.length instead of exists\\n        string peerId;\\n        uint256 minimumDiggingFee;\\n        uint256 maximumRewrapInterval;\\n        uint256 freeBond;\\n        uint256 cursedBond;\\n    }\\n}\\n\",\"keccak256\":\"0x0866af873e8c0d3fc3e16100244326474be51159855c0958246fa3c443f61c60\",\"license\":\"Unlicense\"},\"contracts/libraries/LibUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\n\\n/**\\n * @title Utility functions used within the Sarcophagus system\\n * @notice This library implements various functions that are used throughout\\n * Sarcophagus, mainly to DRY up the codebase\\n * @dev these functions are all stateless, public, pure/view\\n */\\nlibrary LibUtils {\\n    /**\\n     * @notice Reverts if the public key length is not exactly 64 bytes long\\n     * @param publicKey the key to check length of\\n     */\\n    function publicKeyLength(bytes memory publicKey) public pure {\\n        require(publicKey.length == 64, \\\"public key must be 64 bytes\\\");\\n    }\\n\\n    /**\\n     * @notice Reverts if the hash of singleHash does not equal doubleHash\\n     * @param doubleHash the hash to compare hash of singleHash to\\n     * @param singleHash the value to hash and compare against doubleHash\\n     */\\n    function hashCheck(bytes32 doubleHash, bytes memory singleHash) public pure {\\n        require(doubleHash == keccak256(singleHash), \\\"hashes do not match\\\");\\n    }\\n\\n    /**\\n     * @notice The archaeologist needs to sign off on two pieces of data\\n     * to guarantee their unrwap will be successful\\n     *\\n     * @param unencryptedShardDoubleHash the double hash of the unencrypted shard\\n     * @param arweaveTxId the arweave TX ID that contains the archs encrypted shard\\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\\n     * @param diggingFee that the archaeologist has agreed to for the sarcophagus\\n     * @param v signature element\\n     * @param r signature element\\n     * @param s signature element\\n     * @param account address to confirm signature of data came from\\n     */\\n    function verifyArchaeologistSignature(\\n        bytes32 unencryptedShardDoubleHash,\\n        string memory arweaveTxId,\\n        uint256 agreedMaximumRewrapInterval,\\n        uint256 timestamp,\\n        uint256 diggingFee,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        address account\\n    ) internal pure {\\n        // Hash the hash of the data payload\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encode(\\n                        arweaveTxId,\\n                        unencryptedShardDoubleHash,\\n                        agreedMaximumRewrapInterval,\\n                        diggingFee,\\n                        timestamp\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Generate the address from the signature.\\n        // ecrecover should always return a valid address.\\n        address recoveredAddress = ecrecover(messageHash, v, r, s);\\n\\n        if (recoveredAddress != account) {\\n            revert LibErrors.InvalidSignature(recoveredAddress, account);\\n        }\\n    }\\n\\n    /// @notice Returns the address that signed some data given the data and the\\n    /// signature.\\n    /// @param data the data to verify\\n    /// @param v signature element\\n    /// @param r signature element\\n    /// @param s signature element\\n    /// @return the address that signed the data\\n    function recoverAddress(\\n        bytes memory data,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        // Hash the hash of the data payload\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(abi.encode(data)))\\n        );\\n\\n        // Genearate the address from the signature.\\n        // ecrecover should always return a valid address.\\n        // It's highly recommended that a hash be passed into ecrecover\\n        address account = ecrecover(messageHash, v, r, s);\\n\\n        return account;\\n    }\\n\\n    /**\\n     * @notice Reverts if the given resurrection time is not in the future\\n     * @param resurrectionTime the time to check against block.timestamp\\n     */\\n    function resurrectionInFuture(uint256 resurrectionTime) internal view {\\n        if (resurrectionTime <= block.timestamp) {\\n            revert LibErrors.ResurrectionTimeInPast(resurrectionTime);\\n        }\\n    }\\n\\n    /**\\n     * @notice Reverts if the current block timestamp is not within the resurrection window\\n     * (window = [resurrection time, resurrection time + grace period] inclusive)\\n     * @param resurrectionTime the resurrection time of the sarcophagus\\n     * (absolute, i.e. a date time stamp)\\n     */\\n    function unwrapTime(uint256 resurrectionTime) internal view {\\n        // revert if too early\\n        if (resurrectionTime > block.timestamp) {\\n            revert LibErrors.TooEarlyToUnwrap(resurrectionTime, block.timestamp);\\n        }\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // revert if too late\\n        if (resurrectionTime + s.gracePeriod < block.timestamp) {\\n            revert LibErrors.TooLateToUnwrap(resurrectionTime, s.gracePeriod, block.timestamp);\\n        }\\n    }\\n\\n    /// @notice Checks if an archaeologist profile exists and\\n    /// reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check existence of\\n    function revertIfArchProfileExists(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].exists) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Checks if an archaeologist profile doesn't exist and\\n    /// reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check lack of existence of\\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (!s.archaeologistProfiles[archaeologist].exists) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\\n    /// @return The protocol fees amount\\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 100;\\n    }\\n}\\n\",\"keccak256\":\"0x2a7152681cf742ee68300169eadd627b567859c4cc9448790a5428b0fcaafc9d\",\"license\":\"Unlicense\"},\"contracts/storage/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\n/**\\n* Global diamond storage struct to be shared across facets\\n* TODO: Implement diamond storage pattern and consider splitting storage into facet specific structs\\n*/\\nstruct AppStorage {\\n    // SARCO token contract\\n    IERC20 sarcoToken;\\n\\n    // total protocol fees available to be withdrawn by the admin\\n    uint256 totalProtocolFees;\\n\\n    /**\\n    * Protocol level admin configurations\\n    */\\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap\\n    uint256 protocolFeeBasePercentage;\\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time\\n    uint256 gracePeriod;\\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated\\n    uint256 expirationThreshold;\\n\\n    /**\\n    * Ownership mappings\\n    */\\n    // embalmer address => ids of sarcophagi they've created\\n    mapping(address => bytes32[]) embalmerSarcophagi;\\n    // archaeologist address =>  ids of sarcophagi they're protecting\\n    mapping(address => bytes32[]) archaeologistSarcophagi;\\n    // recipient address =>  ids of sarcophagi they're recipient on\\n    mapping(address => bytes32[]) recipientSarcophagi;\\n\\n    // double hashed keyshare => archaeologist address\\n    mapping(bytes32 => address) doubleHashedShardArchaeologists;\\n\\n    // sarcophagus ids\\n    bytes32[] sarcophagusIdentifiers;\\n    // sarcophagus id => sarcophagus object\\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\\n\\n    // archaeologist addresses\\n    address[] archaeologistProfileAddresses;\\n    // archaeologist address => profile\\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\\n\\n\\n    // current balance of rewards available for the archaeologist to withdraw\\n    mapping(address => uint256) archaeologistRewards;\\n\\n\\n    /**\\n    * Archaeologist reputation statistics\\n    * todo: could these be organized differently?\\n    */\\n    mapping(address => bytes32[]) archaeologistSuccesses;\\n    mapping(address => bytes32[]) archaeologistAccusals;\\n    mapping(address => bytes32[]) archaeologistCleanups;\\n}\\n\\nlibrary LibAppStorage {\\n    function getAppStorage() internal pure returns (AppStorage storage s) {\\n        // Set the position of our struct in contract storage\\n        // Since AppStorage s is the first and only state variable declared in\\n        // facets its position in contract storage is 0\\n        assembly {\\n            s.slot := 0\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf74c670645b035ed8fa6f725ac44b559bda71977be9e593e6ce856d1029e6d3\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610fa8806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80635c88a8e114610030575b600080fd5b61004a60048036038101906100459190610c1b565b61004c565b005b600080600a016000868152602001908152602001600020905060008160000154036100ae57846040517f018da6880000000000000000000000000000000000000000000000000000000081526004016100a59190610c9e565b60405180910390fd5b80600001544211156100ec576040517f8680d5de00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8060010160009054906101000a900460ff161561014057846040517f9af72b860000000000000000000000000000000000000000000000000000000081526004016101379190610c9e565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8160000154036101a857846040517f7c6a6d7000000000000000000000000000000000000000000000000000000000815260040161019f9190610c9e565b60405180910390fd5b60008484905067ffffffffffffffff8111156101c7576101c6610cb9565b5b6040519080825280602002602001820160405280156101f55781602001602082028036833780820191505090505b50905060008060005b8787905081101561044c57600088888381811061021e5761021d610ce8565b5b905060200201356040516020016102359190610c9e565b604051602081830303815290604052805190602001209050600080600801600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600087600a0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000801b81600001540361031757336040517f82881f0300000000000000000000000000000000000000000000000000000000815260040161030e9190610d26565b60405180910390fd5b8060010160009054906101000a900460ff16156103365750505061044c565b60018160010160006101000a81548160ff0219169083151502179055508187868061036090610d7a565b97508151811061037357610372610ce8565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508060020154866103bd9190610dc2565b95506103cd828260020154610732565b6000600f0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208c9080600181540180825580915050600190039060005260206000200160009091909190915055505050808061044490610d7a565b9150506101fe565b506000810361045e575050505061072c565b8360030160009054906101000a900460ff1660ff16811061049b5760018460010160006101000a81548160ff0219169083151502179055506105a3565b6000805b85600901805490508110156105675785600a0160008760090183815481106104ca576104c9610ce8565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160009054906101000a900460ff161561055457818061055090610d7a565b9250505b808061055f90610d7a565b91505061049f565b508460030160009054906101000a900460ff1660ff1681106105a15760018560010160006101000a81548160ff0219169083151502179055505b505b8360010160009054906101000a900460ff16156106c25760005b84600901805490508110156106c05784600a0160008660090183815481106105e8576105e7610ce8565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160009054906101000a900460ff166106ad576106ac8986600901838154811061067c5761067b610ce8565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661086d565b5b80806106b890610d7a565b9150506105bd565b505b6000806106d08787866108e6565b915091503373ffffffffffffffffffffffffffffffffffffffff168a7f6cee286923fc4de6af78ba8b06ff9f4236e5aad4282a5e13a3cea8446c803fd4848460405161071d929190610e27565b60405180910390a35050505050505b50505050565b600061073c610a8f565b905080600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206005015482111561080d5780600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154826040517faf5a111b000000000000000000000000000000000000000000000000000000008152600401610804929190610e27565b60405180910390fd5b8181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546108619190610e50565b92505081905550505050565b6000610877610a8f565b9050600081600a016000858152602001908152602001600020600a0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506108e0838260020154610a94565b50505050565b60008060006002846108f89190610eb3565b9050600081856109089190610e50565b90506000800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8760070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16848861097b9190610dc2565b6040518363ffffffff1660e01b8152600401610998929190610ee4565b6020604051808303816000875af11580156109b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109db9190610f45565b506000800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb88836040518363ffffffff1660e01b8152600401610a3b929190610ee4565b6020604051808303816000875af1158015610a5a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7e9190610f45565b508082935093505050935093915050565b600090565b610a9e8282610732565b610aa88282610aac565b5050565b6000610ab6610a8f565b90508181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206004016000828254610b0c9190610dc2565b92505081905550505050565b600080fd5b600080fd5b6000819050919050565b610b3581610b22565b8114610b4057600080fd5b50565b600081359050610b5281610b2c565b92915050565b600080fd5b600080fd5b600080fd5b60008083601f840112610b7d57610b7c610b58565b5b8235905067ffffffffffffffff811115610b9a57610b99610b5d565b5b602083019150836020820283011115610bb657610bb5610b62565b5b9250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610be882610bbd565b9050919050565b610bf881610bdd565b8114610c0357600080fd5b50565b600081359050610c1581610bef565b92915050565b60008060008060608587031215610c3557610c34610b18565b5b6000610c4387828801610b43565b945050602085013567ffffffffffffffff811115610c6457610c63610b1d565b5b610c7087828801610b67565b93509350506040610c8387828801610c06565b91505092959194509250565b610c9881610b22565b82525050565b6000602082019050610cb36000830184610c8f565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b610d2081610bdd565b82525050565b6000602082019050610d3b6000830184610d17565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000819050919050565b6000610d8582610d70565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610db757610db6610d41565b5b600182019050919050565b6000610dcd82610d70565b9150610dd883610d70565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115610e0d57610e0c610d41565b5b828201905092915050565b610e2181610d70565b82525050565b6000604082019050610e3c6000830185610e18565b610e496020830184610e18565b9392505050565b6000610e5b82610d70565b9150610e6683610d70565b925082821015610e7957610e78610d41565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000610ebe82610d70565b9150610ec983610d70565b925082610ed957610ed8610e84565b5b828204905092915050565b6000604082019050610ef96000830185610d17565b610f066020830184610e18565b9392505050565b60008115159050919050565b610f2281610f0d565b8114610f2d57600080fd5b50565b600081519050610f3f81610f19565b92915050565b600060208284031215610f5b57610f5a610b18565b5b6000610f6984828501610f30565b9150509291505056fea26469706673582212202db7980710faf48f9ebd726b8269fefac742ab5a05b2f68203a753b38462589d64736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80635c88a8e114610030575b600080fd5b61004a60048036038101906100459190610c1b565b61004c565b005b600080600a016000868152602001908152602001600020905060008160000154036100ae57846040517f018da6880000000000000000000000000000000000000000000000000000000081526004016100a59190610c9e565b60405180910390fd5b80600001544211156100ec576040517f8680d5de00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8060010160009054906101000a900460ff161561014057846040517f9af72b860000000000000000000000000000000000000000000000000000000081526004016101379190610c9e565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8160000154036101a857846040517f7c6a6d7000000000000000000000000000000000000000000000000000000000815260040161019f9190610c9e565b60405180910390fd5b60008484905067ffffffffffffffff8111156101c7576101c6610cb9565b5b6040519080825280602002602001820160405280156101f55781602001602082028036833780820191505090505b50905060008060005b8787905081101561044c57600088888381811061021e5761021d610ce8565b5b905060200201356040516020016102359190610c9e565b604051602081830303815290604052805190602001209050600080600801600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600087600a0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000801b81600001540361031757336040517f82881f0300000000000000000000000000000000000000000000000000000000815260040161030e9190610d26565b60405180910390fd5b8060010160009054906101000a900460ff16156103365750505061044c565b60018160010160006101000a81548160ff0219169083151502179055508187868061036090610d7a565b97508151811061037357610372610ce8565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508060020154866103bd9190610dc2565b95506103cd828260020154610732565b6000600f0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208c9080600181540180825580915050600190039060005260206000200160009091909190915055505050808061044490610d7a565b9150506101fe565b506000810361045e575050505061072c565b8360030160009054906101000a900460ff1660ff16811061049b5760018460010160006101000a81548160ff0219169083151502179055506105a3565b6000805b85600901805490508110156105675785600a0160008760090183815481106104ca576104c9610ce8565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160009054906101000a900460ff161561055457818061055090610d7a565b9250505b808061055f90610d7a565b91505061049f565b508460030160009054906101000a900460ff1660ff1681106105a15760018560010160006101000a81548160ff0219169083151502179055505b505b8360010160009054906101000a900460ff16156106c25760005b84600901805490508110156106c05784600a0160008660090183815481106105e8576105e7610ce8565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010160009054906101000a900460ff166106ad576106ac8986600901838154811061067c5761067b610ce8565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661086d565b5b80806106b890610d7a565b9150506105bd565b505b6000806106d08787866108e6565b915091503373ffffffffffffffffffffffffffffffffffffffff168a7f6cee286923fc4de6af78ba8b06ff9f4236e5aad4282a5e13a3cea8446c803fd4848460405161071d929190610e27565b60405180910390a35050505050505b50505050565b600061073c610a8f565b905080600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206005015482111561080d5780600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154826040517faf5a111b000000000000000000000000000000000000000000000000000000008152600401610804929190610e27565b60405180910390fd5b8181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546108619190610e50565b92505081905550505050565b6000610877610a8f565b9050600081600a016000858152602001908152602001600020600a0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506108e0838260020154610a94565b50505050565b60008060006002846108f89190610eb3565b9050600081856109089190610e50565b90506000800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8760070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16848861097b9190610dc2565b6040518363ffffffff1660e01b8152600401610998929190610ee4565b6020604051808303816000875af11580156109b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109db9190610f45565b506000800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb88836040518363ffffffff1660e01b8152600401610a3b929190610ee4565b6020604051808303816000875af1158015610a5a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7e9190610f45565b508082935093505050935093915050565b600090565b610a9e8282610732565b610aa88282610aac565b5050565b6000610ab6610a8f565b90508181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206004016000828254610b0c9190610dc2565b92505081905550505050565b600080fd5b600080fd5b6000819050919050565b610b3581610b22565b8114610b4057600080fd5b50565b600081359050610b5281610b2c565b92915050565b600080fd5b600080fd5b600080fd5b60008083601f840112610b7d57610b7c610b58565b5b8235905067ffffffffffffffff811115610b9a57610b99610b5d565b5b602083019150836020820283011115610bb657610bb5610b62565b5b9250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610be882610bbd565b9050919050565b610bf881610bdd565b8114610c0357600080fd5b50565b600081359050610c1581610bef565b92915050565b60008060008060608587031215610c3557610c34610b18565b5b6000610c4387828801610b43565b945050602085013567ffffffffffffffff811115610c6457610c63610b1d565b5b610c7087828801610b67565b93509350506040610c8387828801610c06565b91505092959194509250565b610c9881610b22565b82525050565b6000602082019050610cb36000830184610c8f565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b610d2081610bdd565b82525050565b6000602082019050610d3b6000830184610d17565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000819050919050565b6000610d8582610d70565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610db757610db6610d41565b5b600182019050919050565b6000610dcd82610d70565b9150610dd883610d70565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115610e0d57610e0c610d41565b5b828201905092915050565b610e2181610d70565b82525050565b6000604082019050610e3c6000830185610e18565b610e496020830184610e18565b9392505050565b6000610e5b82610d70565b9150610e6683610d70565b925082821015610e7957610e78610d41565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000610ebe82610d70565b9150610ec983610d70565b925082610ed957610ed8610e84565b5b828204905092915050565b6000604082019050610ef96000830185610d17565b610f066020830184610e18565b9392505050565b60008115159050919050565b610f2281610f0d565b8114610f2d57600080fd5b50565b600081519050610f3f81610f19565b92915050565b600060208284031215610f5b57610f5a610b18565b5b6000610f6984828501610f30565b9150509291505056fea26469706673582212202db7980710faf48f9ebd726b8269fefac742ab5a05b2f68203a753b38462589d64736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "accuse(bytes32,bytes32[],address)": {
        "params": {
          "keyShareHashes": "hashes of the leaked key shares",
          "paymentAddress": "the address to which rewards should be sent if successful",
          "sarcoId": "The identifier of the sarcophagus having leaked shares"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "accuse(bytes32,bytes32[],address)": {
        "notice": "Accuse one or more archaeologists of leaking key shares by submitting the hashes of the leaked shares If the archaeologists responsible for those shares haven't already been accused, their locked bond will be split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus state will be updated to Accused and bonds for all remaining unaccused archaeologists will be returned"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2650,
        "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
        "label": "s",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(AppStorage)4520_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_bytes32)dyn_storage": {
        "base": "t_bytes32",
        "encoding": "dynamic_array",
        "label": "bytes32[]",
        "numberOfBytes": "32"
      },
      "t_array(t_string_storage)2_storage": {
        "base": "t_string_storage",
        "encoding": "inplace",
        "label": "string[2]",
        "numberOfBytes": "64"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_contract(IERC20)77": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_array(t_bytes32)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bytes32[])",
        "numberOfBytes": "32",
        "value": "t_array(t_bytes32)dyn_storage"
      },
      "t_mapping(t_address,t_struct(ArchaeologistProfile)4104_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct LibTypes.ArchaeologistProfile)",
        "numberOfBytes": "32",
        "value": "t_struct(ArchaeologistProfile)4104_storage"
      },
      "t_mapping(t_address,t_struct(CursedArchaeologist)4091_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct LibTypes.CursedArchaeologist)",
        "numberOfBytes": "32",
        "value": "t_struct(CursedArchaeologist)4091_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_bytes32,t_struct(Sarcophagus)4082_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct LibTypes.Sarcophagus)",
        "numberOfBytes": "32",
        "value": "t_struct(Sarcophagus)4082_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(AppStorage)4520_storage": {
        "encoding": "inplace",
        "label": "struct AppStorage",
        "members": [
          {
            "astId": 4454,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "sarcoToken",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(IERC20)77"
          },
          {
            "astId": 4456,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "totalProtocolFees",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 4459,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "protocolFeeBasePercentage",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 4461,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "gracePeriod",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 4463,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "expirationThreshold",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 4469,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "embalmerSarcophagi",
            "offset": 0,
            "slot": "5",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          },
          {
            "astId": 4474,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistSarcophagi",
            "offset": 0,
            "slot": "6",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          },
          {
            "astId": 4479,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "recipientSarcophagi",
            "offset": 0,
            "slot": "7",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          },
          {
            "astId": 4483,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "doubleHashedShardArchaeologists",
            "offset": 0,
            "slot": "8",
            "type": "t_mapping(t_bytes32,t_address)"
          },
          {
            "astId": 4486,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "sarcophagusIdentifiers",
            "offset": 0,
            "slot": "9",
            "type": "t_array(t_bytes32)dyn_storage"
          },
          {
            "astId": 4491,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "sarcophagi",
            "offset": 0,
            "slot": "10",
            "type": "t_mapping(t_bytes32,t_struct(Sarcophagus)4082_storage)"
          },
          {
            "astId": 4494,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistProfileAddresses",
            "offset": 0,
            "slot": "11",
            "type": "t_array(t_address)dyn_storage"
          },
          {
            "astId": 4499,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistProfiles",
            "offset": 0,
            "slot": "12",
            "type": "t_mapping(t_address,t_struct(ArchaeologistProfile)4104_storage)"
          },
          {
            "astId": 4503,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistRewards",
            "offset": 0,
            "slot": "13",
            "type": "t_mapping(t_address,t_uint256)"
          },
          {
            "astId": 4509,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistSuccesses",
            "offset": 0,
            "slot": "14",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          },
          {
            "astId": 4514,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistAccusals",
            "offset": 0,
            "slot": "15",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          },
          {
            "astId": 4519,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistCleanups",
            "offset": 0,
            "slot": "16",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          }
        ],
        "numberOfBytes": "544"
      },
      "t_struct(ArchaeologistProfile)4104_storage": {
        "encoding": "inplace",
        "label": "struct LibTypes.ArchaeologistProfile",
        "members": [
          {
            "astId": 4093,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "exists",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 4095,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "peerId",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          },
          {
            "astId": 4097,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "minimumDiggingFee",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 4099,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "maximumRewrapInterval",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 4101,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "freeBond",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 4103,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "cursedBond",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(CursedArchaeologist)4091_storage": {
        "encoding": "inplace",
        "label": "struct LibTypes.CursedArchaeologist",
        "members": [
          {
            "astId": 4084,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "doubleHashedKeyShare",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 4086,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "isAccused",
            "offset": 0,
            "slot": "1",
            "type": "t_bool"
          },
          {
            "astId": 4088,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "diggingFee",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 4090,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "rawKeyShare",
            "offset": 0,
            "slot": "3",
            "type": "t_bytes_storage"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(Sarcophagus)4082_storage": {
        "encoding": "inplace",
        "label": "struct LibTypes.Sarcophagus",
        "members": [
          {
            "astId": 4057,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "resurrectionTime",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 4059,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "isCompromised",
            "offset": 0,
            "slot": "1",
            "type": "t_bool"
          },
          {
            "astId": 4061,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "name",
            "offset": 0,
            "slot": "2",
            "type": "t_string_storage"
          },
          {
            "astId": 4063,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "threshold",
            "offset": 0,
            "slot": "3",
            "type": "t_uint8"
          },
          {
            "astId": 4065,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "maximumRewrapInterval",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 4069,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "arweaveTxIds",
            "offset": 0,
            "slot": "5",
            "type": "t_array(t_string_storage)2_storage"
          },
          {
            "astId": 4071,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "embalmerAddress",
            "offset": 0,
            "slot": "7",
            "type": "t_address"
          },
          {
            "astId": 4073,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "recipientAddress",
            "offset": 0,
            "slot": "8",
            "type": "t_address"
          },
          {
            "astId": 4076,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "cursedArchaeologistAddresses",
            "offset": 0,
            "slot": "9",
            "type": "t_array(t_address)dyn_storage"
          },
          {
            "astId": 4081,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "cursedArchaeologists",
            "offset": 0,
            "slot": "10",
            "type": "t_mapping(t_address,t_struct(CursedArchaeologist)4091_storage)"
          }
        ],
        "numberOfBytes": "352"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}