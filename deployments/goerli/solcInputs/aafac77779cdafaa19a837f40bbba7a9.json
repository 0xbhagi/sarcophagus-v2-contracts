{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/facets/ArchaeologistFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {LibPrivateKeys} from \"../libraries/LibPrivateKeys.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract ArchaeologistFacet {\n    AppStorage internal s;\n\n    event PublishPrivateKey(bytes32 indexed sarcoId, bytes32 privateKey);\n\n    event DepositFreeBond(address indexed archaeologist, uint256 depositedBond);\n\n    event RegisterArchaeologist(\n        address indexed archaeologist,\n        string peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond\n    );\n\n    event UpdateArchaeologist(\n        address indexed archaeologist,\n        string peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond\n    );\n\n    event WithdrawFreeBond(address indexed archaeologist, uint256 withdrawnBond);\n\n    event WithdrawReward(address indexed archaeologist, uint256 withdrawnReward);\n\n    /// @notice An archaeologist that has already been accused has attempted to publish a key share\n    /// @param archaeologistAddress Address of accused archaeologist\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a share on\n    error ArchaeologistHasBeenAccused(address archaeologistAddress, bytes32 sarcoId);\n\n    /// @notice Clean has been called on a sarcophagus that has already been cleaned\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a share on\n    error SarcophagusAlreadyCleaned(bytes32 sarcoId);\n\n    /// @notice Clean has been called before the deadline for archaeologists to publish key shares has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param publishDeadline Latest time an archaeologist may publish a key share on a sarcophagus: esurrectionTime + gracePeriod\n    error TooEarlyForClean(uint256 currentTime, uint256 publishDeadline);\n\n    /// @notice Clean has been called by someone other than the admin or embalmer of the sarcophagus\n    /// @param senderAddress Address of sender\n    error SenderNotEmbalmerOrAdmin(address senderAddress);\n\n    /// @notice Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\n    error EmbalmerClaimWindowPassed(uint256 currentTime, uint256 embalmerClaimWindowEnd);\n\n    /// @notice Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\n    error TooEarlyForAdminClean(uint256 currentTime, uint256 embalmerClaimWindowEnd);\n\n    /// @notice Archaeologist has attempted to publish a keyshare before the resurrection time\n    /// @param currentTime Timestamp of the failed publish attempt\n    /// @param resurrectionTime Time after which the sarcophagus can be resurrected\n    error TooEarlyForPublish(uint256 currentTime, uint256 resurrectionTime);\n\n    /// @notice Archaeologist has attempted to publish a keyshare after the end of the resurrection window\n    /// @param currentTime Timestamp of the failed publish attempt\n    /// @param publishDeadline Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)\n    error TooLateForPublish(uint256 currentTime, uint256 publishDeadline);\n\n    error ArchaeologistAlreadyPublishedPrivateKey(address archaeologistAddress);\n\n    error ArchaeologistPublishedIncorrectPrivateKey(address archaeologistAddress, bytes publicKey, bytes32 privateKey);\n\n\n    /// @notice Registers the archaeologist profile\n    /// @param peerId The libp2p identifier for the archaeologist\n    /// @param minimumDiggingFee The archaeologist's minimum amount to accept for a digging fee\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\n    /// for a resurrection\n    /// @param freeBond How much bond the archaeologist wants to deposit during the register call (if any)\n    function registerArchaeologist(\n        string memory peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond\n    ) external {\n        // verify that the archaeologist does not already exist\n        LibUtils.revertIfArchProfileExists(msg.sender);\n\n        // create a new archaeologist\n        LibTypes.ArchaeologistProfile memory newArch = LibTypes.ArchaeologistProfile({\n            exists: true,\n            peerId: peerId,\n            minimumDiggingFee: minimumDiggingFee,\n            maximumRewrapInterval: maximumRewrapInterval,\n            freeBond: freeBond,\n            cursedBond: 0\n        });\n\n        // transfer SARCO tokens from the archaeologist to this contract, to be\n        // used as their free bond. can be 0.\n        if (freeBond > 0) {\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\n        }\n\n        // save the new archaeologist into relevant data structures\n        s.archaeologistProfiles[msg.sender] = newArch;\n        s.archaeologistProfileAddresses.push(msg.sender);\n\n        emit RegisterArchaeologist(\n            msg.sender,\n            newArch.peerId,\n            newArch.minimumDiggingFee,\n            newArch.maximumRewrapInterval,\n            newArch.freeBond\n        );\n    }\n\n    /// @notice Updates the archaeologist profile\n    /// @param peerId The libp2p identifier for the archaeologist\n    /// @param minimumDiggingFee The archaeologist's minimum amount to accept for a digging fee\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\n    /// for a resurrection\n    /// freeBond How much bond the archaeologist wants to deposit during the update call (if any)\n    function updateArchaeologist(\n        string memory peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond\n    ) external {\n        // verify that the archaeologist exists\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n\n        // create a new archaeologist\n        LibTypes.ArchaeologistProfile storage existingArch = s.archaeologistProfiles[msg.sender];\n        existingArch.peerId = peerId;\n        existingArch.minimumDiggingFee = minimumDiggingFee;\n        existingArch.maximumRewrapInterval = maximumRewrapInterval;\n\n        // transfer SARCO tokens from the archaeologist to this contract, to be\n        // used as their free bond. can be 0.\n        if (freeBond > 0) {\n            LibBonds.increaseFreeBond(msg.sender, freeBond);\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\n        }\n\n        emit UpdateArchaeologist(\n            msg.sender,\n            existingArch.peerId,\n            existingArch.minimumDiggingFee,\n            existingArch.maximumRewrapInterval,\n            existingArch.freeBond\n        );\n    }\n\n    /// @notice Deposits an archaeologist's free bond to the contract.\n    /// @param amount The amount to deposit\n    function depositFreeBond(uint256 amount) external {\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n        // Increase the archaeologist's free bond in app storage\n        LibBonds.increaseFreeBond(msg.sender, amount);\n\n        // Transfer the amount of sarcoToken from the archaeologist to the contract\n        s.sarcoToken.transferFrom(msg.sender, address(this), amount);\n        // Emit an event\n        emit DepositFreeBond(msg.sender, amount);\n    }\n\n    /// @notice Withdraws an archaeologist's free bond from the contract.\n    /// @param amount The amount to withdraw\n    function withdrawFreeBond(uint256 amount) external {\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n        // Decrease the archaeologist's free bond amount.\n        // Reverts if there is not enough free bond on the contract.\n        LibBonds.decreaseFreeBond(msg.sender, amount);\n\n        // Transfer the amount of sarcoToken to the archaeologist\n        s.sarcoToken.transfer(msg.sender, amount);\n\n        // Emit an event\n        emit WithdrawFreeBond(msg.sender, amount);\n    }\n\n    /// @notice Withdraws all rewards from an archaeologist's reward pool\n    function withdrawReward() external {\n        uint256 amountToWithdraw = s.archaeologistRewards[msg.sender];\n        s.archaeologistRewards[msg.sender] = 0;\n\n        // Transfer the amount of sarcoToken to the archaeologist\n        s.sarcoToken.transfer(msg.sender, amountToWithdraw);\n\n        emit WithdrawReward(msg.sender, amountToWithdraw);\n    }\n\n    /// @notice Publishes the private key for which the archaeologist is responsible during the\n    /// sarcophagus resurrection window.\n    /// Pays digging fees to the archaeologist and releases their locked bond.\n    /// Cannot be called on a compromised or buried sarcophagus.\n    /// @param sarcoId The identifier of the sarcophagus to unwrap\n    /// @param privateKey The private key the archaeologist is publishing\n    function publishPrivateKey(bytes32 sarcoId, bytes32 privateKey) external {\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm current time is after resurrectionTime\n        if (block.timestamp < sarcophagus.resurrectionTime) {\n            revert TooEarlyForPublish(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Confirm current time is within gracePeriod\n        if (block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod) {\n            revert TooLateForPublish(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\n        }\n\n        // Confirm tx sender is an archaeologist on the sarcophagus\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\n            .sarcophagi[sarcoId]\n            .cursedArchaeologists[msg.sender];\n        if (cursedArchaeologist.publicKey.length == 0) {\n            revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\n        }\n\n        // Confirm archaeologist has not already leaked their private key\n        if (cursedArchaeologist.isAccused) {\n            revert ArchaeologistHasBeenAccused(msg.sender, sarcoId);\n        }\n\n        // Confirm archaeologist has not already published their private key\n        if (cursedArchaeologist.privateKey != 0) {\n            revert ArchaeologistAlreadyPublishedPrivateKey(msg.sender);\n        }\n\n        // Confirm that the private key being submitted matches the public key stored on the\n        // sarcophagus for this archaeologist\n        if (!LibPrivateKeys.isPublicKeyFromPrivateKey(privateKey, cursedArchaeologist.publicKey)) {\n            revert ArchaeologistPublishedIncorrectPrivateKey(\n                msg.sender,\n                cursedArchaeologist.publicKey,\n                privateKey\n            );\n        }\n\n        // Store the private key on cursed archaeologist\n        cursedArchaeologist.privateKey = privateKey;\n\n        // Free archaeologist locked bond and transfer digging fees\n        LibBonds.freeArchaeologist(sarcoId, msg.sender);\n        s.archaeologistRewards[msg.sender] += cursedArchaeologist.diggingFee;\n\n        // Save the successful sarcophagus against the archaeologist\n        s.archaeologistSuccesses[msg.sender].push(sarcoId);\n\n        emit PublishPrivateKey(sarcoId, privateKey);\n    }\n}\n"
    },
    "contracts/facets/EmbalmerFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract EmbalmerFacet {\n    // IMPORTANT: AppStorage must be the first state variable in the facet.\n    AppStorage internal s;\n\n    /// @notice Emitted when a sarcophagus is created\n    /// @param sarcoId Id of the new sarcophagus\n    /// @param name Name of the new sarcophagus\n    /// @param resurrectionTime Resurrection time of the new sarcophagus\n    /// @param embalmer Address of embalmer\n    /// @param recipient Address of recipient\n    /// @param cursedArchaeologists Array of addresses of cursed archaeologists\n    /// @param totalDiggingFees Total digging fees charged to embalmer to create the sarcophagus\n    /// @param createSarcophagusProtocolFees Total protocol fees charged to embalmer to create the sarcophagus\n    /// @param arweaveTxId arweave tx id for the sarcophagus: [sarcophagus payload tx, encrypted key share tx]\n    event CreateSarcophagus(\n        bytes32 indexed sarcoId,\n        string name,\n        uint256 resurrectionTime,\n        address embalmer,\n        address recipient,\n        address[] cursedArchaeologists,\n        uint256 totalDiggingFees,\n        uint256 createSarcophagusProtocolFees,\n        string arweaveTxId\n    );\n\n    /// @notice Emitted when a sarcophagus is rewrapped\n    /// @param sarcoId Id of sarcophagus that was buried\n    /// @param resurrectionTime New resurrection time for the sarcophagus\n    /// @param totalDiggingFees Total digging fees charged to the embalmer for the rewrap\n    /// @param rewrapSarcophagusProtocolFees Total protocol fees charged to the embalmer for the rewrap\n    event RewrapSarcophagus(\n        bytes32 indexed sarcoId,\n        uint256 resurrectionTime,\n        uint256 totalDiggingFees,\n        uint256 rewrapSarcophagusProtocolFees\n    );\n\n    /// @notice Emitted when a sarcophagus is buried\n    /// @param sarcoId Id of sarcophagus that was buried\n    event BurySarcophagus(bytes32 indexed sarcoId);\n\n    /// @notice Parameters of a sarcophagus, supplied during sarcophagus creation\n    struct SarcophagusParams {\n        string name;\n        // highest rewrap interval bonded archaeologists have agreed to accept for lifetime of sarcophagus\n        uint256 maximumRewrapInterval;\n        address recipientAddress;\n        uint256 resurrectionTime;\n        uint8 threshold;\n        uint256 creationTime;\n    }\n\n    /// @notice Parameters of an archaeologist's curse, supplied during sarcophagus creation\n    struct SelectedArchaeologistData {\n        bytes publicKey;\n        address archAddress;\n        // diggingFee archaeologist has agreed to receive on sarcophagus for its entire lifetime\n        uint256 diggingFee;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an id that is already in use\n    /// @param sarcoId Id that is already in use\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with expired parameters\n    /// @param currentTime Timestamp of the failed create attempt\n    /// @param creationTime Time when the sarcophagus parameters were created\n    /// @param creationDeadline Deadline for creation of a sarcophagus with the supplied parameters\n    error SarcophagusParametersExpired(\n        uint256 currentTime,\n        uint256 creationTime,\n        uint256 creationDeadline\n    );\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with no archaeologists\n    error NoArchaeologistsProvided();\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a shamir secret sharing threshold of 0\n    error ThresholdCannotBeZero();\n\n    error ThresholdGreaterThanTotalNumberOfArchaeologists(\n        uint8 threshold,\n        uint256 totalNumberOfArchaeologists\n    );\n\n    error ArchaeologistListContainsDuplicate(address archaeologistAddress);\n\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that has already passed\n    /// @param currentTime Timestamp of the failed rewrap attempt\n    /// @param resurrectionTime Resurrection timestamp which has already passed\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a public key that has already been assigned to another sarcophagus\n    /// @param publicKey the duplicated public key\n    error DuplicatePublicKey(bytes publicKey);\n\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that exceeds the maximum rewrap interval\n    /// @param resurrectionTime Resurrection timestamp which is too far in the future\n    /// @param sarcophagusMaximumRewrapInterval Maximum rewrap interval set for the sarcophagus\n    /// @param maximumPermissibleResurrectionTime Resurrection timestamp which is too far in the future\n    error ResurrectionTimeTooFarInFuture(\n        uint256 resurrectionTime,\n        uint256 sarcophagusMaximumRewrapInterval,\n        uint256 maximumPermissibleResurrectionTime\n    );\n\n    error NewResurrectionTimeInPast(uint256 currentTime, uint256 newResurrectionTime);\n\n    error NewResurrectionTimeTooFarInFuture(\n        uint256 resurrectionTime,\n        uint256 sarcophagusMaximumRewrapInterval,\n        uint256 maximumPermissibleResurrectionTime\n    );\n\n    /// @notice Creates a sarcophagus with the supplied parameters and locks\n    /// a portion of each archaeologist's freeBond equal to the diggingFees for the sarcophagus.\n    /// Verifies that all supplied archaeologists have signed off on the sarcophagus negotiation parameters:\n    ///    - publicKey key they are responsible for\n    ///    - maximumRewrapInterval to be enforced for the lifetime of the sarcophagus\n    ///    - creationTime of sarcophagus\n    ///    - diggingFee to be paid to that archaeologist on all rewraps for the lifetime of the sarcophagus\n    ///\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param sarcophagusParams params to set on sarcophagus being created\n    /// @param selectedArchaeologists the archaeologists the embalmer has selected to curse\n    /// @param arweaveTxId ordered pair of arweave tx ids: [sarcophagus payload tx, encrypted key share tx]\n    function createSarcophagus(\n        bytes32 sarcoId,\n        SarcophagusParams calldata sarcophagusParams,\n        SelectedArchaeologistData[] calldata selectedArchaeologists,\n        string memory arweaveTxId\n    ) external {\n        // Confirm that sarcophagus with supplied id doesn't already exist\n        if (s.sarcophagi[sarcoId].resurrectionTime > 0) {\n            revert SarcophagusAlreadyExists(sarcoId);\n        }\n\n        // Confirm that agreed upon sarcophagus parameters have not expired\n        if (block.timestamp > sarcophagusParams.creationTime + s.expirationThreshold) {\n            revert SarcophagusParametersExpired(\n                block.timestamp,\n                sarcophagusParams.creationTime,\n                sarcophagusParams.creationTime + s.expirationThreshold\n            );\n        }\n\n        // Confirm that resurrection time is in the future\n        if (block.timestamp >= sarcophagusParams.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagusParams.resurrectionTime);\n        }\n\n        // Confirm that resurrection or rewrap will occur before the maximumRewrapInterval elapses\n        if (\n            block.timestamp + sarcophagusParams.maximumRewrapInterval <\n            sarcophagusParams.resurrectionTime\n        ) {\n            revert ResurrectionTimeTooFarInFuture(\n                sarcophagusParams.resurrectionTime,\n                sarcophagusParams.maximumRewrapInterval,\n                block.timestamp + sarcophagusParams.maximumRewrapInterval\n            );\n        }\n\n        // Confirm that archaeologists are provided\n        if (selectedArchaeologists.length == 0) {\n            revert NoArchaeologistsProvided();\n        }\n        // Confirm that threshold is greater than 0\n        if (sarcophagusParams.threshold == 0) {\n            revert ThresholdCannotBeZero();\n        }\n        // Confirm that threshold is less than or equal to the number of archaeologists\n        // (k <= n in a shamir secret sharing scheme)\n        if (sarcophagusParams.threshold > selectedArchaeologists.length) {\n            revert ThresholdGreaterThanTotalNumberOfArchaeologists(\n                sarcophagusParams.threshold,\n                selectedArchaeologists.length\n            );\n        }\n\n        // create the sarcophagus\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n        sarcophagus.name = sarcophagusParams.name;\n        sarcophagus.threshold = sarcophagusParams.threshold;\n        sarcophagus.resurrectionTime = sarcophagusParams.resurrectionTime;\n        sarcophagus.maximumRewrapInterval = sarcophagusParams.maximumRewrapInterval;\n        sarcophagus.arweaveTxId = arweaveTxId;\n        sarcophagus.embalmerAddress = msg.sender;\n        sarcophagus.recipientAddress = sarcophagusParams.recipientAddress;\n        sarcophagus.cursedArchaeologistAddresses = new address[](selectedArchaeologists.length);\n\n        // track total digging fees due upon creation of sarcophagus\n        uint256 totalDiggingFees = 0;\n\n        for (uint256 i = 0; i < selectedArchaeologists.length; i++) {\n            // confirm archaeologist is registered\n            LibUtils.revertIfArchProfileDoesNotExist(selectedArchaeologists[i].archAddress);\n\n            // Confirm archaeologist isn't already cursed on sarcophagus\n            if (\n                sarcophagus\n                    .cursedArchaeologists[selectedArchaeologists[i].archAddress]\n                    .publicKey\n                    .length != 0\n            ) {\n                revert ArchaeologistListContainsDuplicate(selectedArchaeologists[i].archAddress);\n            }\n\n            if(s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] != address(0)) {\n                revert DuplicatePublicKey(selectedArchaeologists[i].publicKey);\n            }\n\n            LibUtils.verifyArchaeologistSignature(\n                selectedArchaeologists[i].publicKey,\n                sarcophagusParams.maximumRewrapInterval,\n                sarcophagusParams.creationTime,\n                selectedArchaeologists[i].diggingFee,\n                selectedArchaeologists[i].v,\n                selectedArchaeologists[i].r,\n                selectedArchaeologists[i].s,\n                selectedArchaeologists[i].archAddress\n            );\n\n            totalDiggingFees += selectedArchaeologists[i].diggingFee;\n\n            // Lock the archaeologist's free bond\n            LibBonds.lockUpBond(\n                selectedArchaeologists[i].archAddress,\n                selectedArchaeologists[i].diggingFee\n            );\n\n            // save the cursedArchaeologist and cursedArchaeologistAddress to be stored on the new sarcophagus\n            sarcophagus.cursedArchaeologists[selectedArchaeologists[i].archAddress] = LibTypes\n                .CursedArchaeologist({\n                    publicKey: selectedArchaeologists[i].publicKey,\n                    privateKey: 0,\n                    isAccused: false,\n                    diggingFee: selectedArchaeologists[i].diggingFee\n                });\n\n            sarcophagus.cursedArchaeologistAddresses[i] = selectedArchaeologists[i].archAddress;\n\n            // add address to pub key mapping\n            s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] = selectedArchaeologists[i].archAddress;\n\n            // update archaeologist-specific convenience lookup structures\n            s.publicKeyToArchaeologistAddress[\n                selectedArchaeologists[i].publicKey\n            ] = selectedArchaeologists[i].archAddress;\n            s.archaeologistSarcophagi[selectedArchaeologists[i].archAddress].push(sarcoId);\n        }\n\n        // update sarcophagus-specific convenience lookup structures\n        s.embalmerSarcophagi[msg.sender].push(sarcoId);\n        s.recipientSarcophagi[sarcophagusParams.recipientAddress].push(sarcoId);\n\n        // Transfer totalDiggingFees and the protocolFees in SARCO from embalmer to this contract\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\n        s.totalProtocolFees += protocolFees;\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\n\n        emit CreateSarcophagus(\n            sarcoId,\n            sarcophagusParams.name,\n            sarcophagusParams.resurrectionTime,\n            msg.sender,\n            sarcophagusParams.recipientAddress,\n            sarcophagus.cursedArchaeologistAddresses,\n            totalDiggingFees,\n            protocolFees,\n            arweaveTxId\n        );\n    }\n\n    /// @notice Updates the resurrectionTime on a sarcophagus. Callable by the embalmer of a sarcophagus if its\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param resurrectionTime the new resurrection time\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime) external {\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm the sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm tx sender is embalmer\n        if (sarcophagus.embalmerAddress != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\n        }\n\n        // Confirm resurrection time has not yet passed\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Confirm that new resurrection time is in future\n        if (block.timestamp >= resurrectionTime) {\n            revert NewResurrectionTimeInPast(block.timestamp, resurrectionTime);\n        }\n\n        // Confirm that new resurrection time doesn't exceed sarcophagus's maximumRewrapInterval\n        if (block.timestamp + sarcophagus.maximumRewrapInterval < resurrectionTime) {\n            revert NewResurrectionTimeTooFarInFuture(\n                resurrectionTime,\n                sarcophagus.maximumRewrapInterval,\n                block.timestamp + sarcophagus.maximumRewrapInterval\n            );\n        }\n\n        // track total digging fees across all archaeologists on the sarcophagus\n        uint256 totalDiggingFees = 0;\n\n        // pay digging fee to each cursed archaeologist on the sarcophagus that has not been accused\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\n                .cursedArchaeologists[archaeologistAddresses[i]];\n\n            // if the archaeologist hasn't been accused transfer them their digging fees\n            if (!cursedArchaeologist.isAccused) {\n                s.archaeologistRewards[archaeologistAddresses[i]] += cursedArchaeologist.diggingFee;\n                totalDiggingFees += cursedArchaeologist.diggingFee;\n            }\n        }\n\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\n\n        // Add the protocol fee to the total protocol fees in storage\n        s.totalProtocolFees += protocolFees;\n\n        // Update the resurrectionTime on the sarcophagus to the supplied value\n        sarcophagus.resurrectionTime = resurrectionTime;\n\n        // Transfer the new digging fees and protocol fees from embalmer to contract\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\n\n        emit RewrapSarcophagus(sarcoId, resurrectionTime, totalDiggingFees, protocolFees);\n    }\n\n    /// @notice Terminates a sarcophagus by setting its resurrection time to infinity and returning locked\n    /// bonds to all innocent cursed archaeologists. Callable by the embalmer of a sarcophagus if its\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\n    /// @param sarcoId the identifier of the sarcophagus\n    function burySarcophagus(bytes32 sarcoId) external {\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm the sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm tx sender is embalmer\n        if (sarcophagus.embalmerAddress != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\n        }\n        // Confirm that the current resurrection time is in the future\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Set resurrection time to infinity\n        sarcophagus.resurrectionTime = 2 ** 256 - 1;\n\n        // for each archaeologist on the sarcophagus, unlock bond and pay digging fees\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\n                .cursedArchaeologists[archaeologistAddresses[i]];\n            // if the archaeologist hasn't been accused transfer them their digging fees and return their locked bond\n            if (!cursedArchaeologist.isAccused) {\n                s.archaeologistRewards[archaeologistAddresses[i]] += cursedArchaeologist.diggingFee;\n                LibBonds.freeArchaeologist(sarcoId, archaeologistAddresses[i]);\n            }\n        }\n\n        emit BurySarcophagus(sarcoId);\n    }\n}\n"
    },
    "contracts/facets/ThirdPartyFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport {LibDiamond} from \"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\n\ncontract ThirdPartyFacet {\n    AppStorage internal s;\n\n    event AccuseArchaeologist(\n        bytes32 indexed sarcoId,\n        address indexed accuser,\n        uint256 accuserBondReward,\n        uint256 embalmerBondReward\n    );\n\n    event Clean(bytes32 indexed sarcoId, address indexed cleaner);\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice Clean has been called on a sarcophagus that has already been cleaned\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a private key on\n    error SarcophagusAlreadyCleaned(bytes32 sarcoId);\n\n    /// @notice Clean has been called before the deadline for archaeologists to publish private keys has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param publishDeadline Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\n    error TooEarlyForClean(uint256 currentTime, uint256 publishDeadline);\n\n    /// @notice Clean has been called by someone other than the admin or embalmer of the sarcophagus\n    /// @param senderAddress Address of sender\n    error SenderNotEmbalmerOrAdmin(address senderAddress);\n\n    /// @notice Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\n    error EmbalmerClaimWindowPassed(uint256 currentTime, uint256 embalmerClaimWindowEnd);\n\n    /// @notice Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\n    error TooEarlyForAdminClean(uint256 currentTime, uint256 embalmerClaimWindowEnd);\n\n\n    /// @notice Emitted when a third party attempts to accuse an archaeologist on a sarcophagus where the resurrection time has already passed\n    /// @param currentTime Timestamp of the failed accuse attempt\n    /// @param resurrectionTime Resurrection timestamp which has already passed\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\n\n    /// @notice If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod,\n    /// their locked bonds and diggingFees may be claimed by either the embalmer or the admin\n    /// embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will\n    /// be able to claim remaining locked bond and diggingFees\n    /// @param sarcoId The identifier of the sarcophagus to clean\n    function clean(bytes32 sarcoId) external {\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm the sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm the sarcophagus has not already been cleaned\n        if (sarcophagus.isCleaned) {\n            revert SarcophagusAlreadyCleaned(sarcoId);\n        }\n\n        // Confirm that the resurrectionTime + gracePeriod have passed\n        if (block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod) {\n            revert TooEarlyForClean(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\n        }\n\n        // Confirm tx sender is embalmer or admin\n        if (msg.sender != sarcophagus.embalmerAddress && msg.sender != LibDiamond.contractOwner()) {\n            revert SenderNotEmbalmerOrAdmin(msg.sender);\n        }\n\n        // if sender is embalmer, confirm current time is within embalmerClaimWindow\n        if (\n            msg.sender == sarcophagus.embalmerAddress &&\n            block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n        ) {\n            revert EmbalmerClaimWindowPassed(\n                block.timestamp,\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n            );\n        }\n\n        // if sender is admin, confirm embalmerClaimWindow has passed\n        if (\n            msg.sender == LibDiamond.contractOwner() &&\n            block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n        ) {\n            revert TooEarlyForAdminClean(\n                block.timestamp,\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n            );\n        }\n\n        // sum of locked bonds and digging fees for all archaeologists that have failed to publish private keys before publish deadline and have not been accused\n        uint256 totalDiggingFeesAndLockedBonds = 0;\n        for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\n                .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]];\n            if (!cursedArchaeologist.isAccused && cursedArchaeologist.privateKey == 0) {\n                totalDiggingFeesAndLockedBonds += cursedArchaeologist.diggingFee; // add digging fee for cursedArchaeologist\n                totalDiggingFeesAndLockedBonds += cursedArchaeologist.diggingFee; // add locked bond for cursedArchaeologist\n\n                // slash the archaeologist's locked bond for the sarcophagus\n                LibBonds.decreaseCursedBond(\n                    sarcophagus.cursedArchaeologistAddresses[i],\n                    cursedArchaeologist.diggingFee\n                );\n\n                // track that the archaeologist has had a clean on this sarcophagus\n                s.archaeologistCleanups[sarcophagus.cursedArchaeologistAddresses[i]].push(sarcoId);\n            }\n        }\n\n        // if caller is embalmer, transfer them the total locked bonds and digging fees\n        if (msg.sender == sarcophagus.embalmerAddress) {\n            s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFeesAndLockedBonds);\n        }\n\n        // if caller is admin, add total locked bonds and digging fees into protocolFees\n        if (msg.sender == LibDiamond.contractOwner()) {\n            s.totalProtocolFees += totalDiggingFeesAndLockedBonds;\n        }\n\n        sarcophagus.isCleaned = true;\n        emit Clean(sarcoId, msg.sender);\n    }\n\n    /**\n     * @notice Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id\n     * and payment address generated with the leaked private keys\n     * If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be\n     * split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer\n     *\n     * If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus\n     * state will be updated to Accused and bonds for all remaining unaccused archaeologists will be\n     * returned\n     *\n     * @param sarcoId The identifier of the sarcophagus having leaked private keys\n     * @param signatures an array of signatures of the sarcoId signed by the leaked private keys\n     * @param paymentAddress the address to which rewards should be sent if successful\n     */\n    function accuse(\n        bytes32 sarcoId,\n        Signature[] calldata signatures,\n        address paymentAddress\n    ) external {\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // verify that current time is not past resurrection time\n        if (block.timestamp > sarcophagus.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // build an array of the addresses of the archaeologists currently being accused\n        address[] memory accusedArchAddresses = new address[](signatures.length);\n\n        // track the combined locked bond across all archaeologists being accused in this call\n        // locked bond will be equal to the amount of diggingFees allocated by the embalmer to pay the archaeologist\n        uint256 totalDiggingFees = 0;\n        uint256 accusalCount = 0;\n        for (uint256 i = 0; i < signatures.length; i++) {\n            // todo: obtain signing key for signature\n            bytes memory publicKey = bytes(\"\");\n            // look up the archaeologist responsible for the publicKey\n            address accusedArchaeologistAddress = s.publicKeyToArchaeologistAddress[publicKey];\n            LibTypes.CursedArchaeologist storage accusedArchaeologist = sarcophagus\n                .cursedArchaeologists[accusedArchaeologistAddress];\n\n            // verify the accused archaeologist is cursed on the sarcophagus\n            if (accusedArchaeologist.publicKey.length == 0) {\n                revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\n            }\n\n            // if the archaeologist has already been accused on this sarcophagus break without taking action\n            if (accusedArchaeologist.isAccused) {\n                break;\n            }\n\n            // mark the archaeologist on the sarcophagus as having been accused\n            accusedArchaeologist.isAccused = true;\n            accusedArchAddresses[accusalCount++] = accusedArchaeologistAddress;\n\n            // track the sum of all digging fees for all accused archaeologists\n            totalDiggingFees += accusedArchaeologist.diggingFee;\n\n            // slash the accused archaeologist's bond\n            LibBonds.decreaseCursedBond(\n                accusedArchaeologistAddress,\n                accusedArchaeologist.diggingFee\n            );\n\n            // Save the accusal against the archaeologist\n            s.archaeologistAccusals[accusedArchaeologistAddress].push(sarcoId);\n        }\n\n        // if none of the accusals were valid because the archaeologists have all already been accused, return without taking action\n        if (accusalCount == 0) {\n            return;\n        }\n\n        // the sarcophagus is compromised if the current call has successfully accused the sss threshold of archaeologists\n        if (accusalCount >= sarcophagus.threshold) {\n            sarcophagus.isCompromised = true;\n        } else {\n            // if the current call hasn't resulted in at least sss threshold archaeologists being accused\n            // check if total number of historical accusals on sarcophagus is greater than threshold\n            uint256 totalAccusals = 0;\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\n                if (\n                    sarcophagus\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\n                        .isAccused\n                ) {\n                    totalAccusals++;\n                }\n            }\n            // the sarcophagus is compromised if k or more archaeologists have been accused over the lifetime of the sarcophagus\n            if (totalAccusals >= sarcophagus.threshold) {\n                sarcophagus.isCompromised = true;\n            }\n        }\n\n        // if k or more archaeologists have been accused over the lifetime of the sarcophagus, funds should\n        // be returned to the remaining well behaved archaeologists\n        if (sarcophagus.isCompromised) {\n            // iterate through all archaeologist addresses on the sarcophagus\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\n                // if the archaeologist has never been accused, release their locked bond back to them\n                if (\n                    !sarcophagus\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\n                        .isAccused\n                ) {\n                    LibBonds.freeArchaeologist(\n                        sarcoId,\n                        sarcophagus.cursedArchaeologistAddresses[i]\n                    );\n                }\n            }\n        }\n\n        // refund the diggingFees allocated by the embalmer to the accused archaeologists\n        // split the total bond being slashed between the embalmer and the payment address\n        (uint256 accuserBondReward, uint256 embalmerBondReward) = _distributeLoot(\n            paymentAddress,\n            sarcophagus,\n            totalDiggingFees\n        );\n\n        emit AccuseArchaeologist(sarcoId, msg.sender, accuserBondReward, embalmerBondReward);\n    }\n\n    /**\n     * @notice Takes a sarcophagus's digging fee, splits it in half, and sends\n     * to paymentAddress and embalmer\n     * @param paymentAddress payment address for the transaction caller\n     * @param sarc the sarcophagus to operate on\n     * @param totalDiggingFee the sum of digging fees of all archs that failed to fulfil their duties\n     * @return halfToSender the amount of SARCO token going to transaction\n     * sender\n     * @return halfToEmbalmer the amount of SARCO token going to embalmer\n     */\n    function _distributeLoot(\n        address paymentAddress,\n        LibTypes.Sarcophagus storage sarc,\n        uint256 totalDiggingFee\n    ) private returns (uint256, uint256) {\n        // split the sarcophagus's cursed bond into two halves\n        uint256 halfToEmbalmer = totalDiggingFee / 2;\n        uint256 halfToSender = totalDiggingFee - halfToEmbalmer;\n\n        // transfer the cursed half, plus digging fee to the\n        // embalmer\n        s.sarcoToken.transfer(sarc.embalmerAddress, totalDiggingFee + halfToEmbalmer);\n\n        // transfer the other half of the cursed bond to the transaction caller\n        s.sarcoToken.transfer(paymentAddress, halfToSender);\n\n        return (halfToSender, halfToEmbalmer);\n    }\n\n    function _hashHelper(bytes memory data) private pure returns (bytes32) {\n        return keccak256(data);\n    }\n}\n"
    },
    "contracts/libraries/LibBonds.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\n\nlibrary LibBonds {\n    /// @notice Decreases the amount stored in the freeBond mapping for an\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\n    /// the amount.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being decreased\n    /// @param amount The amount to decrease the free bond by\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Revert if the amount is greater than the current free bond\n        if (amount > s.archaeologistProfiles[archaeologist].freeBond) {\n            revert LibErrors.NotEnoughFreeBond(\n                s.archaeologistProfiles[archaeologist].freeBond,\n                amount\n            );\n        }\n\n        // Decrease the free bond amount\n        s.archaeologistProfiles[archaeologist].freeBond -= amount;\n    }\n\n    /// @notice Increases the amount stored in the freeBond mapping for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being decreased\n    /// @param amount The amount to decrease the free bond by\n    function increaseFreeBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Increase the free bond amount\n        s.archaeologistProfiles[archaeologist].freeBond += amount;\n    }\n\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\n    /// archaeologist. Reverts if the archaeologist's cursed bond is lower than\n    /// the amount.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being decreased\n    /// @param amount The amount to decrease the cursed bond by\n    function decreaseCursedBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Revert if the amount is greater than the current cursed bond\n        if (amount > s.archaeologistProfiles[archaeologist].cursedBond) {\n            revert LibErrors.NotEnoughCursedBond(\n                s.archaeologistProfiles[archaeologist].cursedBond,\n                amount\n            );\n        }\n\n        // Decrease the cursed bond amount\n        s.archaeologistProfiles[archaeologist].cursedBond -= amount;\n    }\n\n    /// @notice Increases the amount stored in the cursedBond mapping for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being decreased\n    /// @param amount The amount to decrease the cursed bond by\n    function increaseCursedBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Increase the cursed bond amount\n        s.archaeologistProfiles[archaeologist].cursedBond += amount;\n    }\n\n    /// @notice Locks up the archaeologist's bond, decreasing the\n    /// archaeologist's free bond by an amount and increasing the\n    /// archaeologist's cursed bond by the same amount.\n    /// @param archaeologist The address of the archaeologist\n    /// @param amount The amount to lock up\n    function lockUpBond(address archaeologist, uint256 amount) internal {\n        // Decrease the free bond amount\n        decreaseFreeBond(archaeologist, amount);\n\n        // Increase the cursed bond amount\n        increaseCursedBond(archaeologist, amount);\n    }\n\n    /// @notice Unlocks the archaeologist's bond, increasing the\n    /// archaeologist's free bond by an amount and decreasing the\n    /// archaeologist's cursed bond by the same amount.\n    /// @param archaeologist The address of the archaeologist\n    /// @param amount The amount to unlock\n    function unlockBond(address archaeologist, uint256 amount) internal {\n        // Decrease the cursed bond amount\n        decreaseCursedBond(archaeologist, amount);\n\n        // Increase the free bond amount\n        increaseFreeBond(archaeologist, amount);\n    }\n\n\n    /// @notice Calculates an archaeologist's cursed bond and frees them\n    /// (unlocks the cursed bond).\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\n    /// @param archaeologistAddress the address of the archaeologist to free\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\n            .sarcophagi[sarcoId]\n            .cursedArchaeologists[archaeologistAddress];\n\n        // Free up the archaeologist's locked bond\n        unlockBond(archaeologistAddress, cursedArchaeologist.diggingFee);\n    }\n}\n"
    },
    "contracts/libraries/LibErrors.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\n/**\n * @title A collection of Errors\n * @notice This library defines all of the Errors that the Sarcophagus system\n * uses.\n */\nlibrary LibErrors {\n\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\n\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\n\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\n\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\n\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\n\n    error SarcophagusInactive(bytes32 sarcoId);\n\n    error SarcophagusCompromised(bytes32 sarcoId);\n\n    error SenderNotEmbalmer(address sender, address embalmer);\n\n    error InvalidSignature(\n        // address recovered from signature via ecrecover\n        address recoveredAddress,\n        // address we expected to have signed the data\n        address expectedAddress\n    );\n\n}\n"
    },
    "contracts/libraries/LibPrivateKeys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n\n/**\n * @title Private key verification\n * @notice Implements a private key -> public key checking function\n * @dev modified from https://github.com/1Address/ecsol, removes extra code\n * which isn't necessary for our Sarcophagus implementation\n */\nlibrary LibPrivateKeys {\n    /**\n     * @notice Given a private key and a public key, determines if that public\n     * key was derived from the private key\n     * @dev based on https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\n     * @param privKey an secp256k1 private key\n     * @param pubKey an uncompressed 65 byte secp256k1 public key\n     * @return bool indicating whether the public key is derived from the\n     * private key\n     */\n    function isPublicKeyFromPrivateKey(bytes32 privKey, bytes memory pubKey) internal pure returns (bool) {\n        // removes the 0x04 prefix from an uncompressed public key\n        bytes memory truncatedPublicKey = new bytes(pubKey.length-1);\n        for (uint256 i = 1; i < pubKey.length; i++) {\n            truncatedPublicKey[i-1] = pubKey[i];\n        }\n\n        // generator point coordinates and order of secp256k1\n        uint256 gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n        uint256 gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n        uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n\n        address signer = ecrecover(\n            0,\n            gy % 2 != 0 ? 28 : 27,\n            bytes32(gx),\n            bytes32(mulmod(uint256(privKey), gx, m))\n        );\n\n        address xyAddress = address(\n            uint160(uint256(keccak256(truncatedPublicKey)) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        );\n        return xyAddress == signer;\n    }\n}\n"
    },
    "contracts/libraries/LibTypes.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\n/**\n * @title Types shared across facets for the Sarcophagus diamond\n */\nlibrary LibTypes {\n    struct Sarcophagus {\n        // never zero - use for existence checks\n        uint256 resurrectionTime;\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\n        bool isCompromised;\n        bool isCleaned;\n        string name;\n        uint8 threshold;\n        uint256 maximumRewrapInterval;\n        string arweaveTxId;\n        address embalmerAddress;\n        address recipientAddress;\n        address[] cursedArchaeologistAddresses;\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\n    }\n\n    struct CursedArchaeologist {\n        // never empty - use for existence checks\n        bytes publicKey;\n        bytes32 privateKey;\n        bool isAccused;\n        uint256 diggingFee;\n    }\n\n    struct ArchaeologistProfile {\n        bool exists; // todo: use peerid.length instead of exists\n        string peerId;\n        uint256 minimumDiggingFee;\n        uint256 maximumRewrapInterval;\n        uint256 freeBond;\n        uint256 cursedBond;\n    }\n}\n"
    },
    "contracts/libraries/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\n\n/**\n * @title Utility functions used within the Sarcophagus system\n * @notice This library implements various functions that are used throughout\n * Sarcophagus, mainly to DRY up the codebase\n * @dev these functions are all stateless, public, pure/view\n */\nlibrary LibUtils {\n    /**\n     * @notice The archaeologist needs to sign off on two pieces of data\n     * to guarantee their unrwap will be successful\n     *\n     * @param publicKey public key archaeologist is responsible for\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\n     * @param diggingFee that the archaeologist has agreed to for the sarcophagus\n     * @param v signature element\n     * @param r signature element\n     * @param s signature element\n     * @param account address to confirm signature of data came from\n     */\n    function verifyArchaeologistSignature(\n        bytes memory publicKey, // todo: data location?\n        uint256 agreedMaximumRewrapInterval,\n        uint256 timestamp,\n        uint256 diggingFee,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address account\n    ) internal pure {\n        // Hash the hash of the data payload\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(\n                    abi.encode(\n                        publicKey,\n                        agreedMaximumRewrapInterval,\n                        diggingFee,\n                        timestamp\n                    )\n                )\n            )\n        );\n\n        // Generate the address from the signature.\n        // ecrecover should always return a valid address.\n        address recoveredAddress = ecrecover(messageHash, v, r, s);\n\n        if (recoveredAddress != account) {\n            revert LibErrors.InvalidSignature(recoveredAddress, account);\n        }\n    }\n\n    /// @notice Checks if an archaeologist profile exists and\n    /// reverts if so\n    ///\n    /// @param archaeologist the archaeologist address to check existence of\n    function revertIfArchProfileExists(address archaeologist) internal view {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        if (s.archaeologistProfiles[archaeologist].exists) {\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\n        }\n    }\n\n    /// @notice Checks if an archaeologist profile doesn't exist and\n    /// reverts if so\n    ///\n    /// @param archaeologist the archaeologist address to check lack of existence of\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        if (!s.archaeologistProfiles[archaeologist].exists) {\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\n        }\n    }\n\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\n    /// @return The protocol fees amount\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 100;\n    }\n}\n"
    },
    "contracts/storage/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\n\n/**\n* Global diamond storage struct to be shared across facets\n* TODO: Implement diamond storage pattern and consider splitting storage into facet specific structs\n*/\nstruct AppStorage {\n    // SARCO token contract\n    IERC20 sarcoToken;\n\n    // total protocol fees available to be withdrawn by the admin\n    uint256 totalProtocolFees;\n\n    /**\n    * Protocol level admin configurations\n    */\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap\n    uint256 protocolFeeBasePercentage;\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time\n    uint256 gracePeriod;\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated\n    uint256 expirationThreshold;\n    // window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\n    uint256 embalmerClaimWindow;\n\n    /**\n    * Ownership mappings\n    */\n    // embalmer address => ids of sarcophagi they've created\n    mapping(address => bytes32[]) embalmerSarcophagi;\n    // archaeologist address =>  ids of sarcophagi they're protecting\n    mapping(address => bytes32[]) archaeologistSarcophagi;\n    // recipient address =>  ids of sarcophagi they're recipient on\n    mapping(address => bytes32[]) recipientSarcophagi;\n\n    // public key => archaeologist address\n    mapping(bytes => address) publicKeyToArchaeologistAddress;\n\n    // sarcophagus id => sarcophagus object\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\n\n    // archaeologist addresses\n    address[] archaeologistProfileAddresses;\n    // archaeologist address => profile\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\n\n\n    // current balance of rewards available for the archaeologist to withdraw\n    mapping(address => uint256) archaeologistRewards;\n\n\n    /**\n    * Archaeologist reputation statistics\n    * todo: could these be organized differently?\n    */\n    mapping(address => bytes32[]) archaeologistSuccesses;\n    mapping(address => bytes32[]) archaeologistAccusals;\n    mapping(address => bytes32[]) archaeologistCleanups;\n}\n\nlibrary LibAppStorage {\n    function getAppStorage() internal pure returns (AppStorage storage s) {\n        // Set the position of our struct in contract storage\n        // Since AppStorage s is the first and only state variable declared in\n        // facets its position in contract storage is 0\n        assembly {\n            s.slot := 0\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}