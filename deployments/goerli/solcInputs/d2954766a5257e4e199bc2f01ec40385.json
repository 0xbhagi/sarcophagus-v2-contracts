{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/facets/AdminFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\n\nimport {LibDiamond} from \"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\";\n\ncontract AdminFacet {\n\n    /// @notice Withdraws the total protocol fee amount from the contract.\n    /// @dev Can only be called by the owner.\n    function withdrawProtocolFees() external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        LibDiamond.enforceIsContractOwner();\n        // Get the total protocol fees from storage\n        uint256 totalProtocolFees = s.totalProtocolFees;\n\n        // Set the total protocol fees to 0 before the transfer to avoid reentrancy\n        s.totalProtocolFees = 0;\n\n        // Transfer the protocol fee amount to the sender after setting state\n        s.sarcoToken.transfer(msg.sender, totalProtocolFees);\n    }\n\n    /// @notice Sets the protocol fee base percentage, used to calculate protocol fees\n    /// @param protocolFeeBasePercentage percentage to set\n    /// @dev Can only be called by the owner.\n    function setProtocolFeeBasePercentage(uint256 protocolFeeBasePercentage) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.protocolFeeBasePercentage = protocolFeeBasePercentage;\n    }\n\n    /// @notice Sets the digging fee / cursed bond ratio\n    /// used to calculate how much bond archaeologists must lock per curse.\n    /// @param cursedBondPercentage ratio to set.\n    /// @dev Can only be called by the owner.\n    function setCursedBondPercentage(uint256 cursedBondPercentage) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.cursedBondPercentage = cursedBondPercentage;\n    }\n\n    /// @notice Updates the resurrection grace period\n    /// @param gracePeriod to set\n    /// @dev Can only be called by the diamond owner.\n    function setGracePeriod(uint256 gracePeriod) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.gracePeriod = gracePeriod;\n    }\n\n    /// @notice Updates the embalmerClaimWindow\n    /// @param embalmerClaimWindow to set\n    /// @dev Can only be called by the diamond owner.\n    function setEmbalmerClaimWindow(uint256 embalmerClaimWindow) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.embalmerClaimWindow = embalmerClaimWindow;\n    }\n\n    /// @notice Updates the expirationThreshold used during sarcophagus creation\n    /// @param expirationThreshold to set\n    /// @dev Can only be called by the diamond owner.\n    function setExpirationThreshold(uint256 expirationThreshold) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.expirationThreshold = expirationThreshold;\n    }\n}\n"
    },
    "contracts/facets/ArchaeologistFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport \"../storage/LibAppStorage.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {LibPrivateKeys} from \"../libraries/LibPrivateKeys.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\n\ncontract ArchaeologistFacet {\n    /// @notice Emitted when an archaeologist successfully publishes their private key for a sarcophagus\n    /// @param sarcoId ID of sarcophagus archaeologist has published the private key on\n    /// @param privateKey private key that has been published\n    event PublishPrivateKey(\n        bytes32 indexed sarcoId,\n        bytes32 privateKey,\n        address indexed archaeologist\n    );\n\n    event DepositFreeBond(address indexed archaeologist, uint256 depositedBond);\n\n    event RegisterArchaeologist(\n        address indexed archaeologist,\n        string peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond,\n        uint256 maximumResurrectionTime\n    );\n\n    event UpdateArchaeologist(\n        address indexed archaeologist,\n        string peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond,\n        uint256 maximumResurrectionTime\n    );\n\n    event WithdrawFreeBond(address indexed archaeologist, uint256 withdrawnBond);\n\n    event WithdrawReward(address indexed archaeologist, uint256 withdrawnReward);\n\n    /// @notice An archaeologist that has already been successfully accused has attempted to publish their private key\n    /// @param archaeologistAddress Address of accused archaeologist who is attempting to publish their private key\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a key on\n    error ArchaeologistHasBeenAccused(address archaeologistAddress, bytes32 sarcoId);\n\n    /// @notice Archaeologist has attempted to publish a key before the resurrection time\n    /// @param currentTime Timestamp of the failed publish attempt\n    /// @param resurrectionTime Time after which the sarcophagus can be resurrected\n    error TooEarlyForPublish(uint256 currentTime, uint256 resurrectionTime);\n\n    /// @notice Archaeologist has attempted to publish a key after the end of the resurrection window\n    /// @param currentTime Timestamp of the failed publish attempt\n    /// @param publishDeadline Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)\n    error TooLateForPublish(uint256 currentTime, uint256 publishDeadline);\n\n    /// @notice Archaeologist has attempted to publish a key for a sarcophagus twice\n    /// @param archaeologistAddress address of publishing archaeologist\n    error ArchaeologistAlreadyPublishedPrivateKey(address archaeologistAddress);\n\n    /// @notice Archaeologist has attempted to set a zero minimumDiggingFeePerSecond or maximumRewrapInterval\n    error CannotSetZeroProfileValue();\n\n    /// @notice Archaeologist has attempted to publish the incorrect private key for a sarcophagus\n    /// @param archaeologistAddress address of publishing archaeologist\n    /// @param publicKey publicKey stored for archaeologist on the sarcophagus\n    /// @param privateKey privateKey the archaeologist has attempted to publish\n    error ArchaeologistPublishedIncorrectPrivateKey(\n        address archaeologistAddress,\n        bytes publicKey,\n        bytes32 privateKey\n    );\n\n    /// @notice Registers the archaeologist profile\n    /// @param peerId The libp2p identifier for the archaeologist\n    /// @param minimumDiggingFeePerSecond The archaeologist's minimum amount to earn per second for being cursed\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\n    /// for a resurrection\n    /// @param freeBond How much bond the archaeologist wants to deposit during the register call (if any)\n    /// @param maximumResurrectionTime The time beyond which the archaeologist is not willing to accept new curses or rewraps\n    function registerArchaeologist(\n        string memory peerId,\n        uint256 minimumDiggingFeePerSecond,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond,\n        uint256 maximumResurrectionTime\n    ) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        // verify that the archaeologist does not already exist\n        LibUtils.revertIfArchProfileExists(msg.sender);\n\n        if (maximumRewrapInterval == 0 || minimumDiggingFeePerSecond == 0) {\n            revert CannotSetZeroProfileValue();\n        }\n\n        // create a new archaeologist\n        LibTypes.ArchaeologistProfile memory newArch = LibTypes.ArchaeologistProfile({\n            peerId: peerId,\n            minimumDiggingFeePerSecond: minimumDiggingFeePerSecond,\n            maximumResurrectionTime: maximumResurrectionTime,\n            maximumRewrapInterval: maximumRewrapInterval,\n            freeBond: freeBond,\n            cursedBond: 0\n        });\n\n        // transfer SARCO tokens from the archaeologist to this contract, to be\n        // used as their free bond. can be 0.\n        if (freeBond > 0) {\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\n        }\n\n        // save the new archaeologist into relevant data structures\n        s.archaeologistProfiles[msg.sender] = newArch;\n        s.archaeologistProfileAddresses.push(msg.sender);\n\n        emit RegisterArchaeologist(\n            msg.sender,\n            newArch.peerId,\n            newArch.minimumDiggingFeePerSecond,\n            newArch.maximumRewrapInterval,\n            newArch.freeBond,\n            newArch.maximumResurrectionTime\n        );\n    }\n\n    /// @notice Updates the archaeologist profile\n    /// @param peerId The libp2p identifier for the archaeologist\n    /// @param minimumDiggingFeePerSecond The archaeologist's minimum amount to earn per second for being cursed\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\n    /// for a resurrection\n    /// freeBond How much bond the archaeologist wants to deposit during the update call (if any)\n    function updateArchaeologist(\n        string memory peerId,\n        uint256 minimumDiggingFeePerSecond,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond,\n        uint256 maximumResurrectionTime\n    ) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        // verify that the archaeologist exists\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n\n        if (maximumRewrapInterval == 0 || minimumDiggingFeePerSecond == 0) {\n            revert CannotSetZeroProfileValue();\n        }\n\n        LibTypes.ArchaeologistProfile storage existingArch = s.archaeologistProfiles[msg.sender];\n        existingArch.peerId = peerId;\n        existingArch.minimumDiggingFeePerSecond = minimumDiggingFeePerSecond;\n        existingArch.maximumRewrapInterval = maximumRewrapInterval;\n        existingArch.maximumResurrectionTime = maximumResurrectionTime;\n\n        // transfer SARCO tokens from the archaeologist to this contract, to be\n        // used as their free bond. can be 0.\n        if (freeBond > 0) {\n            s.archaeologistProfiles[msg.sender].freeBond += freeBond;\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\n        }\n\n        emit UpdateArchaeologist(\n            msg.sender,\n            existingArch.peerId,\n            existingArch.minimumDiggingFeePerSecond,\n            existingArch.maximumRewrapInterval,\n            existingArch.freeBond,\n            existingArch.maximumResurrectionTime\n        );\n    }\n\n    /// @notice Deposits an archaeologist's free bond to the contract.\n    /// @param amount The amount to deposit\n    function depositFreeBond(uint256 amount) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n        // Increase the archaeologist's free bond in app storage\n        s.archaeologistProfiles[msg.sender].freeBond += amount;\n\n        // Transfer the amount of sarcoToken from the archaeologist to the contract\n        s.sarcoToken.transferFrom(msg.sender, address(this), amount);\n        // Emit an event\n        emit DepositFreeBond(msg.sender, amount);\n    }\n\n    /// @notice Withdraws an archaeologist's free bond from the contract.\n    /// @param amount The amount to withdraw\n    function withdrawFreeBond(uint256 amount) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n        // Decrease the archaeologist's free bond amount.\n        // Reverts if there is not enough free bond on the contract.\n        LibBonds.decreaseFreeBond(msg.sender, amount);\n\n        // Transfer the amount of sarcoToken to the archaeologist\n        s.sarcoToken.transfer(msg.sender, amount);\n\n        // Emit an event\n        emit WithdrawFreeBond(msg.sender, amount);\n    }\n\n    /// @notice Withdraws all rewards from an archaeologist's reward pool\n    function withdrawReward() external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        uint256 amountToWithdraw = s.archaeologistRewards[msg.sender];\n        s.archaeologistRewards[msg.sender] = 0;\n\n        // Transfer the amount of sarcoToken to the archaeologist\n        s.sarcoToken.transfer(msg.sender, amountToWithdraw);\n\n        emit WithdrawReward(msg.sender, amountToWithdraw);\n    }\n\n    /// @notice Publishes the private key for which the archaeologist is responsible during the\n    /// sarcophagus resurrection window.\n    /// Pays digging fees to the archaeologist and releases their locked bond.\n    /// Cannot be called on a compromised or buried sarcophagus.\n    /// @param sarcoId The identifier of the sarcophagus for which the archaeologist is responsible\n    /// @param privateKey The private key the archaeologist is publishing\n    function publishPrivateKey(bytes32 sarcoId, bytes32 privateKey) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm current time is after resurrectionTime\n        if (block.timestamp < sarcophagus.resurrectionTime) {\n            revert TooEarlyForPublish(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Confirm current time is within gracePeriod\n        if (block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod) {\n            revert TooLateForPublish(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\n        }\n\n        // Confirm tx sender is an archaeologist on the sarcophagus\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\n            .sarcophagi[sarcoId]\n            .cursedArchaeologists[msg.sender];\n        if (cursedArchaeologist.publicKey.length == 0) {\n            revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\n        }\n\n        // Confirm archaeologist has not already leaked their private key\n        if (cursedArchaeologist.isAccused) {\n            revert ArchaeologistHasBeenAccused(msg.sender, sarcoId);\n        }\n\n        // Confirm archaeologist has not already published their private key\n        if (cursedArchaeologist.privateKey != 0) {\n            revert ArchaeologistAlreadyPublishedPrivateKey(msg.sender);\n        }\n\n        // Confirm that the private key being submitted matches the public key stored on the\n        // sarcophagus for this archaeologist\n        if (!LibPrivateKeys.isPublicKeyOfPrivateKey(privateKey, cursedArchaeologist.publicKey)) {\n            revert ArchaeologistPublishedIncorrectPrivateKey(\n                msg.sender,\n                cursedArchaeologist.publicKey,\n                privateKey\n            );\n        }\n\n        // Store the private key on cursed archaeologist\n        cursedArchaeologist.privateKey = privateKey;\n\n        // Free archaeologist locked bond and transfer digging fees\n        LibBonds.freeArchaeologist(sarcoId, msg.sender);\n\n        // Save the successful sarcophagus against the archaeologist\n        s.archaeologistSuccesses[msg.sender].push(sarcoId);\n\n        emit PublishPrivateKey(sarcoId, privateKey, msg.sender);\n    }\n}\n"
    },
    "contracts/facets/EmbalmerFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport \"../storage/LibAppStorage.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\n\ncontract EmbalmerFacet {\n    /// @notice Emitted when a sarcophagus is created\n    /// @param sarcoId Id of the new sarcophagus\n    /// @param name Name of the new sarcophagus\n    /// @param resurrectionTime Resurrection time of the new sarcophagus\n    /// @param embalmer Address of embalmer\n    /// @param recipient Address of recipient\n    /// @param cursedArchaeologists Array of addresses of cursed archaeologists\n    /// @param totalDiggingFees Total digging fees charged to embalmer to create the sarcophagus\n    /// @param createSarcophagusProtocolFees Total protocol fees charged to embalmer to create the sarcophagus\n    /// @param arweaveTxId arweave tx id for the sarcophagus\n    event CreateSarcophagus(\n        bytes32 indexed sarcoId,\n        string name,\n        uint256 resurrectionTime,\n        address embalmer,\n        address recipient,\n        address[] cursedArchaeologists,\n        uint256 totalDiggingFees,\n        uint256 createSarcophagusProtocolFees,\n        string arweaveTxId\n    );\n\n    /// @notice Emitted when a sarcophagus is rewrapped\n    /// @param sarcoId Id of sarcophagus that was rewrapped\n    /// @param resurrectionTime New resurrection time for the sarcophagus\n    /// @param totalDiggingFees Total digging fees charged to the embalmer for the rewrap\n    /// @param rewrapSarcophagusProtocolFees Total protocol fees charged to the embalmer for the rewrap\n    event RewrapSarcophagus(\n        bytes32 indexed sarcoId,\n        uint256 resurrectionTime,\n        uint256 totalDiggingFees,\n        uint256 rewrapSarcophagusProtocolFees\n    );\n\n    /// @notice Emitted when a sarcophagus is buried\n    /// @param sarcoId Id of sarcophagus that was buried\n    event BurySarcophagus(bytes32 indexed sarcoId);\n\n    /// @notice Parameters of a sarcophagus, supplied during sarcophagus creation\n    struct SarcophagusParams {\n        string name;\n        // highest rewrap interval cursed archaeologists have agreed to accept for lifetime of sarcophagus\n        uint256 maximumRewrapInterval;\n        // The timestamp beyond which the sarcophagus can no longer be rewrapped\n        uint256 maximumResurrectionTime;\n        address recipientAddress;\n        uint256 resurrectionTime;\n        uint8 threshold;\n        uint256 creationTime;\n    }\n\n    /// @notice Parameters of an archaeologist's curse, supplied during sarcophagus creation\n    struct CurseParams {\n        bytes publicKey;\n        address archAddress;\n        uint256 diggingFeePerSecond;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an id that is already in use\n    /// @param sarcoId Id that is already in use\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with expired parameters\n    /// @param currentTime Timestamp of the failed create attempt\n    /// @param creationTime Time when the sarcophagus parameters were created\n    /// @param creationDeadline Deadline for creation of a sarcophagus with the supplied parameters\n    error SarcophagusParametersExpired(\n        uint256 currentTime,\n        uint256 creationTime,\n        uint256 creationDeadline\n    );\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with no archaeologists\n    error NoArchaeologistsProvided();\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a shamir secret sharing threshold of 0\n    error ThresholdCannotBeZero();\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with more required archaeologists than total archaeologists\n    error ThresholdGreaterThanTotalNumberOfArchaeologists(\n        uint8 threshold,\n        uint256 totalNumberOfArchaeologists\n    );\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an archaeologist list that contains the same archaeologist more than once\n    error ArchaeologistListContainsDuplicate(address archaeologistAddress);\n\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that has already passed\n    /// @param currentTime Timestamp of the failed rewrap attempt\n    /// @param resurrectionTime Resurrection timestamp which has already passed\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a public key that has already been assigned to another sarcophagus\n    /// @param publicKey the duplicated public key\n    error DuplicatePublicKey(bytes publicKey);\n\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that exceeds the maximum rewrap interval\n    /// @param resurrectionTime Resurrection timestamp which is too far in the future\n    /// @param sarcophagusMaximumRewrapInterval Maximum rewrap interval set for the sarcophagus\n    /// @param maximumPermissibleResurrectionTime Resurrection timestamp which is too far in the future\n    error ResurrectionTimeTooFarInFuture(\n        uint256 resurrectionTime,\n        uint256 sarcophagusMaximumRewrapInterval,\n        uint256 maximumPermissibleResurrectionTime\n    );\n\n    /// @notice Emitted when the resurrection time defined during sarcohpagus creation or rewrap goes past the max resurrection time\n    /// @param resurrectionTime The resurrection time defined during the sarcophagus creation or rewrap\n    /// @param maxResurrectionTime The maximum allowed resurrection time\n    error ResurrectionTimePastMaxResurrectionTime(\n        uint256 resurrectionTime,\n        uint256 maxResurrectionTime\n    );\n\n    error NewResurrectionTimeInPast(uint256 currentTime, uint256 newResurrectionTime);\n\n    error NewResurrectionTimeIsZero();\n\n    error NewResurrectionTimeTooFarInFuture(\n        uint256 resurrectionTime,\n        uint256 sarcophagusMaximumRewrapInterval,\n        uint256 maximumPermissibleResurrectionTime\n    );\n\n    error ResurrectionTimeTooFarPastPreviousResurrectionTime(\n        uint256 resurrectionTime,\n        uint256 previousResurrectionTime\n    );\n\n    /// @notice Creates a sarcophagus with the supplied parameters and locks\n    /// a portion of each archaeologist's freeBond equal to the digging fees calculated for the duration\n    /// of the sarcophagus until its resurrection time.\n    ///\n    /// Verifies that each supplied archaeologist has signed off on the sarcophagus negotiation parameters:\n    ///    - `publicKey` that matches the private key the archaeologist is responsible for\n    ///    - `maximumRewrapInterval` to be enforced for the lifetime of the sarcophagus. No new resurrection time for future rewraps may exceed this interval from time of rewrap.\n    ///    - `creationTime` of sarcophagus\n    ///    - `diggingFeePerSecond` agreed to be paid to the archaeologist during the lifetime of the sarcophagus. Constant.\n    ///\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param sarcophagusParams params to set on sarcophagus being created\n    /// @param selectedArchaeologists the archaeologists the embalmer has selected to curse\n    /// @param arweaveTxId id of tx storing the sarcophagus payload on arweave\n    function createSarcophagus(\n        bytes32 sarcoId,\n        SarcophagusParams calldata sarcophagusParams,\n        CurseParams[] calldata selectedArchaeologists,\n        string calldata arweaveTxId\n    ) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Confirm that sarcophagus with supplied id doesn't already exist\n        if (s.sarcophagi[sarcoId].resurrectionTime > 0) {\n            revert SarcophagusAlreadyExists(sarcoId);\n        }\n\n        // Ensure too much time hasn't passed since the sarcophagus `creationTime` that has been signed\n        // off by its cursed archaeologists.\n        if (block.timestamp > sarcophagusParams.creationTime + s.expirationThreshold) {\n            revert SarcophagusParametersExpired(\n                block.timestamp,\n                sarcophagusParams.creationTime,\n                sarcophagusParams.creationTime + s.expirationThreshold\n            );\n        }\n\n        // Confirm that resurrection time is in the future\n        if (block.timestamp >= sarcophagusParams.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagusParams.resurrectionTime);\n        }\n\n        // Confirm that resurrection or rewrap will occur before the maximumRewrapInterval elapses\n        if (\n            block.timestamp + sarcophagusParams.maximumRewrapInterval <\n            sarcophagusParams.resurrectionTime\n        ) {\n            revert ResurrectionTimeTooFarInFuture(\n                sarcophagusParams.resurrectionTime,\n                sarcophagusParams.maximumRewrapInterval,\n                block.timestamp + sarcophagusParams.maximumRewrapInterval\n            );\n        }\n\n        // Confirm that the resurrection time is less than the max resurrection time\n        if (sarcophagusParams.resurrectionTime > sarcophagusParams.maximumResurrectionTime) {\n            revert ResurrectionTimePastMaxResurrectionTime(\n                sarcophagusParams.resurrectionTime,\n                sarcophagusParams.maximumResurrectionTime\n            );\n        }\n\n        // Validate archaeologist and threshold lengths\n        if (selectedArchaeologists.length == 0) {\n            revert NoArchaeologistsProvided();\n        }\n\n        if (sarcophagusParams.threshold == 0) {\n            revert ThresholdCannotBeZero();\n        }\n\n        // Ensure that k <= n in the effective k-of-n shamir secret sharing scheme\n        // used to distribute keyshares among archaeologists\n        if (sarcophagusParams.threshold > selectedArchaeologists.length) {\n            revert ThresholdGreaterThanTotalNumberOfArchaeologists(\n                sarcophagusParams.threshold,\n                selectedArchaeologists.length\n            );\n        }\n\n        // create the sarcophagus\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n        sarcophagus.name = sarcophagusParams.name;\n        sarcophagus.threshold = sarcophagusParams.threshold;\n        sarcophagus.resurrectionTime = sarcophagusParams.resurrectionTime;\n        sarcophagus.previousRewrapTime = sarcophagusParams.creationTime;\n        sarcophagus.maximumRewrapInterval = sarcophagusParams.maximumRewrapInterval;\n        sarcophagus.maximumResurrectionTime = sarcophagusParams.maximumResurrectionTime;\n        sarcophagus.arweaveTxId = arweaveTxId;\n        sarcophagus.embalmerAddress = msg.sender;\n        sarcophagus.recipientAddress = sarcophagusParams.recipientAddress;\n        sarcophagus.cursedArchaeologistAddresses = new address[](selectedArchaeologists.length);\n        sarcophagus.cursedBondPercentage = s.cursedBondPercentage;\n\n        // track total digging fees due upon creation of sarcophagus\n        uint256 totalDiggingFees = 0;\n\n        for (uint256 i = 0; i < selectedArchaeologists.length; i++) {\n            LibUtils.revertIfArchProfileDoesNotExist(selectedArchaeologists[i].archAddress);\n\n            // Confirm archaeologist isn't already cursed on this sarcophagus (no duplicates)\n            if (\n                sarcophagus\n                    .cursedArchaeologists[selectedArchaeologists[i].archAddress]\n                    .publicKey\n                    .length != 0\n            ) {\n                revert ArchaeologistListContainsDuplicate(selectedArchaeologists[i].archAddress);\n            }\n\n            // Confirm archaeologist is not re-using a key pair\n            if (\n                s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] != address(0)\n            ) {\n                revert DuplicatePublicKey(selectedArchaeologists[i].publicKey);\n            }\n\n            LibUtils.verifyArchaeologistSignature(\n                sarcophagusParams.maximumRewrapInterval,\n                sarcophagusParams.maximumResurrectionTime,\n                sarcophagusParams.creationTime,\n                selectedArchaeologists[i]\n            );\n\n            // Curse the archaeologist on this sarcophagus\n            uint256 diggingFeesDue = LibBonds.curseArchaeologist(\n                sarcoId,\n                selectedArchaeologists[i],\n                i\n            );\n\n            totalDiggingFees += diggingFeesDue;\n\n            // \"Consume\" this public key so it cannot be reused in the future\n            s.publicKeyToArchaeologistAddress[\n                selectedArchaeologists[i].publicKey\n            ] = selectedArchaeologists[i].archAddress;\n        }\n\n        // Add this sarcophagus id to the embalmer's record\n        s.embalmerSarcophagi[msg.sender].push(sarcoId);\n\n        // Add this sarcophagus id to the recipient's record\n        s.recipientSarcophagi[sarcophagusParams.recipientAddress].push(sarcoId);\n\n        // Transfer totalDiggingFees and the protocolFees in SARCO from embalmer to this contract\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\n        s.totalProtocolFees += protocolFees;\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\n\n        emit CreateSarcophagus(\n            sarcoId,\n            sarcophagusParams.name,\n            sarcophagusParams.resurrectionTime,\n            msg.sender,\n            sarcophagusParams.recipientAddress,\n            sarcophagus.cursedArchaeologistAddresses,\n            totalDiggingFees,\n            protocolFees,\n            arweaveTxId\n        );\n    }\n\n    /// @notice Updates the resurrectionTime on a sarcophagus. Callable by the embalmer of a sarcophagus if its\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param resurrectionTime the new resurrection time\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm the sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        if (resurrectionTime == 0) {\n            revert NewResurrectionTimeIsZero();\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm tx sender is embalmer\n        if (sarcophagus.embalmerAddress != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\n        }\n\n        // Confirm resurrection time has not yet passed\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Confirm that new resurrection time is in future\n        if (block.timestamp >= resurrectionTime) {\n            revert NewResurrectionTimeInPast(block.timestamp, resurrectionTime);\n        }\n\n        // Confirm that new resurrection time doesn't exceed sarcophagus's maximumRewrapInterval\n        if (block.timestamp + sarcophagus.maximumRewrapInterval < resurrectionTime) {\n            revert NewResurrectionTimeTooFarInFuture(\n                resurrectionTime,\n                sarcophagus.maximumRewrapInterval,\n                block.timestamp + sarcophagus.maximumRewrapInterval\n            );\n        }\n\n        // Confirm that the new resurrection time doesn't exceed the maximumResurrectionTime\n        if (sarcophagus.maximumResurrectionTime < resurrectionTime) {\n            revert ResurrectionTimePastMaxResurrectionTime(\n                resurrectionTime,\n                sarcophagus.maximumResurrectionTime\n            );\n        }\n\n        // track total digging fees to be paid by embalmer across all archaeologists on the sarcophagus\n        uint256 totalDiggingFees = 0;\n\n        // pay digging fee to each cursed archaeologist on the sarcophagus that has not been accused\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\n        uint256 cursedBondPercentage = sarcophagus.cursedBondPercentage;\n\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\n                .cursedArchaeologists[archaeologistAddresses[i]];\n\n            if (!cursedArchaeologist.isAccused) {\n                uint256 prevDiggingFees = cursedArchaeologist.diggingFeePerSecond *\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\n                uint256 newDiggingFees = cursedArchaeologist.diggingFeePerSecond *\n                    (resurrectionTime - block.timestamp);\n\n                // If the new digging fees are greater than the previous digging fees, we need to\n                // increase the archaeologist's locked bond\n                if (newDiggingFees > prevDiggingFees) {\n                    uint256 cursedBondIncrease = (newDiggingFees - prevDiggingFees) * cursedBondPercentage / 100;\n\n                    // If the previous cycle's rewards can't cover the cursed bond increase, revert\n                    if (cursedBondIncrease > prevDiggingFees) {\n                        revert ResurrectionTimeTooFarPastPreviousResurrectionTime(\n                            resurrectionTime,\n                            sarcophagus.resurrectionTime\n                        );\n                    }\n\n                    // Increase the archaeologist's cursed bond\n                    s\n                        .archaeologistProfiles[archaeologistAddresses[i]]\n                        .cursedBond += cursedBondIncrease;\n\n                    // Rewards are now previous digging fees - difference\n                    s.archaeologistRewards[archaeologistAddresses[i]] +=\n                        prevDiggingFees -\n                        cursedBondIncrease;\n                } else if (newDiggingFees < prevDiggingFees) {\n                    uint256 cursedBondDecrease = (prevDiggingFees - newDiggingFees) * cursedBondPercentage / 100;\n\n                    // Decrease archaeologist's cursed bond by the difference\n                    s.archaeologistProfiles[archaeologistAddresses[i]].cursedBond -= cursedBondDecrease;\n\n                    // Increase archaeologist's free bond by the difference\n                    s.archaeologistProfiles[archaeologistAddresses[i]].freeBond += cursedBondDecrease;\n\n                    // Rewards are equal to the previous digging fees\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\n                } else {\n                    // Rewards are equal to the previous digging fees\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\n                }\n\n                // Add digging fees due for the new interval\n                totalDiggingFees += newDiggingFees;\n            }\n        }\n\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\n\n        // Add the protocol fee to the total protocol fees in storage\n        s.totalProtocolFees += protocolFees;\n\n        // Update the sarcophagus resurrectionTime and previousRewrapTime\n        sarcophagus.resurrectionTime = resurrectionTime;\n        sarcophagus.previousRewrapTime = block.timestamp;\n\n        // Transfer the new digging fees and protocol fees from embalmer to contract\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\n\n        emit RewrapSarcophagus(sarcoId, resurrectionTime, totalDiggingFees, protocolFees);\n    }\n\n    /// @notice Terminates a sarcophagus by setting its resurrection time to infinity and returning locked\n    /// bonds to all innocent cursed archaeologists. Callable by the embalmer of a sarcophagus if its\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\n    /// @param sarcoId the identifier of the sarcophagus\n    function burySarcophagus(bytes32 sarcoId) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm the sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm tx sender is embalmer\n        if (sarcophagus.embalmerAddress != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\n        }\n        // Confirm that the current resurrection time is in the future\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // for each archaeologist on the sarcophagus, unlock bond and pay digging fees\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\n                .cursedArchaeologists[archaeologistAddresses[i]];\n\n            // if the archaeologist hasn't been accused transfer them their digging fees and return their locked bond\n            if (!cursedArchaeologist.isAccused) {\n                LibBonds.freeArchaeologist(sarcoId, archaeologistAddresses[i]);\n            }\n        }\n\n        // Set resurrection time to infinity\n        sarcophagus.resurrectionTime = 2 ** 256 - 1;\n\n        emit BurySarcophagus(sarcoId);\n    }\n}\n"
    },
    "contracts/facets/ThirdPartyFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport {LibDiamond} from \"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\n\ncontract ThirdPartyFacet {\n    event AccuseArchaeologist(\n        bytes32 indexed sarcoId,\n        address indexed accuser,\n        uint256 totalSlashedBondDistributed,\n        uint256 totalDiggingFeesDistributed,\n        address[] indexed accusedArchAddresses\n    );\n\n    event Clean(bytes32 indexed sarcoId, address indexed cleaner);\n\n    /// @notice Clean has been called on a sarcophagus that has already been cleaned\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a private key on\n    error SarcophagusAlreadyCleaned(bytes32 sarcoId);\n\n    /// @notice Clean has been called before the deadline for archaeologists to publish private keys has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param publishDeadline Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\n    error TooEarlyForClean(uint256 currentTime, uint256 publishDeadline);\n\n    /// @notice Clean has been called by someone other than the admin or embalmer of the sarcophagus\n    /// @param senderAddress Address of sender\n    error SenderNotEmbalmerOrAdmin(address senderAddress);\n\n    /// @notice Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\n    error EmbalmerClaimWindowPassed(uint256 currentTime, uint256 embalmerClaimWindowEnd);\n\n    /// @notice Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\n    error TooEarlyForAdminClean(uint256 currentTime, uint256 embalmerClaimWindowEnd);\n\n    /// @notice Emitted when a third party attempts to accuse an archaeologist on a sarcophagus where the resurrection time has already passed\n    /// @param currentTime Timestamp of the failed accuse attempt\n    /// @param resurrectionTime Resurrection timestamp which has already passed\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\n\n    /// @notice Emitted when accuse is called with an unequal numbers of public keys and signatures\n    /// @param signatures the number of signatures passed into the accuse call\n    /// @param publicKeys the number of public keys passed into the accuse call\n    error DifferentNumberOfSignaturesAndPublicKeys(uint256 signatures, uint256 publicKeys);\n\n    /// @notice Emitted when accuse is called with an invalid signature for the supplied sarcoId, paymentAddress, and publicKey\n    /// @param sarcoId that should have been signed\n    /// @param paymentAddress payment address that should have been signed\n    /// @param publicKey publicKey that should be derived from signing key\n    /// @param signature invalid signature\n    error InvalidAccusalSignature(\n        bytes32 sarcoId,\n        address paymentAddress,\n        bytes publicKey,\n        LibTypes.Signature signature\n    );\n\n    /// @notice If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod,\n    /// their locked bonds and diggingFees may be claimed by either the embalmer or the admin\n    /// embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will\n    /// be able to claim remaining locked bond and diggingFees\n    /// @param sarcoId The identifier of the sarcophagus to clean\n    function clean(bytes32 sarcoId) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm the sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm tx sender is embalmer or admin\n        if (msg.sender != sarcophagus.embalmerAddress && msg.sender != LibDiamond.contractOwner()) {\n            revert SenderNotEmbalmerOrAdmin(msg.sender);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm the sarcophagus has not already been cleaned\n        if (sarcophagus.isCleaned) {\n            revert SarcophagusAlreadyCleaned(sarcoId);\n        }\n\n        // Confirm that the resurrectionTime + gracePeriod have passed\n        if (block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod) {\n            revert TooEarlyForClean(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\n        }\n\n        // if sender is embalmer, confirm current time is within embalmerClaimWindow\n        if (\n            msg.sender == sarcophagus.embalmerAddress &&\n            block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n        ) {\n            revert EmbalmerClaimWindowPassed(\n                block.timestamp,\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n            );\n        }\n\n        // if sender is admin, confirm embalmerClaimWindow has passed\n        if (\n            msg.sender == LibDiamond.contractOwner() &&\n            block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n        ) {\n            revert TooEarlyForAdminClean(\n                block.timestamp,\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n            );\n        }\n\n        // sum of locked bonds and digging fees for all archaeologists that have failed to publish private keys before publish deadline and have not been accused\n        uint256 totalDiggingFeesAndLockedBonds = 0;\n\n        for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\n                .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]];\n\n            // Punish archaeologists that failed to publish their private key in time\n            if (!cursedArchaeologist.isAccused && cursedArchaeologist.privateKey == 0) {\n                uint256 diggingFeesDue = cursedArchaeologist.diggingFeePerSecond *\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\n\n                uint256 cursedBondDue = (diggingFeesDue * sarcophagus.cursedBondPercentage) / 100;\n                totalDiggingFeesAndLockedBonds += diggingFeesDue + cursedBondDue;\n\n                // slash the archaeologist's locked bond for the sarcophagus\n                LibBonds.decreaseCursedBond(\n                    sarcophagus.cursedArchaeologistAddresses[i],\n                    cursedBondDue\n                );\n\n                // track that the archaeologist has had a clean on this sarcophagus\n                s.archaeologistCleanups[sarcophagus.cursedArchaeologistAddresses[i]].push(sarcoId);\n            }\n        }\n\n        // Transfer total slashed locked bonds plus digging fees to the embalmer if they are the caller, otherwise add\n        // this to the contract's protocol fees\n        if (msg.sender == sarcophagus.embalmerAddress) {\n            s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFeesAndLockedBonds);\n        } else {\n            s.totalProtocolFees += totalDiggingFeesAndLockedBonds;\n        }\n\n        sarcophagus.isCleaned = true;\n        emit Clean(sarcoId, msg.sender);\n    }\n\n    /**\n     * @notice Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id\n     * and payment address generated with the leaked private keys\n     * If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be\n     * split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer\n     *\n     * If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus\n     * state will be updated to Accused and bonds for all remaining unaccused archaeologists will be\n     * returned\n     *\n     * @param sarcoId The identifier of the sarcophagus having leaked private keys\n     * @param publicKeys an array of public keys corresponding to leaked private keys - order must match order of signatures\n     * @param signatures an array of signatures of the sarcoId and payment address signed by the leaked private keys - order must match order of publicKeys\n     * @param paymentAddress the address to which rewards should be sent if successful\n     */\n    function accuse(\n        bytes32 sarcoId,\n        bytes[] calldata publicKeys,\n        LibTypes.Signature[] calldata signatures,\n        address paymentAddress\n    ) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // verify that current time is not past resurrection time\n        if (block.timestamp > sarcophagus.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        if (signatures.length != publicKeys.length) {\n            revert DifferentNumberOfSignaturesAndPublicKeys(signatures.length, publicKeys.length);\n        }\n\n        address[] memory accusedArchAddresses = new address[](signatures.length);\n\n        // track the combined locked bond across all archaeologists being accused in this call\n        uint256 totalCursedBond = 0;\n        uint256 accusalCount = 0;\n        for (uint256 i = 0; i < signatures.length; i++) {\n            if (\n                !LibUtils.verifyAccusalSignature(\n                    sarcoId,\n                    paymentAddress,\n                    publicKeys[i],\n                    signatures[i]\n                )\n            ) {\n                revert InvalidAccusalSignature(\n                    sarcoId,\n                    paymentAddress,\n                    publicKeys[i],\n                    signatures[i]\n                );\n            }\n\n            // look up the archaeologist responsible for the publicKey\n            address accusedArchaeologistAddress = s.publicKeyToArchaeologistAddress[publicKeys[i]];\n            LibTypes.CursedArchaeologist storage accusedArchaeologist = sarcophagus\n                .cursedArchaeologists[accusedArchaeologistAddress];\n\n            // verify the accused archaeologist is cursed on the sarcophagus\n            if (accusedArchaeologist.publicKey.length == 0) {\n                revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\n            }\n\n            // if the archaeologist has already been accused on this sarcophagus break without taking action\n            if (accusedArchaeologist.isAccused) {\n                break;\n            }\n\n            // mark the archaeologist on the sarcophagus as having been accused\n            accusedArchaeologist.isAccused = true;\n            accusedArchAddresses[accusalCount++] = accusedArchaeologistAddress;\n\n            uint256 cursedBondDue = ((accusedArchaeologist.diggingFeePerSecond *\n                (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime)) *\n                sarcophagus.cursedBondPercentage) / 100;\n\n            totalCursedBond += cursedBondDue;\n\n            // Slash the offending archaeologists bond\n            LibBonds.decreaseCursedBond(accusedArchaeologistAddress, cursedBondDue);\n\n            // Save this accusal against the archaeologist\n            s.archaeologistAccusals[accusedArchaeologistAddress].push(sarcoId);\n        }\n\n        // if none of the accusals were valid because the archaeologists have all already been accused, return without taking action\n        if (accusalCount == 0) {\n            return;\n        }\n\n        // the sarcophagus is compromised if the current call has successfully accused the sss threshold of archaeologists\n        if (accusalCount >= sarcophagus.threshold) {\n            sarcophagus.isCompromised = true;\n        } else {\n            // if the current call hasn't resulted in at least sss threshold archaeologists being accused\n            // check if total number of historical accusals on sarcophagus is greater than threshold\n            uint256 totalAccusals = 0;\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\n                if (\n                    sarcophagus\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\n                        .isAccused\n                ) {\n                    totalAccusals++;\n                }\n            }\n            // the sarcophagus is compromised if k or more archaeologists have been accused over the lifetime of the sarcophagus\n            if (totalAccusals >= sarcophagus.threshold) {\n                sarcophagus.isCompromised = true;\n            }\n        }\n\n        // if k or more archaeologists have been accused over the lifetime of the sarcophagus, funds should\n        // be returned to the remaining well behaved archaeologists\n        if (sarcophagus.isCompromised) {\n            // iterate through all archaeologist addresses on the sarcophagus\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\n                // if the archaeologist has never been accused, release their locked bond back to them\n                if (\n                    !sarcophagus\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\n                        .isAccused\n                ) {\n                    LibBonds.freeArchaeologist(\n                        sarcoId,\n                        sarcophagus.cursedArchaeologistAddresses[i]\n                    );\n                }\n            }\n        }\n\n        uint256 halfTotalCursedBond = totalCursedBond / 2;\n        uint256 totalDiggingFees = totalCursedBond / (sarcophagus.cursedBondPercentage / 100);\n        // transfer the cursed half, plus the current digging fees, to the embalmer\n        s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFees + halfTotalCursedBond);\n\n        // transfer the other half of the cursed bond to the transaction caller\n        s.sarcoToken.transfer(paymentAddress, halfTotalCursedBond);\n\n        emit AccuseArchaeologist(\n            sarcoId,\n            msg.sender,\n            totalCursedBond,\n            totalDiggingFees,\n            accusedArchAddresses\n        );\n    }\n}\n"
    },
    "contracts/facets/ViewStateFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../libraries/LibTypes.sol\";\nimport \"../libraries/LibUtils.sol\";\nimport \"../storage/LibAppStorage.sol\";\n\ncontract ViewStateFacet {\n    /// @notice Gets the total protocol fees from the contract.\n    /// @return The total protocol fees\n    function getTotalProtocolFees() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.totalProtocolFees;\n    }\n\n    /// @notice Get the protocol fee base percentage from the contract.\n    /// @return The protocol fee base percentage - protocolFeeBasePercentage\n    function getProtocolFeeBasePercentage() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.protocolFeeBasePercentage;\n    }\n\n    /// @notice Get the cursed bond percentage from the contract.\n    /// @return The cursed bond percentage - cursedBondPercentage\n    function getCursedBondPercentage() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.cursedBondPercentage;\n    }\n\n    /// @notice Gets archaeologist profiles given a list of archaeologist addresses.\n    /// If an invalid address is included, simply leaves it out of the list.\n    /// @param addresses The list of archaeologist addresses\n    /// @return The list of archaeologist profiles\n    function getArchaeologistProfiles(\n        address[] memory addresses\n    ) external view returns (LibTypes.ArchaeologistProfile[] memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.ArchaeologistProfile[] memory profiles = new LibTypes.ArchaeologistProfile[](\n            addresses.length\n        );\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            // Skip unregistered archaeologists\n            if (s.archaeologistProfiles[addresses[i]].maximumRewrapInterval == 0) {\n                continue;\n            }\n            profiles[i] = s.archaeologistProfiles[addresses[i]];\n        }\n\n        return profiles;\n    }\n\n    /// @notice Gets the grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time passes\n    /// @return The resurrection grace period\n    function getGracePeriod() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.gracePeriod;\n    }\n\n    /// @notice Gets the window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\n    /// @return The embalmer claim window\n    function getEmbalmerClaimWindow() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.embalmerClaimWindow;\n    }\n\n    /// @notice Gets the expiration threshold after which a sarcophagus must be renegotiated\n    /// @return The expiration threshold\n    function getExpirationThreshold() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.expirationThreshold;\n    }\n\n    /// @notice Given an archaeologist address, return that archaeologist's\n    /// profile\n    /// @param archaeologist The archaeologist account's address\n    /// @return the Archaeologist object\n    function getArchaeologistProfile(\n        address archaeologist\n    ) external view returns (LibTypes.ArchaeologistProfile memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibUtils.revertIfArchProfileDoesNotExist(archaeologist);\n        return s.archaeologistProfiles[archaeologist];\n    }\n\n    /// @notice Return the list of registereed archaeologist addresses.\n    /// @return addresses of registered archaeologists\n    function getArchaeologistProfileAddresses() external view returns (address[] memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistProfileAddresses;\n    }\n\n    /// @notice Given an index (of the full archaeologist array), return the\n    /// archaeologist address at that index\n    /// @param index The index of the registered archaeologist\n    /// @return address of the archaeologist\n    function getArchaeologistProfileAddressAtIndex(uint256 index) external view returns (address) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistProfileAddresses[index];\n    }\n\n    /// @notice Returns the amount of free bond stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being returned\n    function getFreeBond(address archaeologist) external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistProfiles[archaeologist].freeBond;\n    }\n\n    /// @notice Returns the amount of rewards stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// reward is being returned\n    function getRewards(address archaeologist) external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistRewards[archaeologist];\n    }\n\n    /// @notice Returns the amount of cursed bond stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being returned\n    function getCursedBond(address archaeologist) external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistProfiles[archaeologist].cursedBond;\n    }\n\n    /// @notice Returns whether an archaeologist completed an unwrap for a sarcophagus\n    /// @param archaeologist The address of the archaeologist\n    /// @param sarcoId the sarcophagus to check if unwrapping occured\n    function getArchaeologistSuccessOnSarcophagus(\n        address archaeologist,\n        bytes32 sarcoId\n    ) external view returns (bool) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.sarcophagi[sarcoId].cursedArchaeologists[archaeologist].privateKey != 0;\n    }\n\n    /// @notice Returns the number of successful unwraps for an archaeologist.\n    /// @param archaeologist The address of the archaeologist whose success\n    //  count is being returned\n    function getArchaeologistSuccessesCount(address archaeologist) external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistSuccesses[archaeologist].length;\n    }\n\n    /// @notice Returns the sarcophagus unique identifier for a given\n    /// archaeologist and index of the successfully unwrapped sarcophagi\n    /// @param archaeologist The address of an archaeologist\n    /// @param index The index of the archaeologist's unwrapped sarcophagi\n    /// @return the identifier associated with the index of the archaeologist's\n    /// unwrapped sarcophagi\n    function archaeologistSuccessesIdentifier(\n        address archaeologist,\n        uint256 index\n    ) external view returns (bytes32) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistSuccesses[archaeologist][index];\n    }\n\n    /// @notice Returns the number of accusations for an archaeologist.\n    /// @param archaeologist The address of the archaeologist whose accusations\n    /// count is being returned\n    function getArchaeologistAccusalsCount(address archaeologist) external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistAccusals[archaeologist].length;\n    }\n\n    /// @notice Returns the sarcophagus unique identifier for a given\n    /// archaeologist and index of the accused sarcophagi\n    /// @param archaeologist The address of an archaeologist\n    /// @param index The index of the archaeologist's accused sarcophagi\n    /// @return the identifier associated with the index of the archaeologist's\n    /// accused sarcophagi\n    function archaeologistAccusalsIdentifier(\n        address archaeologist,\n        uint256 index\n    ) external view returns (bytes32) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistAccusals[archaeologist][index];\n    }\n\n    /// @notice Returns the number of cleanups for an archaeologist.\n    /// @param archaeologist The address of the archaeologist whose cleanups\n    /// count is being returned\n    function getArchaeologistCleanupsCount(address archaeologist) external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistCleanups[archaeologist].length;\n    }\n\n    /// @notice Returns the sarcophagus unique identifier for a given\n    /// archaeologist and index of the cleaned-up sarcophagi\n    /// @param archaeologist The address of an archaeologist\n    /// @param index The index of the archaeologist's cleaned-up sarcophagi\n    /// @return the identifier associated with the index of the archaeologist's\n    /// cleaned-up sarcophagi\n    function archaeologistCleanupsIdentifier(\n        address archaeologist,\n        uint256 index\n    ) external view returns (bytes32) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistCleanups[archaeologist][index];\n    }\n\n    // Only used in the ViewStateFacet to return statistics data.\n    // Contains a list of sarcoIds for each category. We could simply return the counts of the\n    // arrays but we are already storing the lists of sarcoIds so we may as well use them.\n    struct ArchaeologistStatistics {\n        uint256 successes;\n        uint256 accusals;\n        uint256 cleanups;\n        uint256 failures;\n    }\n\n    /// @notice Gets all reputation statistics for each archaeologist\n    /// Contains a list of counts for each category.\n    /// @param addresses The list of archaeologist addresses\n    /// @return The list of archaeologist statistics\n    function getArchaeologistsStatistics(\n        address[] memory addresses\n    ) external view returns (ArchaeologistStatistics[] memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        ArchaeologistStatistics[] memory statsList = new ArchaeologistStatistics[](\n            addresses.length\n        );\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            // Count the failures for the arch\n            uint256 failures = 0;\n\n            // Get arch sarco ids\n            bytes32[] storage sarcoIds = s.archaeologistSarcophagi[addresses[i]];\n\n            // For each sarco id, if the sarco id is not included in successes and resurrection time\n            // has passed, it's a failure\n            for (uint j = 0; j < sarcoIds.length; j++) {\n                LibTypes.Sarcophagus storage sarco = s.sarcophagi[sarcoIds[j]];\n                if (\n                    !this.getArchaeologistSuccessOnSarcophagus(addresses[i], sarcoIds[j]) &&\n                    sarco.resurrectionTime != 2 ** 256 - 1 &&\n                    block.timestamp > sarco.resurrectionTime + s.gracePeriod\n                ) {\n                    failures += 1;\n                }\n            }\n\n            statsList[i] = ArchaeologistStatistics(\n                this.getArchaeologistSuccessesCount(addresses[i]),\n                this.getArchaeologistAccusalsCount(addresses[i]),\n                this.getArchaeologistCleanupsCount(addresses[i]),\n                failures\n            );\n        }\n\n        return statsList;\n    }\n\n    struct SarcophagusResponse {\n        uint256 resurrectionTime;\n        uint256 previousRewrapTime;\n        bool isCompromised;\n        bool isCleaned;\n        string name;\n        uint8 threshold;\n        uint256 maximumRewrapInterval;\n        uint256 maximumResurrectionTime;\n        uint256 cursedBondPercentage;\n        string arweaveTxId;\n        address embalmerAddress;\n        address recipientAddress;\n        address[] archaeologistAddresses;\n        uint8 publishedPrivateKeyCount;\n        bool hasLockedBond;\n    }\n\n    /// @notice Returns data on the sarcophagus with the supplied id\n    /// includes aggregate data on cursed archaeologists associated with the sarcophagus\n    ///     - publishedPrivateKeyCount - the total number of private keys published by archaeologists on the sarcophagus\n    ///     - hasLockedBond - true if archaeologists still have bond locked in the contract for this sarcophagus\n    /// @param sarcoId The identifier of the sarcophagus being returned\n    function getSarcophagus(bytes32 sarcoId) external view returns (SarcophagusResponse memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        uint8 publishedPrivateKeyCount = 0;\n        bool hasLockedBond = false;\n        for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\n            // archaeologist has published a private key\n            if (\n                sarcophagus\n                    .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\n                    .privateKey != 0\n            ) {\n                publishedPrivateKeyCount++;\n            } else if (\n                !sarcophagus\n                    .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\n                    .isAccused &&\n                !sarcophagus.isCompromised &&\n                !sarcophagus.isCleaned &&\n                sarcophagus.resurrectionTime != 2 ** 256 - 1\n            ) {\n                // if the sarcophagus is not compromised, buried, or cleaned and\n                // one or more unaccused archaeologists hasn't published a private key there is locked bond on the sarcophagus\n                hasLockedBond = true;\n            }\n        }\n\n        return\n            SarcophagusResponse({\n                resurrectionTime: sarcophagus.resurrectionTime,\n                previousRewrapTime: sarcophagus.previousRewrapTime,\n                isCompromised: sarcophagus.isCompromised,\n                isCleaned: sarcophagus.isCleaned,\n                name: sarcophagus.name,\n                threshold: sarcophagus.threshold,\n                maximumRewrapInterval: sarcophagus.maximumRewrapInterval,\n                maximumResurrectionTime: sarcophagus.maximumResurrectionTime,\n                cursedBondPercentage: sarcophagus.cursedBondPercentage,\n                arweaveTxId: sarcophagus.arweaveTxId,\n                embalmerAddress: sarcophagus.embalmerAddress,\n                recipientAddress: sarcophagus.recipientAddress,\n                archaeologistAddresses: sarcophagus.cursedArchaeologistAddresses,\n                publishedPrivateKeyCount: publishedPrivateKeyCount,\n                hasLockedBond: hasLockedBond\n            });\n    }\n\n    /// @notice Given an embalmer's address, returns the identifiers of all\n    /// sarcophagi that the embalmer has created.\n    /// @param embalmer The address of the embalmer whose sarcophagi are being\n    /// returned\n    function getEmbalmerSarcophagi(address embalmer) external view returns (bytes32[] memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.embalmerSarcophagi[embalmer];\n    }\n\n    /// @notice Given an archaeologist's address, returns the identifiers of all\n    /// sarcophagi that the archaeologist has participated in.\n    /// @param archaeologist The address of the archaeologist whose sarcophagi\n    /// are being returned\n    function getArchaeologistSarcophagi(\n        address archaeologist\n    ) external view returns (bytes32[] memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistSarcophagi[archaeologist];\n    }\n\n    /// @notice Given a recipient's address, returns the identifiers of all\n    /// sarcophagi that the recipient has participated in.\n    /// @param recipient The address of the recipient whose sarcophagi are being\n    /// returned\n    function getRecipientSarcophagi(address recipient) external view returns (bytes32[] memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.recipientSarcophagi[recipient];\n    }\n\n    /// @notice Returns the data stored on a sarcophagus for an archaeologist.\n    /// @param sarcoId The identifier of the sarcophagus whose data is being\n    /// returned\n    /// @param archaeologist The address of the archaeologist whose data is\n    /// being returned\n    function getSarcophagusArchaeologist(\n        bytes32 sarcoId,\n        address archaeologist\n    ) external view returns (LibTypes.CursedArchaeologist memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.sarcophagi[sarcoId].cursedArchaeologists[archaeologist];\n    }\n}\n"
    },
    "contracts/libraries/LibBonds.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"./LibErrors.sol\";\n\nimport \"../facets/EmbalmerFacet.sol\";\n\nlibrary LibBonds {\n    /// @notice Decreases the amount stored in the freeBond mapping for an\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\n    /// the amount.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being decreased\n    /// @param amount The amount to decrease the free bond by\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Revert if the amount is greater than the current free bond\n        if (amount > s.archaeologistProfiles[archaeologist].freeBond) {\n            revert LibErrors.NotEnoughFreeBond(\n                s.archaeologistProfiles[archaeologist].freeBond,\n                amount\n            );\n        }\n\n        // Decrease the free bond amount\n        s.archaeologistProfiles[archaeologist].freeBond -= amount;\n    }\n\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\n    /// archaeologist, without respectively increasing their free bond.\n    /// @param archaeologist The address of the archaeologist\n    /// @param amount The amount to slash\n    function decreaseCursedBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Revert if the amount is greater than the current cursed bond\n        if (amount > s.archaeologistProfiles[archaeologist].cursedBond) {\n            revert LibErrors.NotEnoughCursedBond(\n                s.archaeologistProfiles[archaeologist].cursedBond,\n                amount\n            );\n        }\n\n        s.archaeologistProfiles[archaeologist].cursedBond -= amount;\n    }\n\n    /// @notice Bonds the archaeologist to a sarcophagus.\n    /// This does the following:\n    ///   - adds the archaeologist's curse params and address to the sarcophagus\n    ///   - calculates digging fees to be locked and later paid to archaeologist\n    ///   - locks this amount from archaeologist's free bond; increases cursedBond by same\n    ///   - Adds the sarcophagus' id to the archaeologist's record of bonded sarcophagi\n    /// @param sarcoId Id of the sarcophagus with which to curse the archaeologist\n    /// @param archaeologist The archaologist to curse, with associated parameters of the curse\n    ///\n    /// @return the amount of digging fees due the embalmer for this curse\n    function curseArchaeologist(\n        bytes32 sarcoId,\n        EmbalmerFacet.CurseParams calldata archaeologist,\n        uint256 index\n    ) internal returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        sarcophagus.cursedArchaeologists[archaeologist.archAddress] = LibTypes.CursedArchaeologist({\n            publicKey: archaeologist.publicKey,\n            privateKey: 0,\n            isAccused: false,\n            diggingFeePerSecond: archaeologist.diggingFeePerSecond\n        });\n        sarcophagus.cursedArchaeologistAddresses[index] = archaeologist.archAddress;\n\n        // Calculate digging fees due for this time period (creationTime/previousRewrapTime -> resurrectionTime)\n        uint256 diggingFeesDue = archaeologist.diggingFeePerSecond *\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\n\n        // Use cursed bond percentage to determine how much bond to lock up\n        uint256 bondToCurse = (diggingFeesDue * s.cursedBondPercentage) / 100;\n\n        decreaseFreeBond(archaeologist.archAddress, bondToCurse);\n        s.archaeologistProfiles[archaeologist.archAddress].cursedBond += bondToCurse;\n\n        s.archaeologistSarcophagi[archaeologist.archAddress].push(sarcoId);\n\n        return diggingFeesDue;\n    }\n\n    /// @notice Calculates and unlocks an archaeologist's cursed bond. Pays due digging fees to the archaeologist.\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\n    /// @param archaeologistAddress the address of the archaeologist to free\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\n            .sarcophagi[sarcoId]\n            .cursedArchaeologists[archaeologistAddress];\n\n        uint256 diggingFeeAmount = cursedArchaeologist.diggingFeePerSecond *\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\n\n        uint256 cursedBondAmount = diggingFeeAmount * sarcophagus.cursedBondPercentage / 100;\n\n        decreaseCursedBond(archaeologistAddress, cursedBondAmount);\n        s.archaeologistProfiles[archaeologistAddress].freeBond += cursedBondAmount;\n        s.archaeologistRewards[archaeologistAddress] += diggingFeeAmount;\n    }\n}\n"
    },
    "contracts/libraries/LibErrors.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\n/**\n * @title A collection of Errors\n * @notice This library defines all of the Errors that the Sarcophagus system\n * uses.\n */\nlibrary LibErrors {\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\n\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\n\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\n\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\n\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\n\n    error SarcophagusInactive(bytes32 sarcoId);\n\n    error SarcophagusCompromised(bytes32 sarcoId);\n\n    error SenderNotEmbalmer(address sender, address embalmer);\n\n    error InvalidSignature(\n        // address recovered from signature via ecrecover\n        address recoveredAddress,\n        // address we expected to have signed the data\n        address expectedAddress\n    );\n}\n"
    },
    "contracts/libraries/LibPrivateKeys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n\n/**\n * @title Private key verification\n * @notice Implements a private key -> public key checking function\n * @dev modified from https://github.com/1Address/ecsol, removes extra code\n * which isn't necessary for our Sarcophagus implementation\n */\nlibrary LibPrivateKeys {\n    /**\n     * @notice Given a private key and a public key, determines if that public\n     * key was derived from the private key\n     * @dev based on https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\n     * @param privKey an secp256k1 private key\n     * @param pubKey an uncompressed 65 byte secp256k1 public key\n     * @return bool indicating whether the public key is derived from the\n     * private key\n     */\n    function isPublicKeyOfPrivateKey(bytes32 privKey, bytes storage pubKey) internal view returns (bool) {\n        // removes the 0x04 prefix from an uncompressed public key\n        bytes memory truncatedPublicKey = new bytes(pubKey.length-1);\n        for (uint256 i = 1; i < pubKey.length; i++) {\n            truncatedPublicKey[i-1] = pubKey[i];\n        }\n\n        // generator point coordinates and order of secp256k1\n        uint256 gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n        uint256 gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n        uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n\n        address signer = ecrecover(\n            0,\n            gy % 2 != 0 ? 28 : 27,\n            bytes32(gx),\n            bytes32(mulmod(uint256(privKey), gx, m))\n        );\n\n        address xyAddress = address(\n            uint160(uint256(keccak256(truncatedPublicKey)) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        );\n        return xyAddress == signer;\n    }\n}\n"
    },
    "contracts/libraries/LibTypes.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\n/**\n * @title Types shared across facets for the Sarcophagus diamond\n */\nlibrary LibTypes {\n    struct Sarcophagus {\n        // Also used for existence checks -- does not exist if 0\n        uint256 resurrectionTime;\n        uint256 previousRewrapTime;\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\n        bool isCompromised;\n        bool isCleaned;\n        uint8 threshold;\n        string name;\n        uint256 maximumRewrapInterval;\n        uint256 maximumResurrectionTime;\n        string arweaveTxId;\n        address embalmerAddress;\n        address recipientAddress;\n        address[] cursedArchaeologistAddresses;\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\n        uint256 cursedBondPercentage;\n    }\n\n    struct CursedArchaeologist {\n        uint256 diggingFeePerSecond;\n        // Also used for publish checks -- has not published if 0\n        bytes32 privateKey;\n        // Also used for curse checks -- is not bonded if length is 0\n        bytes publicKey;\n        bool isAccused;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct ArchaeologistProfile {\n        // Also used for existence checks -- does not exist if 0\n        uint256 maximumRewrapInterval;\n        uint256 maximumResurrectionTime;\n        string peerId;\n        uint256 minimumDiggingFeePerSecond;\n        uint256 freeBond;\n        uint256 cursedBond;\n    }\n}\n"
    },
    "contracts/libraries/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport \"../facets/ThirdPartyFacet.sol\";\nimport \"./LibTypes.sol\";\nimport \"../facets/EmbalmerFacet.sol\";\n\n/**\n * @title Utility functions used within the Sarcophagus system\n * @notice This library implements various functions that are used throughout\n * Sarcophagus, mainly to DRY up the codebase\n * @dev these functions are all stateless, public, pure/view\n */\nlibrary LibUtils {\n    /**\n     * @notice The archaeologist needs to sign off on two pieces of data\n     * to guarantee their unrwap will be successful\n     *\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\n     * @param curseParams parameters of curse signed by archaeologist\n     */\n    function verifyArchaeologistSignature(\n        uint256 agreedMaximumRewrapInterval,\n        uint256 maximumResurrectionTime,\n        uint256 timestamp,\n        EmbalmerFacet.CurseParams calldata curseParams\n    ) internal pure {\n        // Hash the hash of the data payload\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(\n                    abi.encode(\n                        curseParams.publicKey,\n                        agreedMaximumRewrapInterval,\n                        maximumResurrectionTime,\n                        curseParams.diggingFeePerSecond,\n                        timestamp\n                    )\n                )\n            )\n        );\n\n        // Generate the address from the signature.\n        // ecrecover should always return a valid address.\n        address recoveredAddress = ecrecover(\n            messageHash,\n            curseParams.v,\n            curseParams.r,\n            curseParams.s\n        );\n\n        if (recoveredAddress != curseParams.archAddress) {\n            revert LibErrors.InvalidSignature(recoveredAddress, curseParams.archAddress);\n        }\n    }\n\n    /// @notice Verifies that a signature and public key were created from the same private key\n    /// @param sarcoId the sarcoId that was signed\n    /// @param paymentAddress the payment address that was signed\n    /// @param publicKey an uncompressed 65 byte secp256k1 public key\n    /// @param signature signature on the sarco id and payment address\n    /// @return true if the signature was signed by the private key corresponding to the supplied public key\n    function verifyAccusalSignature(\n        bytes32 sarcoId,\n        address paymentAddress,\n        bytes calldata publicKey,\n        LibTypes.Signature calldata signature\n    ) internal pure returns (bool) {\n        // removes the 0x04 prefix from an uncompressed public key\n        bytes memory truncatedPublicKey = new bytes(publicKey.length - 1);\n        for (uint256 i = 1; i < publicKey.length; i++) {\n            truncatedPublicKey[i - 1] = publicKey[i];\n        }\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encode(sarcoId, paymentAddress))\n            )\n        );\n        // Use ecrecover to get the address that signed the message\n        address signingAddress = ecrecover(messageHash, signature.v, signature.r, signature.s);\n\n        address publicKeyAddress = address(\n            uint160(\n                uint256(keccak256(truncatedPublicKey)) &\n                    0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            )\n        );\n\n        return signingAddress == publicKeyAddress;\n    }\n\n    /// @notice Checks if an archaeologist profile exists and\n    /// reverts if so\n    ///\n    /// @param archaeologist the archaeologist address to check existence of\n    function revertIfArchProfileExists(address archaeologist) internal view {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval != 0) {\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\n        }\n    }\n\n    /// @notice Checks if an archaeologist profile doesn't exist and reverts if so\n    ///\n    /// @param archaeologist the archaeologist address to check lack of existence of\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval == 0) {\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\n        }\n    }\n\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\n    /// @param totalDiggingFees to be paid. Protocol fee is a percentage of this\n    /// @return The protocol fees amount\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 100;\n    }\n}\n"
    },
    "contracts/proxy/LibUtilsProxy.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {LibTypes} from \"../libraries/LibTypes.sol\";\n\ncontract LibUtilsTest {\n    function verifySignature(\n        bytes32 sarcoId,\n        address paymentAddress,\n        bytes calldata publicKey,\n        LibTypes.Signature calldata signature\n    ) external pure returns (bool) {\n        return LibUtils.verifyAccusalSignature(sarcoId, paymentAddress, publicKey, signature);\n    }\n}\n"
    },
    "contracts/storage/AppStorageInit.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./LibAppStorage.sol\";\n\ncontract AppStorageInit {\n    /// @notice Initializes the app with default state values\n    /// @dev Add any AppStorage struct properties here to initialize values\n    function init(\n        IERC20 sarcoToken,\n        uint256 protocolFeeBasePercentage,\n        uint256 gracePeriod,\n        uint256 embalmerClaimWindow,\n        uint256 expirationThreshold\n    ) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        s.sarcoToken = sarcoToken;\n        s.protocolFeeBasePercentage = protocolFeeBasePercentage;\n        // Init digging fees / cursed bond ratio to 1\n        s.cursedBondPercentage = 100;\n        s.gracePeriod = gracePeriod;\n        s.embalmerClaimWindow = embalmerClaimWindow;\n        s.expirationThreshold = expirationThreshold;\n    }\n}\n"
    },
    "contracts/storage/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\n\n/**\n * Global diamond storage struct to be shared across facets\n * TODO: Implement diamond storage pattern and consider splitting storage into facet specific structs\n */\nstruct AppStorage {\n    // SARCO token contract\n    IERC20 sarcoToken;\n    // total protocol fees available to be withdrawn by the admin\n    uint256 totalProtocolFees;\n    /**\n     * Protocol level admin configurations\n     */\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap\n    uint256 protocolFeeBasePercentage;\n    // % of digging fees archaeologists must have locked up per curse in cursed bond\n    uint256 cursedBondPercentage;\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time\n    uint256 gracePeriod;\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated\n    uint256 expirationThreshold;\n    // window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\n    uint256 embalmerClaimWindow;\n\n    // registered archaeologist addresses\n    address[] archaeologistProfileAddresses;\n\n    /**\n     * Ownership mappings\n     */\n    // embalmer address => ids of sarcophagi they've created\n    mapping(address => bytes32[]) embalmerSarcophagi;\n    // archaeologist address =>  ids of sarcophagi they're protecting\n    mapping(address => bytes32[]) archaeologistSarcophagi;\n    // recipient address =>  ids of sarcophagi they're recipient on\n    mapping(address => bytes32[]) recipientSarcophagi;\n    // public key => archaeologist address\n    mapping(bytes => address) publicKeyToArchaeologistAddress;\n    // sarcophagus id => sarcophagus object\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\n    // archaeologist address => profile\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\n    // current balance of rewards available for the archaeologist to withdraw\n    mapping(address => uint256) archaeologistRewards;\n    /**\n     * Archaeologist reputation statistics: address => sarcoIds\n     * todo: could these be organized differently?\n     */\n    mapping(address => bytes32[]) archaeologistSuccesses;\n    mapping(address => bytes32[]) archaeologistAccusals;\n    mapping(address => bytes32[]) archaeologistCleanups;\n}\n\nlibrary LibAppStorage {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"sarcophagus.storage.SarcophagusGoerliTest\");\n\n    function getAppStorage() internal pure returns (AppStorage storage s) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}