{
  "language": "Solidity",
  "sources": {
    "contracts/facets/AdminFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\nimport { LibDiamond } from \"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\";\n\ncontract AdminFacet {\n    AppStorage internal s;\n\n    /// @notice Withdraws the total protocol fee amount from the contract.\n    /// @dev Can only be called by the owner.\n    function withdrawProtocolFees() external {\n        LibDiamond.enforceIsContractOwner();\n        // Get the total protocol fees from storage\n        uint256 totalProtocolFees = s.totalProtocolFees;\n\n        // Set the total protocol fees to 0 before the transfer to avoid reentrancy\n        s.totalProtocolFees = 0;\n\n        // Transfer the protocol fee amount to the sender after setting state\n        s.sarcoToken.transfer(msg.sender, totalProtocolFees);\n    }\n\n    /// @notice Sets the protocol fee base percentage, used to calculate protocol fees\n    /// @param protocolFeeBasePercentage percentage to set\n    /// @dev Can only be called by the owner.\n    function setProtocolFeeBasePercentage(uint256 protocolFeeBasePercentage) external {\n        LibDiamond.enforceIsContractOwner();\n        s.protocolFeeBasePercentage = protocolFeeBasePercentage;\n    }\n\n    /// @notice Updates the resurrection grace period\n    /// @param gracePeriod to set\n    /// @dev Can only be called by the diamond owner.\n    function setGracePeriod(uint256 gracePeriod) external {\n        LibDiamond.enforceIsContractOwner();\n        s.gracePeriod = gracePeriod;\n    }\n\n    /// @notice Updates the expirationThreshold used during sarcophagus creation\n    /// @param expirationThreshold to set\n    /// @dev Can only be called by the diamond owner.\n    function setExpirationThreshold(uint256 expirationThreshold) external {\n        LibDiamond.enforceIsContractOwner();\n        s.expirationThreshold = expirationThreshold;\n    }\n}\n"
    },
    "contracts/storage/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\n\n// Global storage for the app. Can be accessed in facets and in libraries\nstruct AppStorage {\n    IERC20 sarcoToken;\n    // The percentage (i.e. 1 = 1%) of a sarcophagus' total digging fees that will be collected on\n    // createSarcophagus and rewrapSarcophagus, paid by the embalmer\n    uint256 protocolFeeBasePercentage;\n    // The amount of protocol fees currently stored on the contract\n    uint256 totalProtocolFees;\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time\n    uint256 gracePeriod;\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated\n    uint256 expirationThreshold;\n    // sarcophagi\n    bytes32[] sarcophagusIdentifiers;\n    // archaeologist profiles\n    address[] archaeologistProfileAddresses;\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\n\n    // archaeologistSarcoSuccesses is needed by the clean function\n    // to lookup whether an archaeologist has completed an unwrapping\n    mapping(address => mapping(bytes32 => bool)) archaeologistSarcoSuccesses;\n\n    // Archaeologist reputation statistics\n    mapping(address => bytes32[]) archaeologistSuccesses;\n    mapping(address => bytes32[]) archaeologistAccusals;\n    mapping(address => bytes32[]) archaeologistCleanups;\n\n    // Track how much archaeologists have made. To be credited and debited\n    // as archaeologists fulfill their duties and withdraw their rewards\n    mapping(address => uint256) archaeologistRewards;\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\n    // sarcophagus ownerships\n    mapping(address => bytes32[]) embalmerSarcophagi;\n    mapping(address => bytes32[]) archaeologistSarcophagi;\n    mapping(address => bytes32[]) recipientSarcophagi;\n    // Mapping of unencrypted shard double hashes to archaeologists who are\n    // responsible for them. Needed to optimise Accuse algo - unencrypted shard is\n    // double hashed and used as a constant O(1) lookup here\n    mapping(bytes32 => address) doubleHashedShardArchaeologists;\n    // A mapping used to store an archaeologist's data on a sarcophagus.\n    // Digging fees, storage fees, and the hashed shards of the\n    // archaeologists all need to be stored per sarcophagus. This mapping of a\n    // mapping stores the archaeologist's data we need per sarcophagus.\n    // Example usage (to retrieve the digging fees an archaeologist may claim on some sarcophagus):\n    //   LibTypes.ArchaeologistStorage bondedArchaeologist = sarcophagusArchaeologists[sarcoId][archAddress];\n    //   uint256 diggingFees = bondedArchaeologist.diggingFees;\n    mapping(bytes32 => mapping(address => LibTypes.ArchaeologistStorage)) sarcophagusArchaeologists;\n}\n\nlibrary LibAppStorage {\n    function getAppStorage() internal pure returns (AppStorage storage s) {\n        // Set the position of our struct in contract storage\n        // Since AppStorage s is the first and only state variable declared in\n        // facets its position in contract storage is 0\n        assembly {\n            s.slot := 0\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/libraries/LibTypes.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\n/**\n * @title A collection of defined structs\n * @notice This library defines the various data models that the Sarcophagus\n * system uses\n */\nlibrary LibTypes {\n    // DoesNotExist must come first on the list to be the default value\n    enum SarcophagusState {\n        DoesNotExist,\n        Active,\n        Resurrecting,\n        Resurrected,\n        Buried,\n        Cleaned,\n        Accused,\n        Failed\n    }\n\n    // A struct of just the signature. This is used primarily by the\n    // finalizeSarcophagus function for the arweave archaeologist. Note that,\n    // unlike the regular archaeologists, the sarcophagus already stores the\n    // single arweave archaeologist's address so there is no need to pass in the\n    // address to the finalizeSarcophagus function.\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    // Signature struct created to make passing in the signature argmuments into\n    // finalizedSarcophagus easier and to avoid the \"stack too deep\" error.\n    // Also attaching arachaeologist addresses so we can tie the signature back\n    // to the address in finalizeSarcophagus.\n    struct SignatureWithAccount {\n        address account;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    // SelectedArchaeologistData is the struct that is passed into the\n    // initializeSarcophagus function. Even though we don't need each storage\n    // fee of the archaeologist, the storage fee is included in the struct to\n    // reduce the stack size within the function, preventing the \"stack too\n    // deep\" error.\n    struct SelectedArchaeologistData {\n        address archAddress;\n        uint256 diggingFee;\n        bytes32 unencryptedShardDoubleHash;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    // ArchaeologistStorage is the struct that is stored in AppStorage under the\n    // sarcophagusArchaeologists mapping.\n    //\n    // The archaeologist address is left out since each archaeologist's address\n    // is stored on the sarcophagus object as an array.\n    //\n    // The storage fee is left out because we only need to store the storage fee\n    // of the archaeologist uploading to arweave, which will be stored directly\n    // on the sarcophagus.\n    struct ArchaeologistStorage {\n        uint256 diggingFee;\n        uint256 diggingFeesPaid;\n        bytes32 unencryptedShardDoubleHash;\n        bytes unencryptedShard;\n    }\n\n    // ArchaeologistProfile is used to store archaeologist profile data\n    struct ArchaeologistProfile {\n        bool exists;\n        string peerId;\n        uint256 minimumDiggingFee;\n        uint256 maximumRewrapInterval;\n        uint256 freeBond;\n        uint256 cursedBond;\n    }\n\n    struct SarcophagusMemory {\n        string name;\n        address recipient;\n        uint256 resurrectionTime;\n        uint256 maximumRewrapInterval;\n        bool canBeTransferred;\n        uint8 minShards;\n        uint256 timestamp;\n    }\n\n    // The ArchaeologistStorage struct could be contained in this Sarcophagus\n    // struct as a mapping, but it was put into it's own mapping\n    // (sarcophagusArchaeologists) directly in AppStorage. Instead the\n    // sarcophagus stores the addresses of each archaeologist added to it. This\n    // was done to simplify the creation of a sarcophagus object in\n    // initializeSarcophagus.\n    struct Sarcophagus {\n        string name;\n        SarcophagusState state;\n        bool canBeTransferred;\n        uint8 minShards;\n        uint256 resurrectionTime;\n        uint256 maximumRewrapInterval;\n        string[] arweaveTxIds;\n        address embalmer;\n        address recipientAddress;\n        address[] archaeologists;\n    }\n\n    struct MetadataAttributes {\n        string sarcophagusName;\n        uint256 diggingFee;\n        uint256 resurrectionTime;\n        uint256 diggingFeesPaid;\n    }\n\n    // Only used in the ViewStateFacet to return statistics data.\n    // Contains a list of sarcoIds for each category. We could simply return the counts of the\n    // arrays but we are already storing the lists of sarcoIds so we may as well use them.\n    struct ArchaeologistStatistics {\n        uint256 successes;\n        uint256 accusals;\n        uint256 cleanups;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/storage/AppStorageInit.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./LibAppStorage.sol\";\n\ncontract AppStorageInit {\n    /// @notice Initializes the app with default state values\n    /// @dev Add any AppStorage struct properties here to initialize values\n    function init(\n        IERC20 sarcoToken,\n        uint256 protocolFeeBasePercentage,\n        uint256 gracePeriod,\n        uint256 expirationThreshold\n    ) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Add the ERC20 token to app storage (Sarco)\n        s.sarcoToken = sarcoToken;\n        s.protocolFeeBasePercentage = protocolFeeBasePercentage;\n        s.gracePeriod = gracePeriod;\n        s.expirationThreshold = expirationThreshold;\n    }\n}\n"
    },
    "contracts/facets/ThirdPartyFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract ThirdPartyFacet {\n    AppStorage internal s;\n\n    event AccuseArchaeologist(\n        bytes32 indexed sarcoId,\n        address indexed accuser,\n        uint256 accuserBondReward,\n        uint256 embalmerBondReward\n    );\n\n    event CleanUpSarcophagus(\n        bytes32 indexed sarcoId,\n        address indexed cleaner,\n        uint256 cleanerBondReward,\n        uint256 embalmerBondReward\n    );\n\n    /// @notice Close a sarcophagus that has not been unwrapped within its grace period\n    /// @param sarcoId The identifier of the sarcophagus to clean\n    /// @param paymentAddress The address to which rewards will be sent\n    function clean(bytes32 sarcoId, address paymentAddress) external {\n        LibUtils.revertIfNotExistOrInactive(sarcoId);\n\n        LibTypes.Sarcophagus storage sarco = s.sarcophagi[sarcoId];\n\n        // Make sure the sarco is cleanable\n        if (block.timestamp < s.gracePeriod + sarco.resurrectionTime) {\n            revert LibErrors.SarcophagusNotCleanable();\n        }\n\n        // Figure out which archaeoligists did not fulfil their duties;\n        // accumulate their digging fees\n        address[] memory archAddresses = sarco.archaeologists;\n\n        uint256 totalCursedBond;\n        uint256 totalDiggingFee;\n\n        for (uint256 i = 0; i < archAddresses.length; i++) {\n            bool didNotUnwrap = s.archaeologistSarcoSuccesses[archAddresses[i]][\n                sarcoId\n            ] == false;\n\n            if (didNotUnwrap) {\n                LibTypes.ArchaeologistStorage memory defaulter = s\n                    .sarcophagusArchaeologists[sarcoId][archAddresses[i]];\n\n                totalDiggingFee += defaulter.diggingFee;\n\n                uint256 cursedBond = LibBonds.calculateCursedBond(\n                    defaulter.diggingFee\n                );\n\n                totalCursedBond += cursedBond;\n\n                // decrease the defaulter's cursed bond\n                LibBonds.decreaseCursedBond(archAddresses[i], cursedBond);\n\n                // Save the failure to unwrap against the archaeologist\n                s.archaeologistCleanups[archAddresses[i]].push(sarcoId);\n            }\n        }\n\n        (\n            uint256 cleanerBondReward,\n            uint256 embalmerBondReward\n        ) = _distributeLoot(\n                paymentAddress,\n                sarco,\n                totalCursedBond,\n                totalDiggingFee\n            );\n\n        sarco.state = LibTypes.SarcophagusState.Cleaned;\n\n        emit CleanUpSarcophagus(\n            sarcoId,\n            msg.sender,\n            cleanerBondReward,\n            embalmerBondReward\n        );\n    }\n\n    /**\n     * @notice Accuse archaeologoists of bad behaviour, by providing proof of leaked\n     * unencrypted shards before a sarcophagus is ready to be unwrapped. The minumum\n     * number of shards required to unwrap the sarcophagus should be provided for a\n     * a successful accusal.\n     * of the cursed bonds of the archs back to them, and un-curses their bonds.\n     * @param sarcoId The identifier of the sarcophagus having leaked shards\n     * @param unencryptedShardHashes At least 'm' unencrypted shard hashes as proof of bad behaviour\n     * @param paymentAddress the address to which rewards should be sent if successful\n     */\n    function accuse(\n        bytes32 sarcoId,\n        bytes32[] memory unencryptedShardHashes,\n        address paymentAddress\n    ) external {\n        LibUtils.revertIfNotExistOrInactive(sarcoId);\n\n        LibTypes.Sarcophagus storage sarco = s.sarcophagi[sarcoId];\n\n        if (sarco.resurrectionTime < block.timestamp) {\n            revert LibErrors.SarcophagusIsUnwrappable();\n        }\n\n        if (unencryptedShardHashes.length < sarco.minShards) {\n            revert LibErrors.AccuseNotEnoughProof(\n                unencryptedShardHashes.length,\n                sarco.minShards\n            );\n        }\n\n        address[] memory accusedArchAddresses = new address[](\n            unencryptedShardHashes.length\n        );\n\n        // For each provided shard hash, check if its hash matches one on storage. If so, flag that\n        // archaeologist as accusable\n        uint256 diggingFeesToBeDistributed = 0;\n        uint256 totalCursedBond = 0;\n        uint256 pos = 0;\n        for (uint256 i = 0; i < unencryptedShardHashes.length; i++) {\n            bytes32 shardDoubleHash = keccak256(\n                abi.encode(unencryptedShardHashes[i])\n            );\n\n            address matchingArchAddr = s.doubleHashedShardArchaeologists[\n                shardDoubleHash\n            ];\n\n            LibTypes.ArchaeologistStorage storage badArch = s\n                .sarcophagusArchaeologists[sarcoId][matchingArchAddr];\n\n            if (badArch.unencryptedShardDoubleHash == shardDoubleHash) {\n                accusedArchAddresses[pos++] = matchingArchAddr;\n\n                uint256 cursedBond = LibBonds.calculateCursedBond(\n                    badArch.diggingFee\n                );\n\n                diggingFeesToBeDistributed += badArch.diggingFee;\n                totalCursedBond += cursedBond;\n\n                LibBonds.decreaseCursedBond(matchingArchAddr, cursedBond);\n\n                // Save the accusal against the archaeologist\n                s.archaeologistAccusals[matchingArchAddr].push(sarcoId);\n            } else {\n                revert LibErrors.AccuseIncorrectProof();\n            }\n        }\n\n        // At this point, we need to filter out unaccused archs in order to reimburse them.\n        address[] memory bondedArchaeologists = s\n            .sarcophagi[sarcoId]\n            .archaeologists;\n\n        for (uint256 i = 0; i < bondedArchaeologists.length; i++) {\n            // Need to check each archaeologist address on the sarcophagus\n            bool isUnaccused = true;\n\n            for (uint256 j = 0; j < accusedArchAddresses.length; j++) {\n                // For each arch address, if found in accusedArchAddresses,\n                // then don't add to unaccusedArchsAddresses\n                if (bondedArchaeologists[i] == accusedArchAddresses[j]) {\n                    isUnaccused = false;\n                    break;\n                }\n            }\n\n            // If this arch address wasn't in the accused list, free it from its curse\n            if (isUnaccused) {\n                // There are technically no rewards here, since the sarcophagus\n                // has been compromised, so here this effectively merely resets\n                // the state of the non-malicious archaeologists, as if they never\n                // bonded to this sarcophagus in the first place.\n                //\n                // Of course, whatever rewards they might have gained in previous\n                // rewraps remains theirs.\n                LibBonds.freeArchaeologist(sarcoId, bondedArchaeologists[i]);\n            }\n        }\n\n        (\n            uint256 accuserBondReward,\n            uint256 embalmerBondReward\n        ) = _distributeLoot(\n                paymentAddress,\n                sarco,\n                totalCursedBond,\n                diggingFeesToBeDistributed\n            );\n\n        sarco.state = LibTypes.SarcophagusState.Accused;\n\n        emit AccuseArchaeologist(\n            sarcoId,\n            msg.sender,\n            accuserBondReward,\n            embalmerBondReward\n        );\n    }\n\n    /**\n     * @notice Takes a sarcophagus's cursed bond, splits it in half, and sends\n     * to paymentAddress and embalmer\n     * @param paymentAddress payment address for the transaction caller\n     * @param sarc the sarcophagus to operate on\n     * @param totalCursedBond the sum of cursed bonds of all archs that failed to fulfil their duties\n     * @param totalDiggingFee the sum of digging fees of all archs that failed to fulfil their duties\n     * @return halfToSender the amount of SARCO token going to transaction\n     * sender\n     * @return halfToEmbalmer the amount of SARCO token going to embalmer\n     */\n    function _distributeLoot(\n        address paymentAddress,\n        LibTypes.Sarcophagus storage sarc,\n        uint256 totalCursedBond,\n        uint256 totalDiggingFee\n    ) private returns (uint256, uint256) {\n        // split the sarcophagus's cursed bond into two halves\n        uint256 halfToEmbalmer = totalCursedBond / 2;\n        uint256 halfToSender = totalCursedBond - halfToEmbalmer;\n\n        // transfer the cursed half, plus digging fee to the\n        // embalmer\n        s.sarcoToken.transfer(sarc.embalmer, totalDiggingFee + halfToEmbalmer);\n\n        // transfer the other half of the cursed bond to the transaction caller\n        s.sarcoToken.transfer(paymentAddress, halfToSender);\n\n        return (halfToSender, halfToEmbalmer);\n    }\n\n    function _hashHelper(bytes memory data) private pure returns (bytes32) {\n        return keccak256(data);\n    }\n}\n"
    },
    "contracts/libraries/LibErrors.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\n/**\n * @title A collection of Errors\n * @notice This library defines all of the Errors that the Sarcophagus system\n * uses.\n */\nlibrary LibErrors {\n    error AccuseNotEnoughProof(uint256 shardsProvided, uint8 minShards);\n\n    error AccuseIncorrectProof();\n\n    error ArchaeologistAlreadyUnwrapped(address archaeologist);\n\n    error ArchaeologistListNotUnique(address[] archaeologists);\n\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\n\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\n\n    error ArweaveTxIdsInvalid();\n\n    error DiggingFeeTooLow(uint256 diggingFee, address archaeologist);\n\n    error MinShardsGreaterThanArchaeologists(uint8 minShards);\n\n    error MinShardsZero();\n\n    error MaxResurrectionIntervalIsZero();\n\n    error NewResurrectionTimeInPast(uint256 newResurrectionTime);\n\n    error NewResurrectionTimeTooLarge(uint256 newResurrectionTime);\n\n    error NoArchaeologistsProvided();\n\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\n\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\n\n    error NotEnoughReward(uint256 reward, uint256 amount);\n\n    error ResurrectionTimeInPast(uint256 resurrectionTime);\n\n    error ResurrectionTimeTooFarInFuture(uint256 resurrectionTime, uint256 sarcophagusMaximumRewrapInterval);\n\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\n\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\n\n    error SarcophagusInactive(bytes32 sarcoId);\n\n    error SenderNotEmbalmer(address sender, address embalmer);\n\n    error InvalidSignature(\n    // address recovered from signature via ecrecover\n        address recoveredAddress,\n    // address we expected to have signed the data\n        address expectedAddress\n    );\n\n    error SignerNotArchaeologistOnSarcophagus(bytes32 sarcoId, address signer);\n\n    // Used when an attempt is made to accuse or rewrap after the resurrection time has already passed (so it's actually time to unwrap it)\n    error SarcophagusIsUnwrappable();\n\n    // Used when an attempt is made to clean a sarcophagus before the grace period after the resurrection time has passed\n    error SarcophagusNotCleanable();\n\n    error TooEarlyToUnwrap(uint256 resurrectionTime, uint256 currentTime);\n\n    error TooLateToUnwrap(\n        uint256 resurrectionTime,\n        uint256 gracePeriod,\n        uint256 currentTime\n    );\n\n    error UnencryptedShardHashMismatch(\n        bytes unencryptedShard,\n        bytes32 doubleHashedShard\n    );\n\n    error SarcophagusParametersExpired(uint256 timestamp);\n}\n\n"
    },
    "contracts/libraries/LibBonds.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\n\nlibrary LibBonds {\n    /// @notice Calculates the cursed bond that an archaeologist needs to lock\n    /// up\n    /// @dev The cursed bond amount is the digging fee\n    /// @param diggingFee The digging fee of the sarcophagus\n    /// @return The amount of cursed bond\n    function calculateCursedBond(uint256 diggingFee)\n        internal\n        pure\n        returns (uint256)\n    {\n        // TODO: We dont need this function unless we implement a better algorithm\n        // for calculating the cursed bond\n        // Anywhere this method is used should be replaced with just the digging fee\n        return diggingFee;\n    }\n\n    /// @notice Decreases the amount stored in the freeBond mapping for an\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\n    /// the amount.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being decreased\n    /// @param amount The amount to decrease the free bond by\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Revert if the amount is greater than the current free bond\n        if (amount > s.archaeologistProfiles[archaeologist].freeBond) {\n            revert LibErrors.NotEnoughFreeBond(\n                s.archaeologistProfiles[archaeologist].freeBond,\n                amount\n            );\n        }\n\n        // Decrease the free bond amount\n        s.archaeologistProfiles[archaeologist].freeBond -= amount;\n    }\n\n    /// @notice Increases the amount stored in the freeBond mapping for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being decreased\n    /// @param amount The amount to decrease the free bond by\n    function increaseFreeBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Increase the free bond amount\n        s.archaeologistProfiles[archaeologist].freeBond += amount;\n    }\n\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\n    /// archaeologist. Reverts if the archaeologist's cursed bond is lower than\n    /// the amount.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being decreased\n    /// @param amount The amount to decrease the cursed bond by\n    function decreaseCursedBond(address archaeologist, uint256 amount)\n        internal\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Revert if the amount is greater than the current cursed bond\n        if (amount > s.archaeologistProfiles[archaeologist].cursedBond) {\n            revert LibErrors.NotEnoughCursedBond(\n                s.archaeologistProfiles[archaeologist].cursedBond,\n                amount\n            );\n        }\n\n        // Decrease the cursed bond amount\n        s.archaeologistProfiles[archaeologist].cursedBond -= amount;\n    }\n\n    /// @notice Increases the amount stored in the cursedBond mapping for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being decreased\n    /// @param amount The amount to decrease the cursed bond by\n    function increaseCursedBond(address archaeologist, uint256 amount)\n        internal\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Increase the cursed bond amount\n        s.archaeologistProfiles[archaeologist].cursedBond += amount;\n    }\n\n    /// @notice Locks up the archaeologist's bond, decreasing the\n    /// archaeologist's free bond by an amount and increasing the\n    /// archaeologist's cursed bond by the same amount.\n    /// @param archaeologist The address of the archaeologist\n    /// @param amount The amount to lock up\n    function lockUpBond(address archaeologist, uint256 amount) internal {\n        // Decrease the free bond amount\n        decreaseFreeBond(archaeologist, amount);\n\n        // Increase the cursed bond amount\n        increaseCursedBond(archaeologist, amount);\n    }\n\n    /// @notice Unlocks the archaeologist's bond, increasing the\n    /// archaeologist's free bond by an amount and decreasing the\n    /// archaeologist's cursed bond by the same amount.\n    /// @param archaeologist The address of the archaeologist\n    /// @param amount The amount to unlock\n    function unlockBond(address archaeologist, uint256 amount) internal {\n        // Decrease the cursed bond amount\n        decreaseCursedBond(archaeologist, amount);\n\n        // Increase the free bond amount\n        increaseFreeBond(archaeologist, amount);\n    }\n\n    /// @notice Calculates an archaeologist's cursed bond and curses them (locks\n    /// up the free bond).\n    /// @param sarcoId the identifier of the sarcophagus to bond the archaeologist with\n    /// @param archaeologist the address of the archaeologist to curse\n    function curseArchaeologist(bytes32 sarcoId, address archaeologist)\n        internal\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Get the archaeologist's data from storage\n        LibTypes.ArchaeologistStorage memory archaeologistData = s\n            .sarcophagusArchaeologists[sarcoId][archaeologist];\n\n        // Calculate the amount of cursed bond the archaeologists needs to lock up\n        uint256 cursedBondAmount = calculateCursedBond(\n            archaeologistData.diggingFee\n        );\n\n        // Lock up the archaeologist's bond by the cursed bond amount\n        lockUpBond(archaeologist, cursedBondAmount);\n    }\n\n    /// @notice Calculates an archaeologist's cursed bond and frees them\n    /// (unlocks the cursed bond).\n    /// @param sarcoId the identifier of the sarcophagus to free the archaologist from\n    /// @param archaeologist the address of the archaeologist to free\n    function freeArchaeologist(bytes32 sarcoId, address archaeologist)\n        internal\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Get the archaeologist's data from storage\n        LibTypes.ArchaeologistStorage memory archaeologistData = s\n            .sarcophagusArchaeologists[sarcoId][archaeologist];\n\n        // Calculate the amount of cursed bond the archaeologists needs to lock up\n        uint256 cursedBondAmount = calculateCursedBond(\n            archaeologistData.diggingFee\n        );\n\n        // Free up the archaeologist's locked bond\n        unlockBond(archaeologist, cursedBondAmount);\n    }\n}\n"
    },
    "contracts/libraries/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\n\n/**\n * @title Utility functions used within the Sarcophagus system\n * @notice This library implements various functions that are used throughout\n * Sarcophagus, mainly to DRY up the codebase\n * @dev these functions are all stateless, public, pure/view\n */\nlibrary LibUtils {\n    /**\n     * @notice Reverts if the public key length is not exactly 64 bytes long\n     * @param publicKey the key to check length of\n     */\n    function publicKeyLength(bytes memory publicKey) public pure {\n        require(publicKey.length == 64, \"public key must be 64 bytes\");\n    }\n\n    /**\n     * @notice Reverts if the hash of singleHash does not equal doubleHash\n     * @param doubleHash the hash to compare hash of singleHash to\n     * @param singleHash the value to hash and compare against doubleHash\n     */\n    function hashCheck(bytes32 doubleHash, bytes memory singleHash)\n        public\n        pure\n    {\n        require(doubleHash == keccak256(singleHash), \"hashes do not match\");\n    }\n\n    function archaeologistUnwrappedCheck(bytes32 sarcoId, address archaeologist)\n        internal\n        view\n    {\n        if (\n            getArchaeologist(sarcoId, archaeologist).unencryptedShard.length > 0\n        ) {\n            revert LibErrors.ArchaeologistAlreadyUnwrapped(archaeologist);\n        }\n    }\n\n    /**\n     * @notice Reverts with `SarcophagusDoesNotExist` if the Sarcophagus does not exist,\n     * or with `SarcophagusInactive` if the Sarcophagus exists but is not active.\n     * @param sarcoId Identifier of the Sarcophagus\n     */\n    function revertIfNotExistOrInactive(bytes32 sarcoId) internal view {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        if (\n            s.sarcophagi[sarcoId].state ==\n            LibTypes.SarcophagusState.DoesNotExist\n        ) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        if (s.sarcophagi[sarcoId].state != LibTypes.SarcophagusState.Active) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n    }\n\n    /**\n     * @notice The archaeologist needs to sign off on two pieces of data\n     * to guarantee their unrwap will be successful\n     *\n     * @param unencryptedShardDoubleHash the double hash of the unencrypted shard\n     * @param arweaveTxId the arweave TX ID that contains the archs encrypted shard\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\n     * @param diggingFee that the archaeologist has agreed to for the sarcophagus\n     * @param v signature element\n     * @param r signature element\n     * @param s signature element\n     * @param account address to confirm signature of data came from\n     */\n    function verifyArchaeologistSignature(\n        bytes32 unencryptedShardDoubleHash,\n        string memory arweaveTxId,\n        uint256 agreedMaximumRewrapInterval,\n        uint256 timestamp,\n        uint256 diggingFee,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address account\n    ) internal pure {\n        // Hash the hash of the data payload\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encode(arweaveTxId, unencryptedShardDoubleHash, agreedMaximumRewrapInterval, diggingFee, timestamp))\n            )\n        );\n\n        // Generate the address from the signature.\n        // ecrecover should always return a valid address.\n        address recoveredAddress = ecrecover(messageHash, v, r, s);\n\n        if (recoveredAddress != account) {\n            revert LibErrors.InvalidSignature(recoveredAddress, account);\n        }\n    }\n\n    /// @notice Returns the address that signed some data given the data and the\n    /// signature.\n    /// @param data the data to verify\n    /// @param v signature element\n    /// @param r signature element\n    /// @param s signature element\n    /// @return the address that signed the data\n    function recoverAddress(\n        bytes memory data,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // Hash the hash of the data payload\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encode(data))\n            )\n        );\n\n        // Genearate the address from the signature.\n        // ecrecover should always return a valid address.\n        // It's highly recommended that a hash be passed into ecrecover\n        address account = ecrecover(messageHash, v, r, s);\n\n        return account;\n    }\n\n    /**\n     * @notice Reverts if the given resurrection time is not in the future\n     * @param resurrectionTime the time to check against block.timestamp\n     */\n    function resurrectionInFuture(uint256 resurrectionTime) internal view {\n        if (resurrectionTime <= block.timestamp) {\n            revert LibErrors.ResurrectionTimeInPast(resurrectionTime);\n        }\n    }\n\n    /**\n     * @notice Reverts if the current block timestamp is not within the resurrection window\n     * (window = [resurrection time, resurrection time + grace period] inclusive)\n     * @param resurrectionTime the resurrection time of the sarcophagus\n     * (absolute, i.e. a date time stamp)\n     */\n    function unwrapTime(uint256 resurrectionTime) internal view {\n        // revert if too early\n        if (resurrectionTime > block.timestamp) {\n            revert LibErrors.TooEarlyToUnwrap(\n                resurrectionTime,\n                block.timestamp\n            );\n        }\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // revert if too late\n        if (resurrectionTime + s.gracePeriod < block.timestamp) {\n            revert LibErrors.TooLateToUnwrap(\n                resurrectionTime,\n                s.gracePeriod,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @notice Checks if the archaeologist exists on the sarcophagus.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param archaeologist the address of the archaeologist\n    /// @return The boolean true if the archaeologist exists on the sarcophagus\n    function archaeologistExistsOnSarc(bytes32 sarcoId, address archaeologist)\n        internal\n        view\n        returns (bool)\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // If the doubleHashedShard on an archaeologist is 0 (which is its default value),\n        // then the archaeologist doesn't exist on the sarcophagus\n        return\n            s\n            .sarcophagusArchaeologists[sarcoId][archaeologist]\n                .unencryptedShardDoubleHash != 0;\n    }\n\n    /// @notice Checks if an archaeologist profile exists and\n    /// reverts if so\n    ///\n    /// @param archaeologist the archaeologist address to check existence of\n    function revertIfArchProfileExists(address archaeologist)\n        internal\n        view\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        if (s.archaeologistProfiles[archaeologist].exists) {\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(\n                false,\n                archaeologist\n            );\n        }\n    }\n\n    /// @notice Checks if an archaeologist profile doesn't exist and\n    /// reverts if so\n    ///\n    /// @param archaeologist the archaeologist address to check lack of existence of\n    function revertIfArchProfileDoesNotExist(address archaeologist)\n        internal\n        view\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        if (!s.archaeologistProfiles[archaeologist].exists) {\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(\n                true,\n                archaeologist\n            );\n        }\n    }\n\n    /// @notice Gets an archaeologist given the sarcophagus identifier and the\n    /// archaeologist's address.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param archaeologist the address of the archaeologist\n    /// @return The archaeologist\n    function getArchaeologist(bytes32 sarcoId, address archaeologist)\n        internal\n        view\n        returns (LibTypes.ArchaeologistStorage memory)\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        return s.sarcophagusArchaeologists[sarcoId][archaeologist];\n    }\n\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\n    /// @return The protocol fees amount\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 100;\n    }\n}\n"
    },
    "contracts/facets/ViewStateFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../libraries/LibTypes.sol\";\nimport \"hardhat/console.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract ViewStateFacet {\n    AppStorage internal s;\n\n    /// @notice Gets the total protocol fees from the contract.\n    /// @return The total protocol fees\n    function getTotalProtocolFees() external view returns (uint256) {\n        return s.totalProtocolFees;\n    }\n\n    /// @notice Get the protocol fee base percentage from the contract.\n    /// @return The protocol fee base percentage - protocolFeeBasePercentage\n    function getProtocolFeeBasePercentage() external view returns (uint256) {\n        return s.protocolFeeBasePercentage;\n    }\n\n    /// @notice Gets archaeologist profiles given a list of archaeologist addresses.\n    /// If an invalid address is included, simply leaves it out of the list.\n    /// @param addresses The list of archaeologist addresses\n    /// @return The list of archaeologist profiles\n    function getArchaeologistProfiles(address[] memory addresses)\n        external\n        view\n        returns (LibTypes.ArchaeologistProfile[] memory)\n    {\n        LibTypes.ArchaeologistProfile[]\n            memory profiles = new LibTypes.ArchaeologistProfile[](\n                addresses.length\n            );\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            // Check that the archaeologist profile exists\n            if (!s.archaeologistProfiles[addresses[i]].exists) {\n                continue;\n            }\n            profiles[i] = s.archaeologistProfiles[addresses[i]];\n        }\n\n        return profiles;\n    }\n\n    /// @notice Gets the grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time passes\n    /// @return The resurrection grace period\n    function getGracePeriod() external view returns (uint256) {\n        return s.gracePeriod;\n    }\n\n    /// @notice Gets the expiration threshold after which a sarcophagus must be renegotiated\n    /// @return The expiration threshold\n    function getExpirationThreshold() external view returns (uint256) {\n        return s.expirationThreshold;\n    }\n\n    /// @notice Given an archaeologist address, return that archaeologist's\n    /// profile\n    /// @param archaeologist The archaeologist account's address\n    /// @return the Archaeologist object\n    function getArchaeologistProfile(address archaeologist)\n        external\n        view\n        returns (LibTypes.ArchaeologistProfile memory)\n    {\n        return s.archaeologistProfiles[archaeologist];\n    }\n\n    /// @notice Return the list of registereed archaeologist addresses.\n    /// @return addresses of registered archaeologists\n    function getArchaeologistProfileAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return s.archaeologistProfileAddresses;\n    }\n\n    /// @notice Given an index (of the full archaeologist array), return the\n    /// archaeologist address at that index\n    /// @param index The index of the registered archaeologist\n    /// @return address of the archaeologist\n    function getArchaeologistProfileAddressAtIndex(uint256 index)\n        external\n        view\n        returns (address)\n    {\n        return s.archaeologistProfileAddresses[index];\n    }\n\n    /// @notice Returns the amount of free bond stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being returned\n    function getFreeBond(address archaeologist)\n        external\n        view\n        returns (uint256)\n    {\n        return s.archaeologistProfiles[archaeologist].freeBond;\n    }\n\n    /// @notice Returns the amount of rewards stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// reward is being returned\n    function getRewards(address archaeologist) external view returns (uint256) {\n        return s.archaeologistRewards[archaeologist];\n    }\n\n    /// @notice Returns the amount of cursed bond stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being returned\n    function getCursedBond(address archaeologist)\n        external\n        view\n        returns (uint256)\n    {\n        return s.archaeologistProfiles[archaeologist].cursedBond;\n    }\n\n    /// @notice Returns whether an archaeologist completed an unwrap for a sarcophagus\n    /// @param archaeologist The address of the archaeologist\n    /// @param sarcoId the sarcophagus to check if unwrapping occured\n    function getArchaeologistSuccessOnSarcophagus(\n        address archaeologist,\n        bytes32 sarcoId\n    ) external view returns (bool) {\n        return s.archaeologistSarcoSuccesses[archaeologist][sarcoId];\n    }\n\n    /// @notice Returns the number of successful unwraps for an archaeologist.\n    /// @param archaeologist The address of the archaeologist whose success\n    //  count is being returned\n    function getArchaeologistSuccessesCount(address archaeologist)\n        external\n        view\n        returns (uint256)\n    {\n        return s.archaeologistSuccesses[archaeologist].length;\n    }\n\n    /// @notice Returns the sarcophagus unique identifier for a given\n    /// archaeologist and index of the successfully unwrapped sarcophagi\n    /// @param archaeologist The address of an archaeologist\n    /// @param index The index of the archaeologist's unwrapped sarcophagi\n    /// @return the identifier associated with the index of the archaeologist's\n    /// unwrapped sarcophagi\n    function archaeologistSuccessesIdentifier(\n        address archaeologist,\n        uint256 index\n    )\n        external\n        view\n        returns (bytes32)\n    {\n        return s.archaeologistSuccesses[archaeologist][index];\n    }\n\n    /// @notice Returns the number of accusations for an archaeologist.\n    /// @param archaeologist The address of the archaeologist whose accusations\n    /// count is being returned\n    function getArchaeologistAccusalsCount(address archaeologist)\n        external\n        view\n        returns (uint256)\n    {\n        return s.archaeologistAccusals[archaeologist].length;\n    }\n\n    /// @notice Returns the sarcophagus unique identifier for a given\n    /// archaeologist and index of the accused sarcophagi\n    /// @param archaeologist The address of an archaeologist\n    /// @param index The index of the archaeologist's accused sarcophagi\n    /// @return the identifier associated with the index of the archaeologist's\n    /// accused sarcophagi\n    function archaeologistAccusalsIdentifier(\n        address archaeologist,\n        uint256 index\n    )\n        external\n        view\n        returns (bytes32)\n    {\n        return s.archaeologistAccusals[archaeologist][index];\n    }\n\n    /// @notice Returns the number of cleanups for an archaeologist.\n    /// @param archaeologist The address of the archaeologist whose cleanups\n    /// count is being returned\n    function getArchaeologistCleanupsCount(address archaeologist)\n        external\n        view\n        returns (uint256)\n    {\n        return s.archaeologistCleanups[archaeologist].length;\n    }\n\n    /// @notice Returns the sarcophagus unique identifier for a given\n    /// archaeologist and index of the cleaned-up sarcophagi\n    /// @param archaeologist The address of an archaeologist\n    /// @param index The index of the archaeologist's cleaned-up sarcophagi\n    /// @return the identifier associated with the index of the archaeologist's\n    /// cleaned-up sarcophagi\n    function archaeologistCleanupsIdentifier(\n        address archaeologist,\n        uint256 index\n    )\n        external\n        view\n        returns (bytes32)\n    {\n        return s.archaeologistCleanups[archaeologist][index];\n    }\n\n    /// @notice Gets all reputation statistics for each archaeologist\n    /// Contains a list of counts for each category.\n    /// @param addresses The list of archaeologist addresses\n    /// @return The list of archaeologist statistics\n    function getArchaeologistsStatistics(address[] memory addresses)\n        external\n        view\n        returns (LibTypes.ArchaeologistStatistics[] memory)\n    {\n        LibTypes.ArchaeologistStatistics[]\n        memory statsList = new LibTypes.ArchaeologistStatistics[](\n            addresses.length\n        );\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            statsList[i] = LibTypes.ArchaeologistStatistics(\n                this.getArchaeologistSuccessesCount(addresses[i]),\n                this.getArchaeologistAccusalsCount(addresses[i]),\n                this.getArchaeologistCleanupsCount(addresses[i])\n            );\n        }\n\n        return statsList;\n    }\n\n    /// @notice Returns a sarcophagus.\n    /// @param sarcoId The identifier of the sarcophagus being returned\n    function getSarcophagus(bytes32 sarcoId)\n        external\n        view\n        returns (LibTypes.Sarcophagus memory)\n    {\n        LibTypes.Sarcophagus memory sarco = s.sarcophagi[sarcoId];\n        if (sarco.state != LibTypes.SarcophagusState.Active) {\n            return sarco;\n        }\n\n        uint8 unwrapsCount = 0;\n        for (uint8 i = 0; i < sarco.archaeologists.length; i++) {\n            bytes memory shard = s\n            .sarcophagusArchaeologists[sarcoId][sarco.archaeologists[i]]\n                .unencryptedShard;\n\n            if (shard.length != 0) {\n                unwrapsCount = unwrapsCount + 1;\n                sarco.state = LibTypes.SarcophagusState.Resurrecting;\n            }\n\n            if (unwrapsCount == sarco.minShards) {\n                sarco.state = LibTypes.SarcophagusState.Resurrected;\n                break;\n            }\n        }\n\n        if (\n            unwrapsCount < sarco.minShards &&\n            block.timestamp > sarco.resurrectionTime + s.gracePeriod\n        ) {\n            sarco.state = LibTypes.SarcophagusState.Failed;\n        }\n\n        return sarco;\n    }\n\n    /// @notice Given an embalmer's address, returns the identifiers of all\n    /// sarcophagi that the embalmer has created.\n    /// @param embalmer The address of the embalmer whose sarcophagi are being\n    /// returned\n    function getEmbalmerSarcophagi(address embalmer)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.embalmerSarcophagi[embalmer];\n    }\n\n    /// @notice Given an archaeologist's address, returns the identifiers of all\n    /// sarcophagi that the archaeologist has participated in.\n    /// @param archaeologist The address of the archaeologist whose sarcophagi\n    /// are being returned\n    function getArchaeologistSarcophagi(address archaeologist)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.archaeologistSarcophagi[archaeologist];\n    }\n\n    /// @notice Given a recipient's address, returns the identifiers of all\n    /// sarcophagi that the recipient has participated in.\n    /// @param recipient The address of the recipient whose sarcophagi are being\n    /// returned\n    function getRecipientSarcophagi(address recipient)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.recipientSarcophagi[recipient];\n    }\n\n    /// @notice Returns the data stored on a sarcophagus for an archaeologist.\n    /// @param sarcoId The identifier of the sarcophagus whose data is being\n    /// returned\n    /// @param archaeologist The address of the archaeologist whose data is\n    /// being returned\n    function getSarcophagusArchaeologist(bytes32 sarcoId, address archaeologist)\n        external\n        view\n        returns (LibTypes.ArchaeologistStorage memory)\n    {\n        return s.sarcophagusArchaeologists[sarcoId][archaeologist];\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/facets/EmbalmerFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract EmbalmerFacet {\n    // IMPORTANT: AppStorage must be the first state variable in the facet.\n    AppStorage internal s;\n\n    event CreateSarcophagus(\n        bytes32 indexed sarcoId,\n        string name,\n        bool canBeTransferred,\n        uint256 resurrectionTime,\n        address embalmer,\n        address recipient,\n        address[] cursedArchaeologists,\n        uint256 totalDiggingFees,\n        uint256 createSarcophagusProtocolFees,\n        string[] arweaveTxIds\n    );\n\n    event RewrapSarcophagus(\n        bytes32 indexed sarcoId,\n        uint256 resurrectionTime,\n        uint256 totalDiggingFees,\n        uint256 rewrapSarcophagusProtocolFees\n    );\n\n    event BurySarcophagus(bytes32 indexed sarcoId);\n\n    // Archaeologist's addresses are added to this mapping per sarcophagus to\n    // verify that the same archaeologist signature is not used more than once.\n    mapping(bytes32 => mapping(address => bool)) private verifiedArchaeologists;\n\n    /// @notice Embalmer creates the sarcophagus.\n    ///\n    /// The purpose of createSarcophagus is to:\n    ///   - Lock up payment for the selected archaeologists (digging fees)\n    ///   - Store the arweave TX IDs pertaining to the encrypted file payload\n    ///   -    and the encrypted shards\n    ///   - Verify the selected archaeologists have signed off on the\n    ///         double hash of their key share,\n    ///         arweave tx id storing key shares,\n    ///         and maximumRewrapInterval to be used for lifetime of the sarcophagus\n    ///   - Store the selected archaeologists' addresses, digging fees and\n    ///   -     unencrypted double hashes\n    ///   - Curse each participating archaeologist\n    ///   - Create the sarcophagus object\n    ///\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param sarcophagus an object that contains the sarcophagus data\n    /// @param selectedArchaeologists the archaeologists the embalmer has selected to curse\n    /// @param arweaveTxIds ordered pair of arweave tx ids: [tx storing sarcophagus payload,\n    ///         tx storing the archaeologists' encrypted key shares]\n    /// @return The index of the new sarcophagus\n    function createSarcophagus(\n        bytes32 sarcoId,\n        LibTypes.SarcophagusMemory memory sarcophagus,\n        LibTypes.SelectedArchaeologistData[] memory selectedArchaeologists,\n        string[] memory arweaveTxIds\n    ) external returns (uint256) {\n        // Confirm that this exact sarcophagus does not already exist\n        if (\n            s.sarcophagi[sarcoId].state !=\n            LibTypes.SarcophagusState.DoesNotExist\n        ) {\n            revert LibErrors.SarcophagusAlreadyExists(sarcoId);\n        }\n\n        // Confirm that the agreed upon sarcophagus parameters have not expired\n        if (sarcophagus.timestamp + s.expirationThreshold < block.timestamp) {\n            revert LibErrors.SarcophagusParametersExpired(\n                sarcophagus.timestamp\n            );\n        }\n\n        // Confirm that the resurrection time is in the future\n        if (sarcophagus.resurrectionTime <= block.timestamp) {\n            revert LibErrors.ResurrectionTimeInPast(\n                sarcophagus.resurrectionTime\n            );\n        }\n\n        // Confirm that resurrection or rewrap will occur before the maximumRewrapInterval elapses\n        if (sarcophagus.resurrectionTime > block.timestamp + sarcophagus.maximumRewrapInterval) {\n            revert LibErrors.ResurrectionTimeTooFarInFuture(sarcophagus.resurrectionTime, sarcophagus.maximumRewrapInterval);\n        }\n\n        // Validate exactly 2 arweave TX IDs have been provided\n        // TODO: See if we can verify exact byte length of arweave TXs\n        if (arweaveTxIds.length != 2 || bytes(arweaveTxIds[0]).length == 0 || bytes(arweaveTxIds[1]).length == 0) {\n            revert LibErrors.ArweaveTxIdsInvalid();\n        }\n\n        // Confirm that archaeologists are provided\n        if (selectedArchaeologists.length == 0) {\n            revert LibErrors.NoArchaeologistsProvided();\n        }\n\n        // Confirm that minShards is greater than 0\n        if (sarcophagus.minShards == 0) {\n            revert LibErrors.MinShardsZero();\n        }\n\n        // Confirm that minShards is less than or equal to the number of archaeologists\n        // (k <= n in a shamir secret sharing scheme)\n        if (sarcophagus.minShards > selectedArchaeologists.length) {\n            revert LibErrors.MinShardsGreaterThanArchaeologists(\n                sarcophagus.minShards\n            );\n        }\n\n        // Initialize a list of archaeologist addresses to be passed in to the\n        // sarcophagus object\n        address[] memory cursedArchaeologists = new address[](\n            selectedArchaeologists.length\n        );\n\n        uint256 totalDiggingFees = 0;\n\n        for (uint256 i = 0; i < selectedArchaeologists.length; i++) {\n            LibTypes.SelectedArchaeologistData memory arch = selectedArchaeologists[i];\n            LibUtils.revertIfArchProfileDoesNotExist(arch.archAddress);\n\n            // Confirm that the archaeologist list is unique. This is done by\n            // checking that the archaeologist does not already exist from\n            // previous iterations in this loop.\n            if (LibUtils.archaeologistExistsOnSarc(sarcoId, arch.archAddress)) {\n                revert LibErrors.ArchaeologistListNotUnique(\n                    cursedArchaeologists\n                );\n            }\n\n            // Validate the archaeologist has signed off on the sarcophagus parameters: double hashed key share,\n            // arweaveTxId[1] (tx storing share on arweave), maximumRewrapInterval for sarcophagus\n            LibUtils.verifyArchaeologistSignature(\n                arch.unencryptedShardDoubleHash,\n                arweaveTxIds[1],\n                sarcophagus.maximumRewrapInterval,\n                sarcophagus.timestamp,\n                arch.diggingFee,\n                arch.v,\n                arch.r,\n                arch.s,\n                arch.archAddress\n            );\n\n            totalDiggingFees += arch.diggingFee;\n\n            LibTypes.ArchaeologistStorage memory archaeologistStorage = LibTypes\n                .ArchaeologistStorage({\n                    diggingFee: arch.diggingFee,\n                    diggingFeesPaid: 0,\n                    unencryptedShardDoubleHash: arch.unencryptedShardDoubleHash,\n                    unencryptedShard: \"\"\n                });\n\n            // Map the double-hashed share to this archaeologist's address for easier referencing on accuse\n            s.doubleHashedShardArchaeologists[arch.unencryptedShardDoubleHash] = arch\n                .archAddress;\n\n            // Save the necessary archaeologist data to the sarcophagus\n            s.sarcophagusArchaeologists[sarcoId][\n                arch.archAddress\n            ] = archaeologistStorage;\n\n            // Add the sarcophagus identifier to archaeologist's list of sarcophagi\n            s.archaeologistSarcophagi[arch.archAddress].push(sarcoId);\n\n            // Move free bond to cursed bond on archaeologist\n            LibBonds.curseArchaeologist(sarcoId, arch.archAddress);\n\n            // Add the archaeologist address to the list of addresses to be\n            // passed in to the sarcophagus object\n            cursedArchaeologists[i] = arch.archAddress;\n        }\n\n        // Create the sarcophagus object and store it in AppStorage\n\n        // Sarco will continue to be in Active state past its resurrection window\n        // if no archaeologist ever unwraps it and it's never cleaned, buried or accused.\n        // Failure can be inferred by simply making sure to check if the Sarco has\n        // expired when its state is Active.\n        // Note this is also true for the Resurrecting state, if at leaset one of the\n        // archaeologists did unwrap before it was too late.\n        s.sarcophagi[sarcoId] = LibTypes.Sarcophagus({\n            name: sarcophagus.name,\n            state: LibTypes.SarcophagusState.Active,\n            canBeTransferred: sarcophagus.canBeTransferred,\n            minShards: sarcophagus.minShards,\n            resurrectionTime: sarcophagus.resurrectionTime,\n            maximumRewrapInterval: sarcophagus.maximumRewrapInterval,\n            arweaveTxIds: arweaveTxIds,\n            embalmer: msg.sender,\n            recipientAddress: sarcophagus.recipient,\n            archaeologists: cursedArchaeologists\n        });\n\n        // Add the identifier to the necessary data structures\n        s.sarcophagusIdentifiers.push(sarcoId);\n        s.embalmerSarcophagi[msg.sender].push(sarcoId);\n        s.recipientSarcophagi[sarcophagus.recipient].push(sarcoId);\n\n        // Transfer the total fees amount + protocol fees in sarco token from the embalmer to this contract\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\n\n        // Add the create sarcophagus protocol fee to the total protocol fees in storage\n        s.totalProtocolFees += protocolFees;\n\n        s.sarcoToken.transferFrom(\n            msg.sender,\n            address(this),\n            totalDiggingFees + protocolFees\n        );\n\n        // Emit the event\n        emit CreateSarcophagus(\n            sarcoId,\n            sarcophagus.name,\n            sarcophagus.canBeTransferred,\n            sarcophagus.resurrectionTime,\n            msg.sender,\n            sarcophagus.recipient,\n            cursedArchaeologists,\n            totalDiggingFees,\n            protocolFees,\n            arweaveTxIds\n        );\n\n        // Return the index of the sarcophagus\n        return s.sarcophagusIdentifiers.length - 1;\n    }\n\n    /// @notice The embalmer may extend the life of the sarcophagus as long as\n    /// the resurrection time has not passed yet.\n    /// @dev The embalmer sets a new resurrection time sometime in the future.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param resurrectionTime the new resurrection time\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime)\n        external\n    {\n        LibUtils.revertIfNotExistOrInactive(sarcoId);\n\n        // Confirm that the sender is the embalmer\n        if (s.sarcophagi[sarcoId].embalmer != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(\n                msg.sender,\n                s.sarcophagi[sarcoId].embalmer\n            );\n        }\n\n        // Confirm current resurrection time is in future (sarcophagus is rewrappable)\n        if (s.sarcophagi[sarcoId].resurrectionTime <= block.timestamp) {\n            revert LibErrors.SarcophagusIsUnwrappable();\n        }\n\n        // Confirm that the new resurrection time is in the future\n        if (resurrectionTime <= block.timestamp) {\n            revert LibErrors.NewResurrectionTimeInPast(resurrectionTime);\n        }\n\n\n        // Confirm that the new resurrection time doesn't exceed the sarcophagus's maximumRewrapInterval\n        if (resurrectionTime > block.timestamp + s.sarcophagi[sarcoId].maximumRewrapInterval) {\n            revert LibErrors.NewResurrectionTimeTooLarge(resurrectionTime);\n        }\n\n        // For each archaeologist on the sarcophagus, transfer their digging fee allocations to them\n        address[] memory bondedArchaeologists = s\n            .sarcophagi[sarcoId]\n            .archaeologists;\n\n        uint256 totalDiggingFees = 0;\n\n        for (uint256 i = 0; i < bondedArchaeologists.length; i++) {\n            // Get the archaeolgist's fee data\n            LibTypes.ArchaeologistStorage memory archaeologistData = LibUtils\n                .getArchaeologist(sarcoId, bondedArchaeologists[i]);\n\n            // Transfer the archaeologist's digging fee allocation to the archaeologist's reward pool\n            s.archaeologistRewards[bondedArchaeologists[i]] += archaeologistData.diggingFee;\n\n            // Add to the total of digging fees paid\n            archaeologistData.diggingFeesPaid += archaeologistData.diggingFee;\n\n            // Add the archaeologist's digging fee to the sum\n            totalDiggingFees += archaeologistData.diggingFee;\n\n            // Update the archaeologist's data in storage\n            s.sarcophagusArchaeologists[sarcoId][\n                bondedArchaeologists[i]\n            ] = archaeologistData;\n        }\n\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\n\n        // Add the protocol fee to the total protocol fees in storage\n        s.totalProtocolFees += protocolFees;\n\n        // Update the resurrectionTime on the sarcophagus to the supplied value\n        s.sarcophagi[sarcoId].resurrectionTime = resurrectionTime;\n\n        // Transfer the new digging fees from the embalmer to the sarcophagus contract.\n        // Archaeologists may withdraw their due from their respective reward pools\n        s.sarcoToken.transferFrom(\n            msg.sender,\n            address(this),\n            totalDiggingFees + protocolFees\n        );\n\n        // Emit an event\n        emit RewrapSarcophagus(sarcoId, resurrectionTime, totalDiggingFees, protocolFees);\n    }\n\n    /// @notice Permanently closes the sarcophagus, giving it no opportunity to\n    /// be resurrected.\n    /// This may only be done before resurrection time has passed.\n    /// @dev Extends the resurrection time into infinity so that that unwrap\n    /// will never be successful.\n    /// @param sarcoId the identifier of the sarcophagus\n    function burySarcophagus(bytes32 sarcoId) external {\n        LibUtils.revertIfNotExistOrInactive(sarcoId);\n\n        // Confirm that the sender is the embalmer\n        if (s.sarcophagi[sarcoId].embalmer != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(\n                msg.sender,\n                s.sarcophagi[sarcoId].embalmer\n            );\n        }\n\n        // Confirm that the current resurrection time is in the future\n        if (s.sarcophagi[sarcoId].resurrectionTime <= block.timestamp) {\n            revert LibErrors.ResurrectionTimeInPast(\n                s.sarcophagi[sarcoId].resurrectionTime\n            );\n        }\n\n        // Set resurrection time to infinity\n        s.sarcophagi[sarcoId].resurrectionTime = 2**256 - 1;\n\n        // Set sarcophagus state to done\n        s.sarcophagi[sarcoId].state = LibTypes.SarcophagusState.Buried;\n\n        // For each archaeologist on the sarcophagus,\n        // 1. Unlock their cursed bond\n        // 2. Transfer digging fees to the archaeologist.\n        address[] memory bondedArchaeologists = s\n            .sarcophagi[sarcoId]\n            .archaeologists;\n\n        for (uint256 i = 0; i < bondedArchaeologists.length; i++) {\n            // Unlock the archaeologist's cursed bond\n            LibBonds.freeArchaeologist(sarcoId, bondedArchaeologists[i]);\n\n            LibTypes.ArchaeologistStorage memory archaeologistData = LibUtils\n                .getArchaeologist(sarcoId, bondedArchaeologists[i]);\n\n            // Transfer the digging fees to the archaeologist's reward pool\n            s.archaeologistRewards[bondedArchaeologists[i]] += archaeologistData.diggingFee;\n        }\n\n        // Emit an event\n        emit BurySarcophagus(sarcoId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/facets/ArchaeologistFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract ArchaeologistFacet {\n    AppStorage internal s;\n\n    event FinalizeTransfer(\n        bytes32 sarcoId,\n        string arweaveTxId,\n        address oldArchaeologist,\n        address newArchaeologist\n    );\n\n    event UnwrapSarcophagus(bytes32 indexed sarcoId, bytes unencryptedShard);\n\n    event DepositFreeBond(address indexed archaeologist, uint256 depositedBond);\n\n    event RegisterArchaeologist(\n        address indexed archaeologist,\n        string peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond\n    );\n\n    event UpdateArchaeologist(\n        address indexed archaeologist,\n        string peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond\n    );\n\n    event WithdrawFreeBond(\n        address indexed archaeologist,\n        uint256 withdrawnBond\n    );\n\n    event WithdrawReward(\n        address indexed archaeologist,\n        uint256 withdrawnReward\n    );\n\n    /// @notice Registers the archaeologist profile\n    /// @param peerId The libp2p identifier for the archaeologist\n    /// @param minimumDiggingFee The archaeologist's minimum amount to accept for a digging fee\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\n    /// for a resurrection\n    /// @param freeBond How much bond the archaeologist wants to deposit during the register call (if any)\n    function registerArchaeologist(\n        string memory peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond\n    ) external {\n        // verify that the archaeologist does not already exist\n        LibUtils.revertIfArchProfileExists(msg.sender);\n\n        // create a new archaeologist\n        LibTypes.ArchaeologistProfile memory newArch = LibTypes\n            .ArchaeologistProfile({\n                exists: true,\n                peerId: peerId,\n                minimumDiggingFee: minimumDiggingFee,\n                maximumRewrapInterval: maximumRewrapInterval,\n                freeBond: freeBond,\n                cursedBond: 0\n            });\n\n        // transfer SARCO tokens from the archaeologist to this contract, to be\n        // used as their free bond. can be 0.\n        if (freeBond > 0) {\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\n        }\n\n        // save the new archaeologist into relevant data structures\n        s.archaeologistProfiles[msg.sender] = newArch;\n        s.archaeologistProfileAddresses.push(msg.sender);\n\n        emit RegisterArchaeologist(\n            msg.sender,\n            newArch.peerId,\n            newArch.minimumDiggingFee,\n            newArch.maximumRewrapInterval,\n            newArch.freeBond\n        );\n    }\n\n    /// @notice Updates the archaeologist profile\n    /// @param peerId The libp2p identifier for the archaeologist\n    /// @param minimumDiggingFee The archaeologist's minimum amount to accept for a digging fee\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\n    /// for a resurrection\n    /// freeBond How much bond the archaeologist wants to deposit during the update call (if any)\n    function updateArchaeologist(\n        string memory peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond\n    ) external {\n        // verify that the archaeologist exists\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n\n        // create a new archaeologist\n        LibTypes.ArchaeologistProfile storage existingArch = s\n            .archaeologistProfiles[msg.sender];\n        existingArch.peerId = peerId;\n        existingArch.minimumDiggingFee = minimumDiggingFee;\n        existingArch.maximumRewrapInterval = maximumRewrapInterval;\n\n        // transfer SARCO tokens from the archaeologist to this contract, to be\n        // used as their free bond. can be 0.\n        if (freeBond > 0) {\n            LibBonds.increaseFreeBond(msg.sender, freeBond);\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\n        }\n\n        emit UpdateArchaeologist(\n            msg.sender,\n            existingArch.peerId,\n            existingArch.minimumDiggingFee,\n            existingArch.maximumRewrapInterval,\n            existingArch.freeBond\n        );\n    }\n\n    /// @notice Deposits an archaeologist's free bond to the contract.\n    /// @param amount The amount to deposit\n    function depositFreeBond(uint256 amount) external {\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n        // Increase the archaeologist's free bond in app storage\n        LibBonds.increaseFreeBond(msg.sender, amount);\n\n        // Transfer the amount of sarcoToken from the archaeologist to the contract\n        s.sarcoToken.transferFrom(msg.sender, address(this), amount);\n        // Emit an event\n        emit DepositFreeBond(msg.sender, amount);\n    }\n\n    /// @notice Withdraws an archaeologist's free bond from the contract.\n    /// @param amount The amount to withdraw\n    function withdrawFreeBond(uint256 amount) external {\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n        // Decrease the archaeologist's free bond amount.\n        // Reverts if there is not enough free bond on the contract.\n        LibBonds.decreaseFreeBond(msg.sender, amount);\n\n        // Transfer the amount of sarcoToken to the archaeologist\n        s.sarcoToken.transfer(msg.sender, amount);\n\n        // Emit an event\n        emit WithdrawFreeBond(msg.sender, amount);\n    }\n\n    /// @notice Withdraws all rewards from an archaeologist's reward pool\n    function withdrawReward() external {\n        uint256 amountToWithdraw = s.archaeologistRewards[msg.sender];\n        s.archaeologistRewards[msg.sender] = 0;\n\n        // Transfer the amount of sarcoToken to the archaeologist\n        s.sarcoToken.transfer(msg.sender, amountToWithdraw);\n\n        emit WithdrawReward(msg.sender, amountToWithdraw);\n    }\n\n    /// @notice Unwraps the sarcophagus.\n    /// @dev Verifies that the unencrypted shard matches the hashedShard stored\n    /// on chain and pays the archaeologist.\n    /// @param sarcoId The identifier of the sarcophagus to unwrap\n    /// @param unencryptedShard The archaeologist's corresponding unencrypted shard\n    function unwrapSarcophagus(bytes32 sarcoId, bytes memory unencryptedShard)\n        external\n    {\n        LibUtils.revertIfNotExistOrInactive(sarcoId);\n\n        // Confirm that the archaeologist has not already unwrapped by checking\n        // if the unencryptedShard is empty\n        LibUtils.archaeologistUnwrappedCheck(sarcoId, msg.sender);\n\n        // Confirm that the sender is an archaeologist on this sarcophagus\n        if (!LibUtils.archaeologistExistsOnSarc(sarcoId, msg.sender)) {\n            revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\n        }\n\n        // Confirm that the resurrection time has passed and that the\n        // grace period has not passed\n        LibUtils.unwrapTime(s.sarcophagi[sarcoId].resurrectionTime);\n\n        // Get the archaeologist's data from storage\n        LibTypes.ArchaeologistStorage memory archaeologistData = LibUtils\n            .getArchaeologist(sarcoId, msg.sender);\n\n        // Confirm that the double hash of the unencrypted shard matches the hashedShard in storage\n        bytes32 doubleHash = keccak256(abi.encode(keccak256(unencryptedShard)));\n        if (doubleHash != archaeologistData.unencryptedShardDoubleHash) {\n            revert LibErrors.UnencryptedShardHashMismatch(\n                unencryptedShard,\n                archaeologistData.unencryptedShardDoubleHash\n            );\n        }\n\n        // Store the unencrypted shard in on the archaeologist object in the sarcophagus\n        s\n        .sarcophagusArchaeologists[sarcoId][msg.sender]\n            .unencryptedShard = unencryptedShard;\n\n        // Free the archaeologist's cursed bond\n        LibBonds.freeArchaeologist(sarcoId, msg.sender);\n\n        // Save the successful sarcophagus against the archaeologist\n        s.archaeologistSarcoSuccesses[msg.sender][sarcoId] = true;\n        s.archaeologistSuccesses[msg.sender].push(sarcoId);\n\n        // Transfer the digging fee to the archaeologist's reward pool\n        s.archaeologistRewards[msg.sender] += archaeologistData.diggingFee;\n\n        // Emit an event\n        emit UnwrapSarcophagus(sarcoId, unencryptedShard);\n    }\n\n    /// @notice Finalizes a transfer of roles and responsibilities between two\n    /// archaeologists. This is to be called by the new archaeologist.\n    /// @param sarcoId The identifier of the sarcophagus\n    /// @param arweaveTxId The id of the arweave transaction where the new shard\n    /// @param oldArchSignature The signature of the old archaeologist\n    /// was uploaded\n    function finalizeTransfer(\n        bytes32 sarcoId,\n        string memory arweaveTxId,\n        LibTypes.Signature memory oldArchSignature\n    ) external {\n        LibUtils.revertIfNotExistOrInactive(sarcoId);\n\n        // Confirm that the resurrection time is in the future\n        LibUtils.resurrectionInFuture(s.sarcophagi[sarcoId].resurrectionTime);\n\n        // Get the address that signed the oldArchSignature\n        address oldArchaeologist = LibUtils.recoverAddress(\n            bytes(arweaveTxId),\n            oldArchSignature.v,\n            oldArchSignature.r,\n            oldArchSignature.s\n        );\n\n        // Confirm that the oldArchaeologist is an archaeologist on this\n        // sarcophagus. Failure here means that someone besides an archaeologist\n        // on the sarcophagus signed this message or that the data being signed\n        // was not the provided arweaveTxId.\n        if (!LibUtils.archaeologistExistsOnSarc(sarcoId, oldArchaeologist)) {\n            revert LibErrors.SignerNotArchaeologistOnSarcophagus(\n                sarcoId,\n                oldArchaeologist\n            );\n        }\n\n        // Update the list of archaeologist's on the sarcophagus\n        // For each archaeologist on the sarcophagus, find the old archaeologist\n        // and replace it with the sender's address.\n        for (\n            uint256 i = 0;\n            i < s.sarcophagi[sarcoId].archaeologists.length;\n            i++\n        ) {\n            // Find the archaeologist that matches the old archaeologist's address\n            if (s.sarcophagi[sarcoId].archaeologists[i] == oldArchaeologist) {\n                s.sarcophagi[sarcoId].archaeologists[i] = msg.sender;\n\n                // Once found there is no need to continue\n                break;\n            }\n        }\n\n        // Free the old archaeologist's bond\n        LibBonds.freeArchaeologist(sarcoId, oldArchaeologist);\n\n        LibTypes.ArchaeologistStorage storage newArchData = s\n            .sarcophagusArchaeologists[sarcoId][msg.sender];\n\n        LibTypes.ArchaeologistStorage storage oldArchData = s\n            .sarcophagusArchaeologists[sarcoId][oldArchaeologist];\n\n        // Add the new archaeologist's address to the sarcohpagusArchaeologists mapping\n        newArchData.diggingFee = oldArchData.diggingFee;\n        newArchData.unencryptedShardDoubleHash = oldArchData\n            .unencryptedShardDoubleHash;\n        newArchData.unencryptedShard = \"\";\n\n        // Set the old archaeologist's data in the sarcophagusArchaeologists\n        // mapping to their default values\n        oldArchData.diggingFee = 0;\n        oldArchData.unencryptedShardDoubleHash = 0;\n        oldArchData.unencryptedShard = \"\";\n\n        // Add the arweave transaction id to arweaveTxIds on the sarcophagus\n        s.sarcophagi[sarcoId].arweaveTxIds.push(arweaveTxId);\n\n        // Curse the new archaeologist's bond\n        LibBonds.curseArchaeologist(sarcoId, msg.sender);\n\n        // Emit an event\n        emit FinalizeTransfer(\n            sarcoId,\n            arweaveTxId,\n            oldArchaeologist,\n            msg.sender\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}