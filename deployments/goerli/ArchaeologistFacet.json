{
  "address": "0x2dD49A73481BE6437813cb560439Ab809B17e3c2",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologistAddress",
          "type": "address"
        }
      ],
      "name": "ArchaeologistAlreadyPublishedPrivateKey",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologistAddress",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "ArchaeologistHasBeenAccused",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "ArchaeologistNotOnSarcophagus",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "exists",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "ArchaeologistProfileExistsShouldBe",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologistAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "publicKey",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "privateKey",
          "type": "bytes32"
        }
      ],
      "name": "ArchaeologistPublishedIncorrectPrivateKey",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CannotSetZeroProfileValue",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "cursedBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "NotEnoughCursedBond",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "NotEnoughFreeBond",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusCompromised",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusInactive",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "resurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "TooEarlyForPublish",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "publishDeadline",
          "type": "uint256"
        }
      ],
      "name": "TooLateForPublish",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "depositedBond",
          "type": "uint256"
        }
      ],
      "name": "DepositFreeBond",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "privateKey",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "PublishPrivateKey",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "minimumDiggingFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maximumResurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "RegisterArchaeologist",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "minimumDiggingFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maximumResurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "UpdateArchaeologist",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "withdrawnBond",
          "type": "uint256"
        }
      ],
      "name": "WithdrawFreeBond",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "withdrawnReward",
          "type": "uint256"
        }
      ],
      "name": "WithdrawReward",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "depositFreeBond",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "privateKey",
          "type": "bytes32"
        }
      ],
      "name": "publishPrivateKey",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "minimumDiggingFeePerSecond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maximumResurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "registerArchaeologist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "minimumDiggingFeePerSecond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maximumResurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "updateArchaeologist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawFreeBond",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawReward",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xe5b605d21e883b2e22b46c49b31b8fb5f4591534fd7eb8d679e7cefe33fc37da",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xDa863f802Cc8CBA3C436bF801BD7785d9E7d4F36",
    "contractAddress": null,
    "transactionIndex": 113,
    "gasUsed": "1899291",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2b26220a407d19fd0c5cb4ef9150891bdada591540c31bb758280eebb6944480",
    "transactionHash": "0xe5b605d21e883b2e22b46c49b31b8fb5f4591534fd7eb8d679e7cefe33fc37da",
    "logs": [],
    "blockNumber": 8783811,
    "cumulativeGasUsed": "21650300",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 4,
  "solcInputHash": "50efe6a3d8d462e9abce44badd6273ba",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologistAddress\",\"type\":\"address\"}],\"name\":\"ArchaeologistAlreadyPublishedPrivateKey\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologistAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"ArchaeologistHasBeenAccused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"ArchaeologistNotOnSarcophagus\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"ArchaeologistProfileExistsShouldBe\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologistAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"}],\"name\":\"ArchaeologistPublishedIncorrectPrivateKey\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetZeroProfileValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cursedBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotEnoughCursedBond\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotEnoughFreeBond\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusCompromised\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusInactive\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resurrectionTime\",\"type\":\"uint256\"}],\"name\":\"TooEarlyForPublish\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publishDeadline\",\"type\":\"uint256\"}],\"name\":\"TooLateForPublish\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositedBond\",\"type\":\"uint256\"}],\"name\":\"DepositFreeBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"PublishPrivateKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumDiggingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"}],\"name\":\"RegisterArchaeologist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumDiggingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"}],\"name\":\"UpdateArchaeologist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnBond\",\"type\":\"uint256\"}],\"name\":\"WithdrawFreeBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnReward\",\"type\":\"uint256\"}],\"name\":\"WithdrawReward\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositFreeBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"}],\"name\":\"publishPrivateKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFeePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"}],\"name\":\"registerArchaeologist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFeePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"}],\"name\":\"updateArchaeologist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFreeBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ArchaeologistAlreadyPublishedPrivateKey(address)\":[{\"params\":{\"archaeologistAddress\":\"address of publishing archaeologist\"}}],\"ArchaeologistHasBeenAccused(address,bytes32)\":[{\"params\":{\"archaeologistAddress\":\"Address of accused archaeologist who is attempting to publish their private key\",\"sarcoId\":\"ID of sarcophagus archaeologist has attempted to publish a key on\"}}],\"ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)\":[{\"params\":{\"archaeologistAddress\":\"address of publishing archaeologist\",\"privateKey\":\"privateKey the archaeologist has attempted to publish\",\"publicKey\":\"publicKey stored for archaeologist on the sarcophagus\"}}],\"TooEarlyForPublish(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed publish attempt\",\"resurrectionTime\":\"Time after which the sarcophagus can be resurrected\"}}],\"TooLateForPublish(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed publish attempt\",\"publishDeadline\":\"Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)\"}}]},\"events\":{\"PublishPrivateKey(bytes32,bytes32,address)\":{\"params\":{\"privateKey\":\"private key that has been published\",\"sarcoId\":\"ID of sarcophagus archaeologist has published the private key on\"}}},\"kind\":\"dev\",\"methods\":{\"depositFreeBond(uint256)\":{\"params\":{\"amount\":\"The amount to deposit\"}},\"publishPrivateKey(bytes32,bytes32)\":{\"params\":{\"privateKey\":\"The private key the archaeologist is publishing\",\"sarcoId\":\"The identifier of the sarcophagus for which the archaeologist is responsible\"}},\"registerArchaeologist(string,uint256,uint256,uint256,uint256)\":{\"params\":{\"freeBond\":\"How much bond the archaeologist wants to deposit during the register call (if any)\",\"maximumResurrectionTime\":\"The time beyond which the archaeologist is not willing to accept new curses or rewraps\",\"maximumRewrapInterval\":\"The longest interval of time from a rewrap time the arch will accept for a resurrection\",\"minimumDiggingFeePerSecond\":\"The archaeologist's minimum amount to earn per second for being cursed\",\"peerId\":\"The libp2p identifier for the archaeologist\"}},\"updateArchaeologist(string,uint256,uint256,uint256,uint256)\":{\"params\":{\"maximumRewrapInterval\":\"The longest interval of time from a rewrap time the arch will accept for a resurrection freeBond How much bond the archaeologist wants to deposit during the update call (if any)\",\"minimumDiggingFeePerSecond\":\"The archaeologist's minimum amount to earn per second for being cursed\",\"peerId\":\"The libp2p identifier for the archaeologist\"}},\"withdrawFreeBond(uint256)\":{\"params\":{\"amount\":\"The amount to withdraw\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"ArchaeologistAlreadyPublishedPrivateKey(address)\":[{\"notice\":\"Archaeologist has attempted to publish a key for a sarcophagus twice\"}],\"ArchaeologistHasBeenAccused(address,bytes32)\":[{\"notice\":\"An archaeologist that has already been successfully accused has attempted to publish their private key\"}],\"ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)\":[{\"notice\":\"Archaeologist has attempted to publish the incorrect private key for a sarcophagus\"}],\"CannotSetZeroProfileValue()\":[{\"notice\":\"Archaeologist has attempted to set a zero minimumDiggingFeePerSecond or maximumRewrapInterval\"}],\"TooEarlyForPublish(uint256,uint256)\":[{\"notice\":\"Archaeologist has attempted to publish a key before the resurrection time\"}],\"TooLateForPublish(uint256,uint256)\":[{\"notice\":\"Archaeologist has attempted to publish a key after the end of the resurrection window\"}]},\"events\":{\"PublishPrivateKey(bytes32,bytes32,address)\":{\"notice\":\"Emitted when an archaeologist successfully publishes their private key for a sarcophagus\"}},\"kind\":\"user\",\"methods\":{\"depositFreeBond(uint256)\":{\"notice\":\"Deposits an archaeologist's free bond to the contract.\"},\"publishPrivateKey(bytes32,bytes32)\":{\"notice\":\"Publishes the private key for which the archaeologist is responsible during the sarcophagus resurrection window. Pays digging fees to the archaeologist and releases their locked bond. Cannot be called on a compromised or buried sarcophagus.\"},\"registerArchaeologist(string,uint256,uint256,uint256,uint256)\":{\"notice\":\"Registers the archaeologist profile\"},\"updateArchaeologist(string,uint256,uint256,uint256,uint256)\":{\"notice\":\"Updates the archaeologist profile\"},\"withdrawFreeBond(uint256)\":{\"notice\":\"Withdraws an archaeologist's free bond from the contract.\"},\"withdrawReward()\":{\"notice\":\"Withdraws all rewards from an archaeologist's reward pool\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/ArchaeologistFacet.sol\":\"ArchaeologistFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"contracts/facets/ArchaeologistFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport {LibPrivateKeys} from \\\"../libraries/LibPrivateKeys.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\n\\ncontract ArchaeologistFacet {\\n    /// @notice Emitted when an archaeologist successfully publishes their private key for a sarcophagus\\n    /// @param sarcoId ID of sarcophagus archaeologist has published the private key on\\n    /// @param privateKey private key that has been published\\n    event PublishPrivateKey(\\n        bytes32 indexed sarcoId,\\n        bytes32 privateKey,\\n        address indexed archaeologist\\n    );\\n\\n    event DepositFreeBond(address indexed archaeologist, uint256 depositedBond);\\n\\n    event RegisterArchaeologist(\\n        address indexed archaeologist,\\n        string peerId,\\n        uint256 minimumDiggingFee,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond,\\n        uint256 maximumResurrectionTime\\n    );\\n\\n    event UpdateArchaeologist(\\n        address indexed archaeologist,\\n        string peerId,\\n        uint256 minimumDiggingFee,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond,\\n        uint256 maximumResurrectionTime\\n    );\\n\\n    event WithdrawFreeBond(address indexed archaeologist, uint256 withdrawnBond);\\n\\n    event WithdrawReward(address indexed archaeologist, uint256 withdrawnReward);\\n\\n    /// @notice An archaeologist that has already been successfully accused has attempted to publish their private key\\n    /// @param archaeologistAddress Address of accused archaeologist who is attempting to publish their private key\\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a key on\\n    error ArchaeologistHasBeenAccused(address archaeologistAddress, bytes32 sarcoId);\\n\\n    /// @notice Archaeologist has attempted to publish a key before the resurrection time\\n    /// @param currentTime Timestamp of the failed publish attempt\\n    /// @param resurrectionTime Time after which the sarcophagus can be resurrected\\n    error TooEarlyForPublish(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Archaeologist has attempted to publish a key after the end of the resurrection window\\n    /// @param currentTime Timestamp of the failed publish attempt\\n    /// @param publishDeadline Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)\\n    error TooLateForPublish(uint256 currentTime, uint256 publishDeadline);\\n\\n    /// @notice Archaeologist has attempted to publish a key for a sarcophagus twice\\n    /// @param archaeologistAddress address of publishing archaeologist\\n    error ArchaeologistAlreadyPublishedPrivateKey(address archaeologistAddress);\\n\\n    /// @notice Archaeologist has attempted to set a zero minimumDiggingFeePerSecond or maximumRewrapInterval\\n    error CannotSetZeroProfileValue();\\n\\n    /// @notice Archaeologist has attempted to publish the incorrect private key for a sarcophagus\\n    /// @param archaeologistAddress address of publishing archaeologist\\n    /// @param publicKey publicKey stored for archaeologist on the sarcophagus\\n    /// @param privateKey privateKey the archaeologist has attempted to publish\\n    error ArchaeologistPublishedIncorrectPrivateKey(\\n        address archaeologistAddress,\\n        bytes publicKey,\\n        bytes32 privateKey\\n    );\\n\\n    /// @notice Registers the archaeologist profile\\n    /// @param peerId The libp2p identifier for the archaeologist\\n    /// @param minimumDiggingFeePerSecond The archaeologist's minimum amount to earn per second for being cursed\\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\\n    /// for a resurrection\\n    /// @param freeBond How much bond the archaeologist wants to deposit during the register call (if any)\\n    /// @param maximumResurrectionTime The time beyond which the archaeologist is not willing to accept new curses or rewraps\\n    function registerArchaeologist(\\n        string memory peerId,\\n        uint256 minimumDiggingFeePerSecond,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond,\\n        uint256 maximumResurrectionTime\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        // verify that the archaeologist does not already exist\\n        LibUtils.revertIfArchProfileExists(msg.sender);\\n\\n        if (maximumRewrapInterval == 0 || minimumDiggingFeePerSecond == 0) {\\n            revert CannotSetZeroProfileValue();\\n        }\\n\\n        // create a new archaeologist\\n        LibTypes.ArchaeologistProfile memory newArch = LibTypes.ArchaeologistProfile({\\n            peerId: peerId,\\n            minimumDiggingFeePerSecond: minimumDiggingFeePerSecond,\\n            maximumResurrectionTime: maximumResurrectionTime,\\n            maximumRewrapInterval: maximumRewrapInterval,\\n            freeBond: freeBond,\\n            cursedBond: 0\\n        });\\n\\n        // transfer SARCO tokens from the archaeologist to this contract, to be\\n        // used as their free bond. can be 0.\\n        if (freeBond > 0) {\\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\\n        }\\n\\n        // save the new archaeologist into relevant data structures\\n        s.archaeologistProfiles[msg.sender] = newArch;\\n        s.archaeologistProfileAddresses.push(msg.sender);\\n\\n        emit RegisterArchaeologist(\\n            msg.sender,\\n            newArch.peerId,\\n            newArch.minimumDiggingFeePerSecond,\\n            newArch.maximumRewrapInterval,\\n            newArch.freeBond,\\n            newArch.maximumResurrectionTime\\n        );\\n    }\\n\\n    /// @notice Updates the archaeologist profile\\n    /// @param peerId The libp2p identifier for the archaeologist\\n    /// @param minimumDiggingFeePerSecond The archaeologist's minimum amount to earn per second for being cursed\\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\\n    /// for a resurrection\\n    /// freeBond How much bond the archaeologist wants to deposit during the update call (if any)\\n    function updateArchaeologist(\\n        string memory peerId,\\n        uint256 minimumDiggingFeePerSecond,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond,\\n        uint256 maximumResurrectionTime\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        // verify that the archaeologist exists\\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\\n\\n        if (maximumRewrapInterval == 0 || minimumDiggingFeePerSecond == 0) {\\n            revert CannotSetZeroProfileValue();\\n        }\\n\\n        LibTypes.ArchaeologistProfile storage existingArch = s.archaeologistProfiles[msg.sender];\\n        existingArch.peerId = peerId;\\n        existingArch.minimumDiggingFeePerSecond = minimumDiggingFeePerSecond;\\n        existingArch.maximumRewrapInterval = maximumRewrapInterval;\\n        existingArch.maximumResurrectionTime = maximumResurrectionTime;\\n\\n        // transfer SARCO tokens from the archaeologist to this contract, to be\\n        // used as their free bond. can be 0.\\n        if (freeBond > 0) {\\n            s.archaeologistProfiles[msg.sender].freeBond += freeBond;\\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\\n        }\\n\\n        emit UpdateArchaeologist(\\n            msg.sender,\\n            existingArch.peerId,\\n            existingArch.minimumDiggingFeePerSecond,\\n            existingArch.maximumRewrapInterval,\\n            existingArch.freeBond,\\n            existingArch.maximumResurrectionTime\\n        );\\n    }\\n\\n    /// @notice Deposits an archaeologist's free bond to the contract.\\n    /// @param amount The amount to deposit\\n    function depositFreeBond(uint256 amount) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\\n        // Increase the archaeologist's free bond in app storage\\n        s.archaeologistProfiles[msg.sender].freeBond += amount;\\n\\n        // Transfer the amount of sarcoToken from the archaeologist to the contract\\n        s.sarcoToken.transferFrom(msg.sender, address(this), amount);\\n        // Emit an event\\n        emit DepositFreeBond(msg.sender, amount);\\n    }\\n\\n    /// @notice Withdraws an archaeologist's free bond from the contract.\\n    /// @param amount The amount to withdraw\\n    function withdrawFreeBond(uint256 amount) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\\n        // Decrease the archaeologist's free bond amount.\\n        // Reverts if there is not enough free bond on the contract.\\n        LibBonds.decreaseFreeBond(msg.sender, amount);\\n\\n        // Transfer the amount of sarcoToken to the archaeologist\\n        s.sarcoToken.transfer(msg.sender, amount);\\n\\n        // Emit an event\\n        emit WithdrawFreeBond(msg.sender, amount);\\n    }\\n\\n    /// @notice Withdraws all rewards from an archaeologist's reward pool\\n    function withdrawReward() external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        uint256 amountToWithdraw = s.archaeologistRewards[msg.sender];\\n        s.archaeologistRewards[msg.sender] = 0;\\n\\n        // Transfer the amount of sarcoToken to the archaeologist\\n        s.sarcoToken.transfer(msg.sender, amountToWithdraw);\\n\\n        emit WithdrawReward(msg.sender, amountToWithdraw);\\n    }\\n\\n    /// @notice Publishes the private key for which the archaeologist is responsible during the\\n    /// sarcophagus resurrection window.\\n    /// Pays digging fees to the archaeologist and releases their locked bond.\\n    /// Cannot be called on a compromised or buried sarcophagus.\\n    /// @param sarcoId The identifier of the sarcophagus for which the archaeologist is responsible\\n    /// @param privateKey The private key the archaeologist is publishing\\n    function publishPrivateKey(bytes32 sarcoId, bytes32 privateKey) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm current time is after resurrectionTime\\n        if (block.timestamp < sarcophagus.resurrectionTime) {\\n            revert TooEarlyForPublish(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm current time is within gracePeriod\\n        if (block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod) {\\n            revert TooLateForPublish(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\\n        }\\n\\n        // Confirm tx sender is an archaeologist on the sarcophagus\\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\\n            .sarcophagi[sarcoId]\\n            .cursedArchaeologists[msg.sender];\\n        if (cursedArchaeologist.publicKey.length == 0) {\\n            revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\\n        }\\n\\n        // Confirm archaeologist has not already leaked their private key\\n        if (cursedArchaeologist.isAccused) {\\n            revert ArchaeologistHasBeenAccused(msg.sender, sarcoId);\\n        }\\n\\n        // Confirm archaeologist has not already published their private key\\n        if (cursedArchaeologist.privateKey != 0) {\\n            revert ArchaeologistAlreadyPublishedPrivateKey(msg.sender);\\n        }\\n\\n        // Confirm that the private key being submitted matches the public key stored on the\\n        // sarcophagus for this archaeologist\\n        if (!LibPrivateKeys.isPublicKeyOfPrivateKey(privateKey, cursedArchaeologist.publicKey)) {\\n            revert ArchaeologistPublishedIncorrectPrivateKey(\\n                msg.sender,\\n                cursedArchaeologist.publicKey,\\n                privateKey\\n            );\\n        }\\n\\n        // Store the private key on cursed archaeologist\\n        cursedArchaeologist.privateKey = privateKey;\\n\\n        // Free archaeologist locked bond and transfer digging fees\\n        LibBonds.freeArchaeologist(sarcoId, msg.sender);\\n\\n        emit PublishPrivateKey(sarcoId, privateKey, msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0x59b2a848df327e6893b9cd16438f7584c53803556619e304fc60fcd4420d9679\",\"license\":\"Unlicense\"},\"contracts/facets/EmbalmerFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\n\\ncontract EmbalmerFacet {\\n    /// @notice Emitted when a sarcophagus is created\\n    /// @param sarcoId Id of the new sarcophagus\\n    /// @param name Name of the new sarcophagus\\n    /// @param resurrectionTime Resurrection time of the new sarcophagus\\n    /// @param creationTime Creation time as set during negotiation, not the same as blocktime at which event is emitted\\n    /// @param embalmer Address of embalmer\\n    /// @param recipient Address of recipient\\n    /// @param cursedArchaeologists Array of addresses of cursed archaeologists\\n    /// @param totalDiggingFees Total digging fees charged to embalmer to create the sarcophagus\\n    /// @param arweaveTxId arweave tx id for the sarcophagus\\n    event CreateSarcophagus(\\n        bytes32 indexed sarcoId,\\n        string name,\\n        uint256 resurrectionTime,\\n        uint256 creationTime,\\n        address embalmer,\\n        address recipient,\\n        address[] cursedArchaeologists,\\n        uint256 totalDiggingFees,\\n        string arweaveTxId\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is rewrapped\\n    /// @param sarcoId Id of sarcophagus that was rewrapped\\n    /// @param resurrectionTime New resurrection time for the sarcophagus\\n    /// @param totalDiggingFees Total digging fees charged to the embalmer for the rewrap\\n    /// @param rewrapSarcophagusProtocolFees Total protocol fees charged to the embalmer for the rewrap\\n    event RewrapSarcophagus(\\n        bytes32 indexed sarcoId,\\n        uint256 resurrectionTime,\\n        uint256 totalDiggingFees,\\n        uint256 rewrapSarcophagusProtocolFees\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is buried\\n    /// @param sarcoId Id of sarcophagus that was buried\\n    event BurySarcophagus(bytes32 indexed sarcoId);\\n\\n    /// @notice Parameters of a sarcophagus, supplied during sarcophagus creation\\n    struct SarcophagusParams {\\n        string name;\\n        // highest rewrap interval cursed archaeologists have agreed to accept for lifetime of sarcophagus\\n        uint256 maximumRewrapInterval;\\n        // The timestamp beyond which the sarcophagus can no longer be rewrapped\\n        uint256 maximumResurrectionTime;\\n        address recipientAddress;\\n        uint256 resurrectionTime;\\n        uint8 threshold;\\n        uint256 creationTime;\\n    }\\n\\n    /// @notice Parameters of an archaeologist's curse, supplied during sarcophagus creation\\n    struct CurseParams {\\n        bytes publicKey;\\n        address archAddress;\\n        uint256 diggingFeePerSecond;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an id that is already in use\\n    /// @param sarcoId Id that is already in use\\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with expired parameters\\n    /// @param currentTime Timestamp of the failed create attempt\\n    /// @param creationTime Time when the sarcophagus parameters were created\\n    /// @param creationDeadline Deadline for creation of a sarcophagus with the supplied parameters\\n    error SarcophagusParametersExpired(\\n        uint256 currentTime,\\n        uint256 creationTime,\\n        uint256 creationDeadline\\n    );\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with no archaeologists\\n    error NoArchaeologistsProvided();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a shamir secret sharing threshold of 0\\n    error ThresholdCannotBeZero();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with more required archaeologists than total archaeologists\\n    error ThresholdGreaterThanTotalNumberOfArchaeologists(\\n        uint8 threshold,\\n        uint256 totalNumberOfArchaeologists\\n    );\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an archaeologist list that contains the same archaeologist more than once\\n    error ArchaeologistListContainsDuplicate(address archaeologistAddress);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that has already passed\\n    /// @param currentTime Timestamp of the failed rewrap attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a public key that has already been assigned to another sarcophagus\\n    /// @param publicKey the duplicated public key\\n    error DuplicatePublicKey(bytes publicKey);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that exceeds the maximum rewrap interval\\n    /// @param resurrectionTime Resurrection timestamp which is too far in the future\\n    /// @param sarcophagusMaximumRewrapInterval Maximum rewrap interval set for the sarcophagus\\n    /// @param maximumPermissibleResurrectionTime Resurrection timestamp which is too far in the future\\n    error ResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    /// @notice Emitted when the resurrection time defined during sarcohpagus creation or rewrap goes past the max resurrection time\\n    /// @param resurrectionTime The resurrection time defined during the sarcophagus creation or rewrap\\n    /// @param maxResurrectionTime The maximum allowed resurrection time\\n    error ResurrectionTimePastMaxResurrectionTime(\\n        uint256 resurrectionTime,\\n        uint256 maxResurrectionTime\\n    );\\n\\n    error NewResurrectionTimeInPast(uint256 currentTime, uint256 newResurrectionTime);\\n\\n    error NewResurrectionTimeIsZero();\\n\\n    error NewResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    error ResurrectionTimeTooFarPastPreviousResurrectionTime(\\n        uint256 resurrectionTime,\\n        uint256 previousResurrectionTime\\n    );\\n\\n    /// @notice Creates a sarcophagus with the supplied parameters and locks\\n    /// a portion of each archaeologist's freeBond equal to the digging fees calculated for the duration\\n    /// of the sarcophagus until its resurrection time.\\n    ///\\n    /// Verifies that each supplied archaeologist has signed off on the sarcophagus negotiation parameters:\\n    ///    - `publicKey` that matches the private key the archaeologist is responsible for\\n    ///    - `maximumRewrapInterval` to be enforced for the lifetime of the sarcophagus. No new resurrection time for future rewraps may exceed this interval from time of rewrap.\\n    ///    - `creationTime` of sarcophagus\\n    ///    - `diggingFeePerSecond` agreed to be paid to the archaeologist during the lifetime of the sarcophagus. Constant.\\n    ///\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param sarcophagusParams params to set on sarcophagus being created\\n    /// @param selectedArchaeologists the archaeologists the embalmer has selected to curse\\n    /// @param arweaveTxId id of tx storing the sarcophagus payload on arweave\\n    function createSarcophagus(\\n        bytes32 sarcoId,\\n        SarcophagusParams calldata sarcophagusParams,\\n        CurseParams[] calldata selectedArchaeologists,\\n        string calldata arweaveTxId\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Confirm that sarcophagus with supplied id doesn't already exist\\n        if (s.sarcophagi[sarcoId].resurrectionTime > 0) {\\n            revert SarcophagusAlreadyExists(sarcoId);\\n        }\\n\\n        // Ensure too much time hasn't passed since the sarcophagus `creationTime` that has been signed\\n        // off by its cursed archaeologists.\\n        if (block.timestamp > sarcophagusParams.creationTime + s.expirationThreshold) {\\n            revert SarcophagusParametersExpired(\\n                block.timestamp,\\n                sarcophagusParams.creationTime,\\n                sarcophagusParams.creationTime + s.expirationThreshold\\n            );\\n        }\\n\\n        // Confirm that resurrection time is in the future\\n        if (block.timestamp >= sarcophagusParams.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagusParams.resurrectionTime);\\n        }\\n\\n        // Confirm that resurrection or rewrap will occur before the maximumRewrapInterval elapses\\n        if (\\n            block.timestamp + sarcophagusParams.maximumRewrapInterval <\\n            sarcophagusParams.resurrectionTime\\n        ) {\\n            revert ResurrectionTimeTooFarInFuture(\\n                sarcophagusParams.resurrectionTime,\\n                sarcophagusParams.maximumRewrapInterval,\\n                block.timestamp + sarcophagusParams.maximumRewrapInterval\\n            );\\n        }\\n\\n        // Confirm that the resurrection time is less than the max resurrection time\\n        if (sarcophagusParams.resurrectionTime > sarcophagusParams.maximumResurrectionTime) {\\n            revert ResurrectionTimePastMaxResurrectionTime(\\n                sarcophagusParams.resurrectionTime,\\n                sarcophagusParams.maximumResurrectionTime\\n            );\\n        }\\n\\n        // Validate archaeologist and threshold lengths\\n        if (selectedArchaeologists.length == 0) {\\n            revert NoArchaeologistsProvided();\\n        }\\n\\n        if (sarcophagusParams.threshold == 0) {\\n            revert ThresholdCannotBeZero();\\n        }\\n\\n        // Ensure that k <= n in the effective k-of-n shamir secret sharing scheme\\n        // used to distribute keyshares among archaeologists\\n        if (sarcophagusParams.threshold > selectedArchaeologists.length) {\\n            revert ThresholdGreaterThanTotalNumberOfArchaeologists(\\n                sarcophagusParams.threshold,\\n                selectedArchaeologists.length\\n            );\\n        }\\n\\n        // create the sarcophagus\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n        sarcophagus.name = sarcophagusParams.name;\\n        sarcophagus.threshold = sarcophagusParams.threshold;\\n        sarcophagus.resurrectionTime = sarcophagusParams.resurrectionTime;\\n        sarcophagus.previousRewrapTime = sarcophagusParams.creationTime;\\n        sarcophagus.maximumRewrapInterval = sarcophagusParams.maximumRewrapInterval;\\n        sarcophagus.maximumResurrectionTime = sarcophagusParams.maximumResurrectionTime;\\n        sarcophagus.arweaveTxId = arweaveTxId;\\n        sarcophagus.embalmerAddress = msg.sender;\\n        sarcophagus.recipientAddress = sarcophagusParams.recipientAddress;\\n        sarcophagus.cursedArchaeologistAddresses = new address[](selectedArchaeologists.length);\\n        sarcophagus.cursedBondPercentage = s.cursedBondPercentage;\\n\\n        // track total digging fees due upon creation of sarcophagus\\n        uint256 totalDiggingFees = 0;\\n\\n        for (uint256 i = 0; i < selectedArchaeologists.length; i++) {\\n            LibUtils.revertIfArchProfileDoesNotExist(selectedArchaeologists[i].archAddress);\\n\\n            // Confirm archaeologist isn't already cursed on this sarcophagus (no duplicates)\\n            if (\\n                sarcophagus\\n                    .cursedArchaeologists[selectedArchaeologists[i].archAddress]\\n                    .publicKey\\n                    .length != 0\\n            ) {\\n                revert ArchaeologistListContainsDuplicate(selectedArchaeologists[i].archAddress);\\n            }\\n\\n            // Confirm archaeologist is not re-using a key pair\\n            if (\\n                s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] != address(0)\\n            ) {\\n                revert DuplicatePublicKey(selectedArchaeologists[i].publicKey);\\n            }\\n\\n            LibUtils.verifyArchaeologistSignature(\\n                sarcophagusParams.maximumRewrapInterval,\\n                sarcophagusParams.maximumResurrectionTime,\\n                sarcophagusParams.creationTime,\\n                selectedArchaeologists[i]\\n            );\\n\\n            // Curse the archaeologist on this sarcophagus\\n            uint256 diggingFeesDue = LibBonds.curseArchaeologist(\\n                sarcoId,\\n                selectedArchaeologists[i],\\n                i\\n            );\\n\\n            totalDiggingFees += diggingFeesDue;\\n\\n            // \\\"Consume\\\" this public key so it cannot be reused in the future\\n            s.publicKeyToArchaeologistAddress[\\n                selectedArchaeologists[i].publicKey\\n            ] = selectedArchaeologists[i].archAddress;\\n        }\\n\\n        // Add this sarcophagus id to the embalmer's record\\n        s.embalmerSarcophagi[msg.sender].push(sarcoId);\\n\\n        // Add this sarcophagus id to the recipient's record\\n        s.recipientSarcophagi[sarcophagusParams.recipientAddress].push(sarcoId);\\n\\n        // Transfer totalDiggingFees and the protocolFees in SARCO from embalmer to this contract\\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n        s.totalProtocolFees += protocolFees;\\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\\n\\n        emit CreateSarcophagus(\\n            sarcoId,\\n            sarcophagusParams.name,\\n            sarcophagusParams.resurrectionTime,\\n            sarcophagusParams.creationTime,\\n            msg.sender,\\n            sarcophagusParams.recipientAddress,\\n            sarcophagus.cursedArchaeologistAddresses,\\n            totalDiggingFees,\\n            arweaveTxId\\n        );\\n    }\\n\\n    /// @notice Updates the resurrectionTime on a sarcophagus. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param resurrectionTime the new resurrection time\\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        if (resurrectionTime == 0) {\\n            revert NewResurrectionTimeIsZero();\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n\\n        // Confirm resurrection time has not yet passed\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time is in future\\n        if (block.timestamp >= resurrectionTime) {\\n            revert NewResurrectionTimeInPast(block.timestamp, resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time doesn't exceed sarcophagus's maximumRewrapInterval\\n        if (block.timestamp + sarcophagus.maximumRewrapInterval < resurrectionTime) {\\n            revert NewResurrectionTimeTooFarInFuture(\\n                resurrectionTime,\\n                sarcophagus.maximumRewrapInterval,\\n                block.timestamp + sarcophagus.maximumRewrapInterval\\n            );\\n        }\\n\\n        // Confirm that the new resurrection time doesn't exceed the maximumResurrectionTime\\n        if (sarcophagus.maximumResurrectionTime < resurrectionTime) {\\n            revert ResurrectionTimePastMaxResurrectionTime(\\n                resurrectionTime,\\n                sarcophagus.maximumResurrectionTime\\n            );\\n        }\\n\\n        // track total digging fees to be paid by embalmer across all archaeologists on the sarcophagus\\n        uint256 totalDiggingFees = 0;\\n\\n        // pay digging fee to each cursed archaeologist on the sarcophagus that has not been accused\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        uint256 cursedBondPercentage = sarcophagus.cursedBondPercentage;\\n\\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n\\n            if (!cursedArchaeologist.isAccused) {\\n                uint256 prevDiggingFees = cursedArchaeologist.diggingFeePerSecond *\\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n                uint256 newDiggingFees = cursedArchaeologist.diggingFeePerSecond *\\n                    (resurrectionTime - block.timestamp);\\n\\n                // If the new digging fees are greater than the previous digging fees, we need to\\n                // increase the archaeologist's locked bond\\n                if (newDiggingFees > prevDiggingFees) {\\n                    uint256 cursedBondIncrease = ((newDiggingFees - prevDiggingFees) *\\n                        cursedBondPercentage) / 100;\\n\\n                    // If the previous cycle's rewards can't cover the cursed bond increase, revert\\n                    if (cursedBondIncrease > prevDiggingFees) {\\n                        revert ResurrectionTimeTooFarPastPreviousResurrectionTime(\\n                            resurrectionTime,\\n                            sarcophagus.resurrectionTime\\n                        );\\n                    }\\n\\n                    // Increase the archaeologist's cursed bond\\n                    s\\n                        .archaeologistProfiles[archaeologistAddresses[i]]\\n                        .cursedBond += cursedBondIncrease;\\n\\n                    // Rewards are now previous digging fees - difference\\n                    s.archaeologistRewards[archaeologistAddresses[i]] +=\\n                        prevDiggingFees -\\n                        cursedBondIncrease;\\n                } else if (newDiggingFees < prevDiggingFees) {\\n                    uint256 cursedBondDecrease = ((prevDiggingFees - newDiggingFees) *\\n                        cursedBondPercentage) / 100;\\n\\n                    // Decrease archaeologist's cursed bond by the difference\\n                    s\\n                        .archaeologistProfiles[archaeologistAddresses[i]]\\n                        .cursedBond -= cursedBondDecrease;\\n\\n                    // Increase archaeologist's free bond by the difference\\n                    s\\n                        .archaeologistProfiles[archaeologistAddresses[i]]\\n                        .freeBond += cursedBondDecrease;\\n\\n                    // Rewards are equal to the previous digging fees\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\\n                } else {\\n                    // Rewards are equal to the previous digging fees\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\\n                }\\n\\n                // Add digging fees due for the new interval\\n                totalDiggingFees += newDiggingFees;\\n            }\\n        }\\n\\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n\\n        // Add the protocol fee to the total protocol fees in storage\\n        s.totalProtocolFees += protocolFees;\\n\\n        // Update the sarcophagus resurrectionTime and previousRewrapTime\\n        sarcophagus.resurrectionTime = resurrectionTime;\\n        sarcophagus.previousRewrapTime = block.timestamp;\\n\\n        // Transfer the new digging fees and protocol fees from embalmer to contract\\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\\n\\n        emit RewrapSarcophagus(sarcoId, resurrectionTime, totalDiggingFees, protocolFees);\\n    }\\n\\n    /// @notice Terminates a sarcophagus by setting its resurrection time to infinity and returning locked\\n    /// bonds to all innocent cursed archaeologists. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    function burySarcophagus(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n        // Confirm that the current resurrection time is in the future\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // for each archaeologist on the sarcophagus, unlock bond and pay digging fees\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n\\n            // if the archaeologist hasn't been accused transfer them their digging fees and return their locked bond\\n            if (!cursedArchaeologist.isAccused) {\\n                LibBonds.freeArchaeologist(sarcoId, archaeologistAddresses[i]);\\n            }\\n        }\\n\\n        // Set resurrection time to infinity\\n        sarcophagus.resurrectionTime = 2 ** 256 - 1;\\n\\n        emit BurySarcophagus(sarcoId);\\n    }\\n}\\n\",\"keccak256\":\"0xded9cc3f16abd24a19c0de22d20fd4827706e914a0e2de2e45e565c770a46556\",\"license\":\"Unlicense\"},\"contracts/facets/ThirdPartyFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport {LibDiamond} from \\\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\ncontract ThirdPartyFacet {\\n    event AccuseArchaeologist(\\n        bytes32 indexed sarcoId,\\n        address indexed accuser,\\n        uint256 totalSlashedBondDistributed,\\n        uint256 totalDiggingFeesDistributed,\\n        address[] indexed accusedArchAddresses\\n    );\\n\\n    event Clean(bytes32 indexed sarcoId, address indexed cleaner);\\n\\n    /// @notice Clean has been called on a sarcophagus that has already been cleaned\\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a private key on\\n    error SarcophagusAlreadyCleaned(bytes32 sarcoId);\\n\\n    /// @notice Clean has been called before the deadline for archaeologists to publish private keys has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param publishDeadline Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\\n    error TooEarlyForClean(uint256 currentTime, uint256 publishDeadline);\\n\\n    /// @notice Clean has been called by someone other than the admin or embalmer of the sarcophagus\\n    /// @param senderAddress Address of sender\\n    error SenderNotEmbalmerOrAdmin(address senderAddress);\\n\\n    /// @notice Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error EmbalmerClaimWindowPassed(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error TooEarlyForAdminClean(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Emitted when a third party attempts to accuse an archaeologist on a sarcophagus where the resurrection time has already passed\\n    /// @param currentTime Timestamp of the failed accuse attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when accuse is called with an unequal numbers of public keys and signatures\\n    /// @param signatures the number of signatures passed into the accuse call\\n    /// @param publicKeys the number of public keys passed into the accuse call\\n    error DifferentNumberOfSignaturesAndPublicKeys(uint256 signatures, uint256 publicKeys);\\n\\n    /// @notice Emitted when accuse is called with an invalid signature for the supplied sarcoId, paymentAddress, and publicKey\\n    /// @param sarcoId that should have been signed\\n    /// @param paymentAddress payment address that should have been signed\\n    /// @param publicKey publicKey that should be derived from signing key\\n    /// @param signature invalid signature\\n    error InvalidAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes publicKey,\\n        LibTypes.Signature signature\\n    );\\n\\n    /// @notice If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod,\\n    /// their locked bonds and diggingFees may be claimed by either the embalmer or the admin\\n    /// embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will\\n    /// be able to claim remaining locked bond and diggingFees\\n    /// @param sarcoId The identifier of the sarcophagus to clean\\n    function clean(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer or admin\\n        if (msg.sender != sarcophagus.embalmerAddress && msg.sender != LibDiamond.contractOwner()) {\\n            revert SenderNotEmbalmerOrAdmin(msg.sender);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not already been cleaned\\n        if (sarcophagus.isCleaned) {\\n            revert SarcophagusAlreadyCleaned(sarcoId);\\n        }\\n\\n        // Confirm that the resurrectionTime + gracePeriod have passed\\n        if (block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod) {\\n            revert TooEarlyForClean(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\\n        }\\n\\n        // if sender is embalmer, confirm current time is within embalmerClaimWindow\\n        if (\\n            msg.sender == sarcophagus.embalmerAddress &&\\n            block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert EmbalmerClaimWindowPassed(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // if sender is admin, confirm embalmerClaimWindow has passed\\n        if (\\n            msg.sender == LibDiamond.contractOwner() &&\\n            block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert TooEarlyForAdminClean(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // sum of locked bonds and digging fees for all archaeologists that have failed to publish private keys before publish deadline and have not been accused\\n        uint256 totalDiggingFeesAndLockedBonds = 0;\\n\\n        for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]];\\n\\n            // Punish archaeologists that failed to publish their private key in time\\n            if (!cursedArchaeologist.isAccused && cursedArchaeologist.privateKey == 0) {\\n                uint256 diggingFeesDue = cursedArchaeologist.diggingFeePerSecond *\\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n                uint256 cursedBondDue = (diggingFeesDue * sarcophagus.cursedBondPercentage) / 100;\\n                totalDiggingFeesAndLockedBonds += diggingFeesDue + cursedBondDue;\\n\\n                // slash the archaeologist's locked bond for the sarcophagus\\n                LibBonds.decreaseCursedBond(\\n                    sarcophagus.cursedArchaeologistAddresses[i],\\n                    cursedBondDue\\n                );\\n            }\\n        }\\n\\n        // Transfer total slashed locked bonds plus digging fees to the embalmer if they are the caller, otherwise add\\n        // this to the contract's protocol fees\\n        if (msg.sender == sarcophagus.embalmerAddress) {\\n            s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFeesAndLockedBonds);\\n        } else {\\n            s.totalProtocolFees += totalDiggingFeesAndLockedBonds;\\n        }\\n\\n        sarcophagus.isCleaned = true;\\n        emit Clean(sarcoId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id\\n     * and payment address generated with the leaked private keys\\n     * If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be\\n     * split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer\\n     *\\n     * If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus\\n     * state will be updated to Accused and bonds for all remaining unaccused archaeologists will be\\n     * returned\\n     *\\n     * @param sarcoId The identifier of the sarcophagus having leaked private keys\\n     * @param publicKeys an array of public keys corresponding to leaked private keys - order must match order of signatures\\n     * @param signatures an array of signatures of the sarcoId and payment address signed by the leaked private keys - order must match order of publicKeys\\n     * @param paymentAddress the address to which rewards should be sent if successful\\n     */\\n    function accuse(\\n        bytes32 sarcoId,\\n        bytes[] calldata publicKeys,\\n        LibTypes.Signature[] calldata signatures,\\n        address paymentAddress\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // verify that current time is not past resurrection time\\n        if (block.timestamp > sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        if (signatures.length != publicKeys.length) {\\n            revert DifferentNumberOfSignaturesAndPublicKeys(signatures.length, publicKeys.length);\\n        }\\n\\n        address[] memory accusedArchAddresses = new address[](signatures.length);\\n\\n        // track the combined locked bond across all archaeologists being accused in this call\\n        uint256 totalCursedBond = 0;\\n        uint256 accusalCount = 0;\\n        for (uint256 i = 0; i < signatures.length; i++) {\\n            if (\\n                !LibUtils.verifyAccusalSignature(\\n                    sarcoId,\\n                    paymentAddress,\\n                    publicKeys[i],\\n                    signatures[i]\\n                )\\n            ) {\\n                revert InvalidAccusalSignature(\\n                    sarcoId,\\n                    paymentAddress,\\n                    publicKeys[i],\\n                    signatures[i]\\n                );\\n            }\\n\\n            // look up the archaeologist responsible for the publicKey\\n            address accusedArchaeologistAddress = s.publicKeyToArchaeologistAddress[publicKeys[i]];\\n            LibTypes.CursedArchaeologist storage accusedArchaeologist = sarcophagus\\n                .cursedArchaeologists[accusedArchaeologistAddress];\\n\\n            // verify the accused archaeologist is cursed on the sarcophagus\\n            if (accusedArchaeologist.publicKey.length == 0) {\\n                revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\\n            }\\n\\n            // if the archaeologist has already been accused on this sarcophagus break without taking action\\n            if (accusedArchaeologist.isAccused) {\\n                break;\\n            }\\n\\n            // mark the archaeologist on the sarcophagus as having been accused\\n            accusedArchaeologist.isAccused = true;\\n            accusedArchAddresses[accusalCount++] = accusedArchaeologistAddress;\\n\\n            uint256 cursedBondDue = ((accusedArchaeologist.diggingFeePerSecond *\\n                (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime)) *\\n                sarcophagus.cursedBondPercentage) / 100;\\n\\n            totalCursedBond += cursedBondDue;\\n\\n            // Slash the offending archaeologists bond\\n            LibBonds.decreaseCursedBond(accusedArchaeologistAddress, cursedBondDue);\\n        }\\n\\n        // if none of the accusals were valid because the archaeologists have all already been accused, return without taking action\\n        if (accusalCount == 0) {\\n            return;\\n        }\\n\\n        // the sarcophagus is compromised if the current call has successfully accused the sss threshold of archaeologists\\n        if (accusalCount >= sarcophagus.threshold) {\\n            sarcophagus.isCompromised = true;\\n        } else {\\n            // if the current call hasn't resulted in at least sss threshold archaeologists being accused\\n            // check if total number of historical accusals on sarcophagus is greater than threshold\\n            uint256 totalAccusals = 0;\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                if (\\n                    sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    totalAccusals++;\\n                }\\n            }\\n            // the sarcophagus is compromised if k or more archaeologists have been accused over the lifetime of the sarcophagus\\n            if (totalAccusals >= sarcophagus.threshold) {\\n                sarcophagus.isCompromised = true;\\n            }\\n        }\\n\\n        // if k or more archaeologists have been accused over the lifetime of the sarcophagus, funds should\\n        // be returned to the remaining well behaved archaeologists\\n        if (sarcophagus.isCompromised) {\\n            // iterate through all archaeologist addresses on the sarcophagus\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                // if the archaeologist has never been accused, release their locked bond back to them\\n                if (\\n                    !sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    LibBonds.freeArchaeologist(\\n                        sarcoId,\\n                        sarcophagus.cursedArchaeologistAddresses[i]\\n                    );\\n                }\\n            }\\n        }\\n\\n        uint256 halfTotalCursedBond = totalCursedBond / 2;\\n        uint256 totalDiggingFees = totalCursedBond / (sarcophagus.cursedBondPercentage / 100);\\n        // transfer the cursed half, plus the current digging fees, to the embalmer\\n        s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFees + halfTotalCursedBond);\\n\\n        // transfer the other half of the cursed bond to the transaction caller\\n        s.sarcoToken.transfer(paymentAddress, halfTotalCursedBond);\\n\\n        emit AccuseArchaeologist(\\n            sarcoId,\\n            msg.sender,\\n            totalCursedBond,\\n            totalDiggingFees,\\n            accusedArchAddresses\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x1f62b0e9efa8f03c5b25e006f0586ac422fa411fc6e30255c6712251abc87215\",\"license\":\"Unlicense\"},\"contracts/libraries/LibBonds.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"./LibErrors.sol\\\";\\n\\nimport \\\"../facets/EmbalmerFacet.sol\\\";\\n\\nlibrary LibBonds {\\n    /// @notice Decreases the amount stored in the freeBond mapping for an\\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\\n    /// the amount.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being decreased\\n    /// @param amount The amount to decrease the free bond by\\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current free bond\\n        if (amount > s.archaeologistProfiles[archaeologist].freeBond) {\\n            revert LibErrors.NotEnoughFreeBond(\\n                s.archaeologistProfiles[archaeologist].freeBond,\\n                amount\\n            );\\n        }\\n\\n        // Decrease the free bond amount\\n        s.archaeologistProfiles[archaeologist].freeBond -= amount;\\n    }\\n\\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\\n    /// archaeologist, without respectively increasing their free bond.\\n    /// @param archaeologist The address of the archaeologist\\n    /// @param amount The amount to slash\\n    function decreaseCursedBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current cursed bond\\n        if (amount > s.archaeologistProfiles[archaeologist].cursedBond) {\\n            revert LibErrors.NotEnoughCursedBond(\\n                s.archaeologistProfiles[archaeologist].cursedBond,\\n                amount\\n            );\\n        }\\n\\n        s.archaeologistProfiles[archaeologist].cursedBond -= amount;\\n    }\\n\\n    /// @notice Bonds the archaeologist to a sarcophagus.\\n    /// This does the following:\\n    ///   - adds the archaeologist's curse params and address to the sarcophagus\\n    ///   - calculates digging fees to be locked and later paid to archaeologist\\n    ///   - locks this amount from archaeologist's free bond; increases cursedBond by same\\n    ///   - Adds the sarcophagus' id to the archaeologist's record of bonded sarcophagi\\n    /// @param sarcoId Id of the sarcophagus with which to curse the archaeologist\\n    /// @param archaeologist The archaologist to curse, with associated parameters of the curse\\n    ///\\n    /// @return the amount of digging fees due the embalmer for this curse\\n    function curseArchaeologist(\\n        bytes32 sarcoId,\\n        EmbalmerFacet.CurseParams calldata archaeologist,\\n        uint256 index\\n    ) internal returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        sarcophagus.cursedArchaeologists[archaeologist.archAddress] = LibTypes.CursedArchaeologist({\\n            publicKey: archaeologist.publicKey,\\n            privateKey: 0,\\n            isAccused: false,\\n            diggingFeePerSecond: archaeologist.diggingFeePerSecond\\n        });\\n        sarcophagus.cursedArchaeologistAddresses[index] = archaeologist.archAddress;\\n\\n        // Calculate digging fees due for this time period (creationTime/previousRewrapTime -> resurrectionTime)\\n        uint256 diggingFeesDue = archaeologist.diggingFeePerSecond *\\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n        // Use cursed bond percentage to determine how much bond to lock up\\n        uint256 bondToCurse = (diggingFeesDue * s.cursedBondPercentage) / 100;\\n\\n        decreaseFreeBond(archaeologist.archAddress, bondToCurse);\\n        s.archaeologistProfiles[archaeologist.archAddress].cursedBond += bondToCurse;\\n\\n        s.archaeologistSarcophagi[archaeologist.archAddress].push(sarcoId);\\n\\n        return diggingFeesDue;\\n    }\\n\\n    /// @notice Calculates and unlocks an archaeologist's cursed bond. Pays due digging fees to the archaeologist.\\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\\n    /// @param archaeologistAddress the address of the archaeologist to free\\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\\n            .sarcophagi[sarcoId]\\n            .cursedArchaeologists[archaeologistAddress];\\n\\n        uint256 diggingFeeAmount = cursedArchaeologist.diggingFeePerSecond *\\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n        uint256 cursedBondAmount = diggingFeeAmount * sarcophagus.cursedBondPercentage / 100;\\n\\n        decreaseCursedBond(archaeologistAddress, cursedBondAmount);\\n        s.archaeologistProfiles[archaeologistAddress].freeBond += cursedBondAmount;\\n        s.archaeologistRewards[archaeologistAddress] += diggingFeeAmount;\\n    }\\n}\\n\",\"keccak256\":\"0xb5473904e43e2e8ef1e4dec6f2665ce1820ee9ae672d17a32b30ab676224822f\",\"license\":\"Unlicense\"},\"contracts/libraries/LibErrors.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title A collection of Errors\\n * @notice This library defines all of the Errors that the Sarcophagus system\\n * uses.\\n */\\nlibrary LibErrors {\\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\\n\\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\\n\\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\\n\\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\\n\\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\\n\\n    error SarcophagusInactive(bytes32 sarcoId);\\n\\n    error SarcophagusCompromised(bytes32 sarcoId);\\n\\n    error SenderNotEmbalmer(address sender, address embalmer);\\n\\n    error InvalidSignature(\\n        // address recovered from signature via ecrecover\\n        address recoveredAddress,\\n        // address we expected to have signed the data\\n        address expectedAddress\\n    );\\n}\\n\",\"keccak256\":\"0xe2e2e99c7e608571b8d072ceacc037b744ca637ad66633af1c2f10e935eb8567\",\"license\":\"Unlicense\"},\"contracts/libraries/LibPrivateKeys.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n\\n/**\\n * @title Private key verification\\n * @notice Implements a private key -> public key checking function\\n * @dev modified from https://github.com/1Address/ecsol, removes extra code\\n * which isn't necessary for our Sarcophagus implementation\\n */\\nlibrary LibPrivateKeys {\\n    /**\\n     * @notice Given a private key and a public key, determines if that public\\n     * key was derived from the private key\\n     * @dev based on https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n     * @param privKey an secp256k1 private key\\n     * @param pubKey an uncompressed 65 byte secp256k1 public key\\n     * @return bool indicating whether the public key is derived from the\\n     * private key\\n     */\\n    function isPublicKeyOfPrivateKey(bytes32 privKey, bytes storage pubKey) internal view returns (bool) {\\n        // removes the 0x04 prefix from an uncompressed public key\\n        bytes memory truncatedPublicKey = new bytes(pubKey.length-1);\\n        for (uint256 i = 1; i < pubKey.length; i++) {\\n            truncatedPublicKey[i-1] = pubKey[i];\\n        }\\n\\n        // generator point coordinates and order of secp256k1\\n        uint256 gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\\n        uint256 gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\\n        uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\\n\\n        address signer = ecrecover(\\n            0,\\n            gy % 2 != 0 ? 28 : 27,\\n            bytes32(gx),\\n            bytes32(mulmod(uint256(privKey), gx, m))\\n        );\\n\\n        address xyAddress = address(\\n            uint160(uint256(keccak256(truncatedPublicKey)) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        );\\n        return xyAddress == signer;\\n    }\\n}\\n\",\"keccak256\":\"0xd09b1a4699f04a34db00d8476900583681e7e714272f93b555873708a29a5416\",\"license\":\"MIT\"},\"contracts/libraries/LibTypes.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title Types shared across facets for the Sarcophagus diamond\\n */\\nlibrary LibTypes {\\n    struct Sarcophagus {\\n        // Also used for existence checks -- does not exist if 0\\n        uint256 resurrectionTime;\\n        uint256 previousRewrapTime;\\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\\n        bool isCompromised;\\n        bool isCleaned;\\n        uint8 threshold;\\n        string name;\\n        uint256 maximumRewrapInterval;\\n        uint256 maximumResurrectionTime;\\n        string arweaveTxId;\\n        address embalmerAddress;\\n        address recipientAddress;\\n        address[] cursedArchaeologistAddresses;\\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\\n        uint256 cursedBondPercentage;\\n    }\\n\\n    struct CursedArchaeologist {\\n        uint256 diggingFeePerSecond;\\n        // Also used for publish checks -- has not published if 0\\n        bytes32 privateKey;\\n        // Also used for curse checks -- is not bonded if length is 0\\n        bytes publicKey;\\n        bool isAccused;\\n    }\\n\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    struct ArchaeologistProfile {\\n        // Also used for existence checks -- does not exist if 0\\n        uint256 maximumRewrapInterval;\\n        uint256 maximumResurrectionTime;\\n        string peerId;\\n        uint256 minimumDiggingFeePerSecond;\\n        uint256 freeBond;\\n        uint256 cursedBond;\\n    }\\n}\\n\",\"keccak256\":\"0xb6ded0e9a252560ab14a589c47df996bcf1f0b9cd4910aa1bf0da6fd01c99232\",\"license\":\"Unlicense\"},\"contracts/libraries/LibUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport \\\"../facets/ThirdPartyFacet.sol\\\";\\nimport \\\"./LibTypes.sol\\\";\\nimport \\\"../facets/EmbalmerFacet.sol\\\";\\n\\n/**\\n * @title Utility functions used within the Sarcophagus system\\n * @notice This library implements various functions that are used throughout\\n * Sarcophagus, mainly to DRY up the codebase\\n * @dev these functions are all stateless, public, pure/view\\n */\\nlibrary LibUtils {\\n    /**\\n     * @notice The archaeologist needs to sign off on two pieces of data\\n     * to guarantee their unrwap will be successful\\n     *\\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\\n     * @param curseParams parameters of curse signed by archaeologist\\n     */\\n    function verifyArchaeologistSignature(\\n        uint256 agreedMaximumRewrapInterval,\\n        uint256 maximumResurrectionTime,\\n        uint256 timestamp,\\n        EmbalmerFacet.CurseParams calldata curseParams\\n    ) internal pure {\\n        // Hash the hash of the data payload\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encode(\\n                        curseParams.publicKey,\\n                        agreedMaximumRewrapInterval,\\n                        maximumResurrectionTime,\\n                        curseParams.diggingFeePerSecond,\\n                        timestamp\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Generate the address from the signature.\\n        // ecrecover should always return a valid address.\\n        address recoveredAddress = ecrecover(\\n            messageHash,\\n            curseParams.v,\\n            curseParams.r,\\n            curseParams.s\\n        );\\n\\n        if (recoveredAddress != curseParams.archAddress) {\\n            revert LibErrors.InvalidSignature(recoveredAddress, curseParams.archAddress);\\n        }\\n    }\\n\\n    /// @notice Verifies that a signature and public key were created from the same private key\\n    /// @param sarcoId the sarcoId that was signed\\n    /// @param paymentAddress the payment address that was signed\\n    /// @param publicKey an uncompressed 65 byte secp256k1 public key\\n    /// @param signature signature on the sarco id and payment address\\n    /// @return true if the signature was signed by the private key corresponding to the supplied public key\\n    function verifyAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes calldata publicKey,\\n        LibTypes.Signature calldata signature\\n    ) internal pure returns (bool) {\\n        // removes the 0x04 prefix from an uncompressed public key\\n        bytes memory truncatedPublicKey = new bytes(publicKey.length - 1);\\n        for (uint256 i = 1; i < publicKey.length; i++) {\\n            truncatedPublicKey[i - 1] = publicKey[i];\\n        }\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(abi.encode(sarcoId, paymentAddress))\\n            )\\n        );\\n        // Use ecrecover to get the address that signed the message\\n        address signingAddress = ecrecover(messageHash, signature.v, signature.r, signature.s);\\n\\n        address publicKeyAddress = address(\\n            uint160(\\n                uint256(keccak256(truncatedPublicKey)) &\\n                    0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n            )\\n        );\\n\\n        return signingAddress == publicKeyAddress;\\n    }\\n\\n    /// @notice Checks if an archaeologist profile exists and\\n    /// reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check existence of\\n    function revertIfArchProfileExists(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval != 0) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Checks if an archaeologist profile doesn't exist and reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check lack of existence of\\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval == 0) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\\n    /// @param totalDiggingFees to be paid. Protocol fee is a percentage of this\\n    /// @return The protocol fees amount\\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 100;\\n    }\\n}\\n\",\"keccak256\":\"0xfb87b9c1495d1044d9bf70a5a67bcc6e798b6584159a3df9c5a0ab297c693612\",\"license\":\"Unlicense\"},\"contracts/storage/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\n/**\\n * Global diamond storage struct to be shared across facets\\n * TODO: Implement diamond storage pattern and consider splitting storage into facet specific structs\\n */\\nstruct AppStorage {\\n    // SARCO token contract\\n    IERC20 sarcoToken;\\n    // total protocol fees available to be withdrawn by the admin\\n    uint256 totalProtocolFees;\\n    /**\\n     * Protocol level admin configurations\\n     */\\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap\\n    uint256 protocolFeeBasePercentage;\\n    // % of digging fees archaeologists must have locked up per curse in cursed bond\\n    uint256 cursedBondPercentage;\\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time\\n    uint256 gracePeriod;\\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated\\n    uint256 expirationThreshold;\\n    // window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\\n    uint256 embalmerClaimWindow;\\n    // registered archaeologist addresses\\n    address[] archaeologistProfileAddresses;\\n    /**\\n     * Ownership mappings\\n     */\\n    // embalmer address => ids of sarcophagi they've created\\n    mapping(address => bytes32[]) embalmerSarcophagi;\\n    // archaeologist address =>  ids of sarcophagi they're protecting\\n    mapping(address => bytes32[]) archaeologistSarcophagi;\\n    // recipient address =>  ids of sarcophagi they're recipient on\\n    mapping(address => bytes32[]) recipientSarcophagi;\\n    // public key => archaeologist address\\n    mapping(bytes => address) publicKeyToArchaeologistAddress;\\n    // sarcophagus id => sarcophagus object\\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\\n    // archaeologist address => profile\\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\\n    // current balance of rewards available for the archaeologist to withdraw\\n    mapping(address => uint256) archaeologistRewards;\\n}\\n\\nlibrary LibAppStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"sarcophagus.storage.SarcophagusGoerliTest\\\");\\n\\n    function getAppStorage() internal pure returns (AppStorage storage s) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2afdc926b9a4dbe3e84abd27ab6111094c8a5265efa0a9bc3f67cab77f9cd4b3\",\"license\":\"Unlicense\"},\"hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x2205345e83eb86f5281f159a9215a096cb6d404782619f9b8e9d7a4a46c32a37\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612177806100206000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c8063364e0801146100675780636a5ac74c146100835780637f06727a1461009f5780638355a17b146100bb578063a4110dbe146100d7578063c885bc58146100f3575b600080fd5b610081600480360381019061007c91906116e9565b6100fd565b005b61009d600480360381019061009891906116e9565b610211565b005b6100b960048036038101906100b4919061185c565b610378565b005b6100d560048036038101906100d0919061185c565b6105c8565b005b6100f160048036038101906100ec9190611929565b610870565b005b6100fb610c63565b005b6000610107610df1565b905061011233610e1e565b61011c3383610eba565b8060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33846040518363ffffffff1660e01b815260040161017b9291906119b9565b6020604051808303816000875af115801561019a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101be9190611a1a565b503373ffffffffffffffffffffffffffffffffffffffff167fd91b1e491a880123721b161dbbf8249668b0c546077d7ba4d0016441ca9d8f45836040516102059190611a47565b60405180910390a25050565b600061021b610df1565b905061022633610e1e565b8181600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600401600082825461027a9190611a91565b925050819055508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330856040518463ffffffff1660e01b81526004016102e293929190611ae7565b6020604051808303816000875af1158015610301573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103259190611a1a565b503373ffffffffffffffffffffffffffffffffffffffff167ff882a0847c57aefe6f6c7df2098dd0afd122eb0e886199e223651b8e45fda8238360405161036c9190611a47565b60405180910390a25050565b6000610382610df1565b905061038d33610e1e565b600084148061039c5750600085145b156103d3576040517fdec9919f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600081600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050868160020190805190602001906104309291906115fc565b508581600301819055508481600001819055508281600101819055506000841115610556578382600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546104a99190611a91565b925050819055508160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330876040518463ffffffff1660e01b815260040161051193929190611ae7565b6020604051808303816000875af1158015610530573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105549190611a1a565b505b3373ffffffffffffffffffffffffffffffffffffffff167f8937618657bc05b4e1f529d147029377f8e0e6886ecf59183d212f263bd1bfa18260020183600301548460000154856004015486600101546040516105b7959493929190611c24565b60405180910390a250505050505050565b60006105d2610df1565b90506105dd33610ff5565b60008414806105ec5750600085145b15610623576040517fdec9919f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006040518060c00160405280868152602001848152602001888152602001878152602001858152602001600081525090506000841115610704578160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330876040518463ffffffff1660e01b81526004016106bf93929190611ae7565b6020604051808303816000875af11580156106de573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107029190611a1a565b505b8082600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082015181600001556020820151816001015560408201518160020190805190602001906107769291906115fc565b50606082015181600301556080820151816004015560a0820151816005015590505081600701339080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167f4d7b40490f4c8e19031e2c3248c8e1da3d74d5779beb3b7e2d7295194a58edd98260400151836060015184600001518560800151866020015160405161085f959493929190611cf5565b60405180910390a250505050505050565b600061087a610df1565b9050600081600c016000858152602001908152602001600020905060008160000154036108de57836040517f018da6880000000000000000000000000000000000000000000000000000000081526004016108d59190611d5e565b60405180910390fd5b8060020160009054906101000a900460ff161561093257836040517f9af72b860000000000000000000000000000000000000000000000000000000081526004016109299190611d5e565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81600001540361099a57836040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016109919190611d5e565b60405180910390fd5b80600001544210156109e9574281600001546040517f482768090000000000000000000000000000000000000000000000000000000081526004016109e0929190611d79565b60405180910390fd5b816004015481600001546109fd9190611a91565b421115610a56574282600401548260000154610a199190611a91565b6040517f4ccffab1000000000000000000000000000000000000000000000000000000008152600401610a4d929190611d79565b60405180910390fd5b600082600c016000868152602001908152602001600020600a0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000816002018054610ac090611b4d565b905003610b0457336040517f82881f03000000000000000000000000000000000000000000000000000000008152600401610afb9190611da2565b60405180910390fd5b8060030160009054906101000a900460ff1615610b5a5733856040517fa40b4423000000000000000000000000000000000000000000000000000000008152600401610b51929190611dbd565b60405180910390fd5b6000801b816001015414610ba557336040517f7b06b177000000000000000000000000000000000000000000000000000000008152600401610b9c9190611da2565b60405180910390fd5b610bb28482600201611091565b610bfa573381600201856040517f5a95e91c000000000000000000000000000000000000000000000000000000008152600401610bf193929190611e8c565b60405180910390fd5b838160010181905550610c0d8533611336565b3373ffffffffffffffffffffffffffffffffffffffff16857f110eca32dd0b1dbdeaa29671186ba025abb2a6d9c193469a7214ee3244ef740486604051610c549190611d5e565b60405180910390a35050505050565b6000610c6d610df1565b9050600081600e0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050600082600e0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33836040518363ffffffff1660e01b8152600401610d5b9291906119b9565b6020604051808303816000875af1158015610d7a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d9e9190611a1a565b503373ffffffffffffffffffffffffffffffffffffffff167fbc84835063c693975166f00cffb19f01a94c2db55b1bf259238c5da3594e506682604051610de59190611a47565b60405180910390a25050565b6000807f1464b352a39efde2dd07892d0f2f274ce8052e8749182fc4ead14ba82366194490508091505090565b6000610e28610df1565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015403610eb6576001826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401610ead929190611ed9565b60405180910390fd5b5050565b6000610ec4610df1565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154821115610f955780600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154826040517fa4e3bead000000000000000000000000000000000000000000000000000000008152600401610f8c929190611d79565b60405180910390fd5b8181600d0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206004016000828254610fe99190611f02565b92505081905550505050565b6000610fff610df1565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001541461108d576000826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401611084929190611ed9565b60405180910390fd5b5050565b60008060018380546110a290611b4d565b90506110ae9190611f02565b67ffffffffffffffff8111156110c7576110c6611731565b5b6040519080825280601f01601f1916602001820160405280156110f95781602001600182028036833780820191505090505b5090506000600190505b83805461110f90611b4d565b90508110156111da578381815461112590611b4d565b811061113457611133611f36565b5b8154600116156111535790600052602060002090602091828204019190065b9054901a7f010000000000000000000000000000000000000000000000000000000000000002826001836111879190611f02565b8151811061119857611197611f36565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806111d290611f65565b915050611103565b5060007f79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798905060007f483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8905060007ffffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036414190506000600160008060028661125e9190611fdc565b0361126a57601b61126d565b601c5b8660001b85806112805761127f611fad565b5b888d60001c0960001b604051600081526020016040526040516112a69493929190612071565b6020604051602081039080840390855afa1580156112c8573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff868051906020012060001c1690508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614965050505050505092915050565b6000611340610df1565b9050600081600c0160008581526020019081526020016000209050600082600c016000868152602001908152602001600020600a0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000826001015483600001546113ca9190611f02565b82600001546113d991906120b6565b90506000606484600b0154836113ef91906120b6565b6113f99190612110565b905061140586826114c1565b8085600d0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546114599190611a91565b925050819055508185600e0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546114b19190611a91565b9250508190555050505050505050565b60006114cb610df1565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206005015482111561159c5780600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154826040517faf5a111b000000000000000000000000000000000000000000000000000000008152600401611593929190611d79565b60405180910390fd5b8181600d0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546115f09190611f02565b92505081905550505050565b82805461160890611b4d565b90600052602060002090601f01602090048101928261162a5760008555611671565b82601f1061164357805160ff1916838001178555611671565b82800160010185558215611671579182015b82811115611670578251825591602001919060010190611655565b5b50905061167e9190611682565b5090565b5b8082111561169b576000816000905550600101611683565b5090565b6000604051905090565b600080fd5b600080fd5b6000819050919050565b6116c6816116b3565b81146116d157600080fd5b50565b6000813590506116e3816116bd565b92915050565b6000602082840312156116ff576116fe6116a9565b5b600061170d848285016116d4565b91505092915050565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61176982611720565b810181811067ffffffffffffffff8211171561178857611787611731565b5b80604052505050565b600061179b61169f565b90506117a78282611760565b919050565b600067ffffffffffffffff8211156117c7576117c6611731565b5b6117d082611720565b9050602081019050919050565b82818337600083830152505050565b60006117ff6117fa846117ac565b611791565b90508281526020810184848401111561181b5761181a61171b565b5b6118268482856117dd565b509392505050565b600082601f83011261184357611842611716565b5b81356118538482602086016117ec565b91505092915050565b600080600080600060a08688031215611878576118776116a9565b5b600086013567ffffffffffffffff811115611896576118956116ae565b5b6118a28882890161182e565b95505060206118b3888289016116d4565b94505060406118c4888289016116d4565b93505060606118d5888289016116d4565b92505060806118e6888289016116d4565b9150509295509295909350565b6000819050919050565b611906816118f3565b811461191157600080fd5b50565b600081359050611923816118fd565b92915050565b600080604083850312156119405761193f6116a9565b5b600061194e85828601611914565b925050602061195f85828601611914565b9150509250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061199482611969565b9050919050565b6119a481611989565b82525050565b6119b3816116b3565b82525050565b60006040820190506119ce600083018561199b565b6119db60208301846119aa565b9392505050565b60008115159050919050565b6119f7816119e2565b8114611a0257600080fd5b50565b600081519050611a14816119ee565b92915050565b600060208284031215611a3057611a2f6116a9565b5b6000611a3e84828501611a05565b91505092915050565b6000602082019050611a5c60008301846119aa565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611a9c826116b3565b9150611aa7836116b3565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115611adc57611adb611a62565b5b828201905092915050565b6000606082019050611afc600083018661199b565b611b09602083018561199b565b611b1660408301846119aa565b949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611b6557607f821691505b602082108103611b7857611b77611b1e565b5b50919050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b60008154611bb181611b4d565b611bbb8186611b7e565b94506001821660008114611bd65760018114611be857611c1b565b60ff1983168652602086019350611c1b565b611bf185611b8f565b60005b83811015611c1357815481890152600182019150602081019050611bf4565b808801955050505b50505092915050565b600060a0820190508181036000830152611c3e8188611ba4565b9050611c4d60208301876119aa565b611c5a60408301866119aa565b611c6760608301856119aa565b611c7460808301846119aa565b9695505050505050565b600081519050919050565b60005b83811015611ca7578082015181840152602081019050611c8c565b83811115611cb6576000848401525b50505050565b6000611cc782611c7e565b611cd18185611b7e565b9350611ce1818560208601611c89565b611cea81611720565b840191505092915050565b600060a0820190508181036000830152611d0f8188611cbc565b9050611d1e60208301876119aa565b611d2b60408301866119aa565b611d3860608301856119aa565b611d4560808301846119aa565b9695505050505050565b611d58816118f3565b82525050565b6000602082019050611d736000830184611d4f565b92915050565b6000604082019050611d8e60008301856119aa565b611d9b60208301846119aa565b9392505050565b6000602082019050611db7600083018461199b565b92915050565b6000604082019050611dd2600083018561199b565b611ddf6020830184611d4f565b9392505050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b60008154611e1981611b4d565b611e238186611de6565b94506001821660008114611e3e5760018114611e5057611e83565b60ff1983168652602086019350611e83565b611e5985611df7565b60005b83811015611e7b57815481890152600182019150602081019050611e5c565b808801955050505b50505092915050565b6000606082019050611ea1600083018661199b565b8181036020830152611eb38185611e0c565b9050611ec26040830184611d4f565b949350505050565b611ed3816119e2565b82525050565b6000604082019050611eee6000830185611eca565b611efb602083018461199b565b9392505050565b6000611f0d826116b3565b9150611f18836116b3565b925082821015611f2b57611f2a611a62565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000611f70826116b3565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611fa257611fa1611a62565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000611fe7826116b3565b9150611ff2836116b3565b92508261200257612001611fad565b5b828206905092915050565b6000819050919050565b60008160001b9050919050565b600061203f61203a6120358461200d565b612017565b6118f3565b9050919050565b61204f81612024565b82525050565b600060ff82169050919050565b61206b81612055565b82525050565b60006080820190506120866000830187612046565b6120936020830186612062565b6120a06040830185611d4f565b6120ad6060830184611d4f565b95945050505050565b60006120c1826116b3565b91506120cc836116b3565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561210557612104611a62565b5b828202905092915050565b600061211b826116b3565b9150612126836116b3565b92508261213657612135611fad565b5b82820490509291505056fea264697066735822122007d6763e594a0be8bf80333f987454444bfa0125016d7e0dd84cd4f190b1177764736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100625760003560e01c8063364e0801146100675780636a5ac74c146100835780637f06727a1461009f5780638355a17b146100bb578063a4110dbe146100d7578063c885bc58146100f3575b600080fd5b610081600480360381019061007c91906116e9565b6100fd565b005b61009d600480360381019061009891906116e9565b610211565b005b6100b960048036038101906100b4919061185c565b610378565b005b6100d560048036038101906100d0919061185c565b6105c8565b005b6100f160048036038101906100ec9190611929565b610870565b005b6100fb610c63565b005b6000610107610df1565b905061011233610e1e565b61011c3383610eba565b8060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33846040518363ffffffff1660e01b815260040161017b9291906119b9565b6020604051808303816000875af115801561019a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101be9190611a1a565b503373ffffffffffffffffffffffffffffffffffffffff167fd91b1e491a880123721b161dbbf8249668b0c546077d7ba4d0016441ca9d8f45836040516102059190611a47565b60405180910390a25050565b600061021b610df1565b905061022633610e1e565b8181600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600401600082825461027a9190611a91565b925050819055508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330856040518463ffffffff1660e01b81526004016102e293929190611ae7565b6020604051808303816000875af1158015610301573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103259190611a1a565b503373ffffffffffffffffffffffffffffffffffffffff167ff882a0847c57aefe6f6c7df2098dd0afd122eb0e886199e223651b8e45fda8238360405161036c9190611a47565b60405180910390a25050565b6000610382610df1565b905061038d33610e1e565b600084148061039c5750600085145b156103d3576040517fdec9919f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600081600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050868160020190805190602001906104309291906115fc565b508581600301819055508481600001819055508281600101819055506000841115610556578382600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546104a99190611a91565b925050819055508160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330876040518463ffffffff1660e01b815260040161051193929190611ae7565b6020604051808303816000875af1158015610530573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105549190611a1a565b505b3373ffffffffffffffffffffffffffffffffffffffff167f8937618657bc05b4e1f529d147029377f8e0e6886ecf59183d212f263bd1bfa18260020183600301548460000154856004015486600101546040516105b7959493929190611c24565b60405180910390a250505050505050565b60006105d2610df1565b90506105dd33610ff5565b60008414806105ec5750600085145b15610623576040517fdec9919f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006040518060c00160405280868152602001848152602001888152602001878152602001858152602001600081525090506000841115610704578160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330876040518463ffffffff1660e01b81526004016106bf93929190611ae7565b6020604051808303816000875af11580156106de573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107029190611a1a565b505b8082600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082015181600001556020820151816001015560408201518160020190805190602001906107769291906115fc565b50606082015181600301556080820151816004015560a0820151816005015590505081600701339080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167f4d7b40490f4c8e19031e2c3248c8e1da3d74d5779beb3b7e2d7295194a58edd98260400151836060015184600001518560800151866020015160405161085f959493929190611cf5565b60405180910390a250505050505050565b600061087a610df1565b9050600081600c016000858152602001908152602001600020905060008160000154036108de57836040517f018da6880000000000000000000000000000000000000000000000000000000081526004016108d59190611d5e565b60405180910390fd5b8060020160009054906101000a900460ff161561093257836040517f9af72b860000000000000000000000000000000000000000000000000000000081526004016109299190611d5e565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81600001540361099a57836040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016109919190611d5e565b60405180910390fd5b80600001544210156109e9574281600001546040517f482768090000000000000000000000000000000000000000000000000000000081526004016109e0929190611d79565b60405180910390fd5b816004015481600001546109fd9190611a91565b421115610a56574282600401548260000154610a199190611a91565b6040517f4ccffab1000000000000000000000000000000000000000000000000000000008152600401610a4d929190611d79565b60405180910390fd5b600082600c016000868152602001908152602001600020600a0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000816002018054610ac090611b4d565b905003610b0457336040517f82881f03000000000000000000000000000000000000000000000000000000008152600401610afb9190611da2565b60405180910390fd5b8060030160009054906101000a900460ff1615610b5a5733856040517fa40b4423000000000000000000000000000000000000000000000000000000008152600401610b51929190611dbd565b60405180910390fd5b6000801b816001015414610ba557336040517f7b06b177000000000000000000000000000000000000000000000000000000008152600401610b9c9190611da2565b60405180910390fd5b610bb28482600201611091565b610bfa573381600201856040517f5a95e91c000000000000000000000000000000000000000000000000000000008152600401610bf193929190611e8c565b60405180910390fd5b838160010181905550610c0d8533611336565b3373ffffffffffffffffffffffffffffffffffffffff16857f110eca32dd0b1dbdeaa29671186ba025abb2a6d9c193469a7214ee3244ef740486604051610c549190611d5e565b60405180910390a35050505050565b6000610c6d610df1565b9050600081600e0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050600082600e0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33836040518363ffffffff1660e01b8152600401610d5b9291906119b9565b6020604051808303816000875af1158015610d7a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d9e9190611a1a565b503373ffffffffffffffffffffffffffffffffffffffff167fbc84835063c693975166f00cffb19f01a94c2db55b1bf259238c5da3594e506682604051610de59190611a47565b60405180910390a25050565b6000807f1464b352a39efde2dd07892d0f2f274ce8052e8749182fc4ead14ba82366194490508091505090565b6000610e28610df1565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015403610eb6576001826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401610ead929190611ed9565b60405180910390fd5b5050565b6000610ec4610df1565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154821115610f955780600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154826040517fa4e3bead000000000000000000000000000000000000000000000000000000008152600401610f8c929190611d79565b60405180910390fd5b8181600d0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206004016000828254610fe99190611f02565b92505081905550505050565b6000610fff610df1565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001541461108d576000826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401611084929190611ed9565b60405180910390fd5b5050565b60008060018380546110a290611b4d565b90506110ae9190611f02565b67ffffffffffffffff8111156110c7576110c6611731565b5b6040519080825280601f01601f1916602001820160405280156110f95781602001600182028036833780820191505090505b5090506000600190505b83805461110f90611b4d565b90508110156111da578381815461112590611b4d565b811061113457611133611f36565b5b8154600116156111535790600052602060002090602091828204019190065b9054901a7f010000000000000000000000000000000000000000000000000000000000000002826001836111879190611f02565b8151811061119857611197611f36565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806111d290611f65565b915050611103565b5060007f79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798905060007f483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8905060007ffffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036414190506000600160008060028661125e9190611fdc565b0361126a57601b61126d565b601c5b8660001b85806112805761127f611fad565b5b888d60001c0960001b604051600081526020016040526040516112a69493929190612071565b6020604051602081039080840390855afa1580156112c8573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff868051906020012060001c1690508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614965050505050505092915050565b6000611340610df1565b9050600081600c0160008581526020019081526020016000209050600082600c016000868152602001908152602001600020600a0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000826001015483600001546113ca9190611f02565b82600001546113d991906120b6565b90506000606484600b0154836113ef91906120b6565b6113f99190612110565b905061140586826114c1565b8085600d0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546114599190611a91565b925050819055508185600e0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546114b19190611a91565b9250508190555050505050505050565b60006114cb610df1565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206005015482111561159c5780600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154826040517faf5a111b000000000000000000000000000000000000000000000000000000008152600401611593929190611d79565b60405180910390fd5b8181600d0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546115f09190611f02565b92505081905550505050565b82805461160890611b4d565b90600052602060002090601f01602090048101928261162a5760008555611671565b82601f1061164357805160ff1916838001178555611671565b82800160010185558215611671579182015b82811115611670578251825591602001919060010190611655565b5b50905061167e9190611682565b5090565b5b8082111561169b576000816000905550600101611683565b5090565b6000604051905090565b600080fd5b600080fd5b6000819050919050565b6116c6816116b3565b81146116d157600080fd5b50565b6000813590506116e3816116bd565b92915050565b6000602082840312156116ff576116fe6116a9565b5b600061170d848285016116d4565b91505092915050565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61176982611720565b810181811067ffffffffffffffff8211171561178857611787611731565b5b80604052505050565b600061179b61169f565b90506117a78282611760565b919050565b600067ffffffffffffffff8211156117c7576117c6611731565b5b6117d082611720565b9050602081019050919050565b82818337600083830152505050565b60006117ff6117fa846117ac565b611791565b90508281526020810184848401111561181b5761181a61171b565b5b6118268482856117dd565b509392505050565b600082601f83011261184357611842611716565b5b81356118538482602086016117ec565b91505092915050565b600080600080600060a08688031215611878576118776116a9565b5b600086013567ffffffffffffffff811115611896576118956116ae565b5b6118a28882890161182e565b95505060206118b3888289016116d4565b94505060406118c4888289016116d4565b93505060606118d5888289016116d4565b92505060806118e6888289016116d4565b9150509295509295909350565b6000819050919050565b611906816118f3565b811461191157600080fd5b50565b600081359050611923816118fd565b92915050565b600080604083850312156119405761193f6116a9565b5b600061194e85828601611914565b925050602061195f85828601611914565b9150509250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061199482611969565b9050919050565b6119a481611989565b82525050565b6119b3816116b3565b82525050565b60006040820190506119ce600083018561199b565b6119db60208301846119aa565b9392505050565b60008115159050919050565b6119f7816119e2565b8114611a0257600080fd5b50565b600081519050611a14816119ee565b92915050565b600060208284031215611a3057611a2f6116a9565b5b6000611a3e84828501611a05565b91505092915050565b6000602082019050611a5c60008301846119aa565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611a9c826116b3565b9150611aa7836116b3565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115611adc57611adb611a62565b5b828201905092915050565b6000606082019050611afc600083018661199b565b611b09602083018561199b565b611b1660408301846119aa565b949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611b6557607f821691505b602082108103611b7857611b77611b1e565b5b50919050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b60008154611bb181611b4d565b611bbb8186611b7e565b94506001821660008114611bd65760018114611be857611c1b565b60ff1983168652602086019350611c1b565b611bf185611b8f565b60005b83811015611c1357815481890152600182019150602081019050611bf4565b808801955050505b50505092915050565b600060a0820190508181036000830152611c3e8188611ba4565b9050611c4d60208301876119aa565b611c5a60408301866119aa565b611c6760608301856119aa565b611c7460808301846119aa565b9695505050505050565b600081519050919050565b60005b83811015611ca7578082015181840152602081019050611c8c565b83811115611cb6576000848401525b50505050565b6000611cc782611c7e565b611cd18185611b7e565b9350611ce1818560208601611c89565b611cea81611720565b840191505092915050565b600060a0820190508181036000830152611d0f8188611cbc565b9050611d1e60208301876119aa565b611d2b60408301866119aa565b611d3860608301856119aa565b611d4560808301846119aa565b9695505050505050565b611d58816118f3565b82525050565b6000602082019050611d736000830184611d4f565b92915050565b6000604082019050611d8e60008301856119aa565b611d9b60208301846119aa565b9392505050565b6000602082019050611db7600083018461199b565b92915050565b6000604082019050611dd2600083018561199b565b611ddf6020830184611d4f565b9392505050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b60008154611e1981611b4d565b611e238186611de6565b94506001821660008114611e3e5760018114611e5057611e83565b60ff1983168652602086019350611e83565b611e5985611df7565b60005b83811015611e7b57815481890152600182019150602081019050611e5c565b808801955050505b50505092915050565b6000606082019050611ea1600083018661199b565b8181036020830152611eb38185611e0c565b9050611ec26040830184611d4f565b949350505050565b611ed3816119e2565b82525050565b6000604082019050611eee6000830185611eca565b611efb602083018461199b565b9392505050565b6000611f0d826116b3565b9150611f18836116b3565b925082821015611f2b57611f2a611a62565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000611f70826116b3565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611fa257611fa1611a62565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000611fe7826116b3565b9150611ff2836116b3565b92508261200257612001611fad565b5b828206905092915050565b6000819050919050565b60008160001b9050919050565b600061203f61203a6120358461200d565b612017565b6118f3565b9050919050565b61204f81612024565b82525050565b600060ff82169050919050565b61206b81612055565b82525050565b60006080820190506120866000830187612046565b6120936020830186612062565b6120a06040830185611d4f565b6120ad6060830184611d4f565b95945050505050565b60006120c1826116b3565b91506120cc836116b3565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561210557612104611a62565b5b828202905092915050565b600061211b826116b3565b9150612126836116b3565b92508261213657612135611fad565b5b82820490509291505056fea264697066735822122007d6763e594a0be8bf80333f987454444bfa0125016d7e0dd84cd4f190b1177764736f6c634300080d0033",
  "devdoc": {
    "errors": {
      "ArchaeologistAlreadyPublishedPrivateKey(address)": [
        {
          "params": {
            "archaeologistAddress": "address of publishing archaeologist"
          }
        }
      ],
      "ArchaeologistHasBeenAccused(address,bytes32)": [
        {
          "params": {
            "archaeologistAddress": "Address of accused archaeologist who is attempting to publish their private key",
            "sarcoId": "ID of sarcophagus archaeologist has attempted to publish a key on"
          }
        }
      ],
      "ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)": [
        {
          "params": {
            "archaeologistAddress": "address of publishing archaeologist",
            "privateKey": "privateKey the archaeologist has attempted to publish",
            "publicKey": "publicKey stored for archaeologist on the sarcophagus"
          }
        }
      ],
      "TooEarlyForPublish(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed publish attempt",
            "resurrectionTime": "Time after which the sarcophagus can be resurrected"
          }
        }
      ],
      "TooLateForPublish(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed publish attempt",
            "publishDeadline": "Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)"
          }
        }
      ]
    },
    "events": {
      "PublishPrivateKey(bytes32,bytes32,address)": {
        "params": {
          "privateKey": "private key that has been published",
          "sarcoId": "ID of sarcophagus archaeologist has published the private key on"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "depositFreeBond(uint256)": {
        "params": {
          "amount": "The amount to deposit"
        }
      },
      "publishPrivateKey(bytes32,bytes32)": {
        "params": {
          "privateKey": "The private key the archaeologist is publishing",
          "sarcoId": "The identifier of the sarcophagus for which the archaeologist is responsible"
        }
      },
      "registerArchaeologist(string,uint256,uint256,uint256,uint256)": {
        "params": {
          "freeBond": "How much bond the archaeologist wants to deposit during the register call (if any)",
          "maximumResurrectionTime": "The time beyond which the archaeologist is not willing to accept new curses or rewraps",
          "maximumRewrapInterval": "The longest interval of time from a rewrap time the arch will accept for a resurrection",
          "minimumDiggingFeePerSecond": "The archaeologist's minimum amount to earn per second for being cursed",
          "peerId": "The libp2p identifier for the archaeologist"
        }
      },
      "updateArchaeologist(string,uint256,uint256,uint256,uint256)": {
        "params": {
          "maximumRewrapInterval": "The longest interval of time from a rewrap time the arch will accept for a resurrection freeBond How much bond the archaeologist wants to deposit during the update call (if any)",
          "minimumDiggingFeePerSecond": "The archaeologist's minimum amount to earn per second for being cursed",
          "peerId": "The libp2p identifier for the archaeologist"
        }
      },
      "withdrawFreeBond(uint256)": {
        "params": {
          "amount": "The amount to withdraw"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "ArchaeologistAlreadyPublishedPrivateKey(address)": [
        {
          "notice": "Archaeologist has attempted to publish a key for a sarcophagus twice"
        }
      ],
      "ArchaeologistHasBeenAccused(address,bytes32)": [
        {
          "notice": "An archaeologist that has already been successfully accused has attempted to publish their private key"
        }
      ],
      "ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)": [
        {
          "notice": "Archaeologist has attempted to publish the incorrect private key for a sarcophagus"
        }
      ],
      "CannotSetZeroProfileValue()": [
        {
          "notice": "Archaeologist has attempted to set a zero minimumDiggingFeePerSecond or maximumRewrapInterval"
        }
      ],
      "TooEarlyForPublish(uint256,uint256)": [
        {
          "notice": "Archaeologist has attempted to publish a key before the resurrection time"
        }
      ],
      "TooLateForPublish(uint256,uint256)": [
        {
          "notice": "Archaeologist has attempted to publish a key after the end of the resurrection window"
        }
      ]
    },
    "events": {
      "PublishPrivateKey(bytes32,bytes32,address)": {
        "notice": "Emitted when an archaeologist successfully publishes their private key for a sarcophagus"
      }
    },
    "kind": "user",
    "methods": {
      "depositFreeBond(uint256)": {
        "notice": "Deposits an archaeologist's free bond to the contract."
      },
      "publishPrivateKey(bytes32,bytes32)": {
        "notice": "Publishes the private key for which the archaeologist is responsible during the sarcophagus resurrection window. Pays digging fees to the archaeologist and releases their locked bond. Cannot be called on a compromised or buried sarcophagus."
      },
      "registerArchaeologist(string,uint256,uint256,uint256,uint256)": {
        "notice": "Registers the archaeologist profile"
      },
      "updateArchaeologist(string,uint256,uint256,uint256,uint256)": {
        "notice": "Updates the archaeologist profile"
      },
      "withdrawFreeBond(uint256)": {
        "notice": "Withdraws an archaeologist's free bond from the contract."
      },
      "withdrawReward()": {
        "notice": "Withdraws all rewards from an archaeologist's reward pool"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}