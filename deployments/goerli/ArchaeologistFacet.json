{
  "address": "0x978F6AfB5d1689da12e36D4bd42860991DEC804F",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologistAddress",
          "type": "address"
        }
      ],
      "name": "ArchaeologistAlreadyPublishedPrivateKey",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologistAddress",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "ArchaeologistHasBeenAccused",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "ArchaeologistNotOnSarcophagus",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "exists",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "ArchaeologistProfileExistsShouldBe",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologistAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "publicKey",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "privateKey",
          "type": "bytes32"
        }
      ],
      "name": "ArchaeologistPublishedIncorrectPrivateKey",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CannotSetZeroProfileValue",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "cursedBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "NotEnoughCursedBond",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "NotEnoughFreeBond",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusCompromised",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusInactive",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "resurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "TooEarlyForPublish",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "publishDeadline",
          "type": "uint256"
        }
      ],
      "name": "TooLateForPublish",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "depositedBond",
          "type": "uint256"
        }
      ],
      "name": "DepositFreeBond",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "privateKey",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "PublishPrivateKey",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "minimumDiggingFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maximumResurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "RegisterArchaeologist",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "minimumDiggingFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maximumResurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "UpdateArchaeologist",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "withdrawnBond",
          "type": "uint256"
        }
      ],
      "name": "WithdrawFreeBond",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "withdrawnReward",
          "type": "uint256"
        }
      ],
      "name": "WithdrawReward",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "depositFreeBond",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "privateKey",
          "type": "bytes32"
        }
      ],
      "name": "publishPrivateKey",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "minimumDiggingFeePerSecond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maximumResurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "registerArchaeologist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "minimumDiggingFeePerSecond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maximumResurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "updateArchaeologist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawFreeBond",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawReward",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xe4145dd0c2b76e0f3a55ce8e87a0e4baedbf9a6ca58b595797ab505e233a0545",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xDa863f802Cc8CBA3C436bF801BD7785d9E7d4F36",
    "contractAddress": null,
    "transactionIndex": 118,
    "gasUsed": "1921749",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x83be2aa60668919008959e6d703dd75ceb3f54f8aa43c34499e5dd979db5b4cc",
    "transactionHash": "0xe4145dd0c2b76e0f3a55ce8e87a0e4baedbf9a6ca58b595797ab505e233a0545",
    "logs": [],
    "blockNumber": 8738754,
    "cumulativeGasUsed": "15266675",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "d2954766a5257e4e199bc2f01ec40385",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologistAddress\",\"type\":\"address\"}],\"name\":\"ArchaeologistAlreadyPublishedPrivateKey\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologistAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"ArchaeologistHasBeenAccused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"ArchaeologistNotOnSarcophagus\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"ArchaeologistProfileExistsShouldBe\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologistAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"}],\"name\":\"ArchaeologistPublishedIncorrectPrivateKey\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetZeroProfileValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cursedBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotEnoughCursedBond\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotEnoughFreeBond\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusCompromised\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusInactive\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resurrectionTime\",\"type\":\"uint256\"}],\"name\":\"TooEarlyForPublish\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publishDeadline\",\"type\":\"uint256\"}],\"name\":\"TooLateForPublish\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositedBond\",\"type\":\"uint256\"}],\"name\":\"DepositFreeBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"PublishPrivateKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumDiggingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"}],\"name\":\"RegisterArchaeologist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumDiggingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"}],\"name\":\"UpdateArchaeologist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnBond\",\"type\":\"uint256\"}],\"name\":\"WithdrawFreeBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnReward\",\"type\":\"uint256\"}],\"name\":\"WithdrawReward\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositFreeBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"}],\"name\":\"publishPrivateKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFeePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"}],\"name\":\"registerArchaeologist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFeePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"}],\"name\":\"updateArchaeologist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFreeBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ArchaeologistAlreadyPublishedPrivateKey(address)\":[{\"params\":{\"archaeologistAddress\":\"address of publishing archaeologist\"}}],\"ArchaeologistHasBeenAccused(address,bytes32)\":[{\"params\":{\"archaeologistAddress\":\"Address of accused archaeologist who is attempting to publish their private key\",\"sarcoId\":\"ID of sarcophagus archaeologist has attempted to publish a key on\"}}],\"ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)\":[{\"params\":{\"archaeologistAddress\":\"address of publishing archaeologist\",\"privateKey\":\"privateKey the archaeologist has attempted to publish\",\"publicKey\":\"publicKey stored for archaeologist on the sarcophagus\"}}],\"TooEarlyForPublish(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed publish attempt\",\"resurrectionTime\":\"Time after which the sarcophagus can be resurrected\"}}],\"TooLateForPublish(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed publish attempt\",\"publishDeadline\":\"Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)\"}}]},\"events\":{\"PublishPrivateKey(bytes32,bytes32,address)\":{\"params\":{\"privateKey\":\"private key that has been published\",\"sarcoId\":\"ID of sarcophagus archaeologist has published the private key on\"}}},\"kind\":\"dev\",\"methods\":{\"depositFreeBond(uint256)\":{\"params\":{\"amount\":\"The amount to deposit\"}},\"publishPrivateKey(bytes32,bytes32)\":{\"params\":{\"privateKey\":\"The private key the archaeologist is publishing\",\"sarcoId\":\"The identifier of the sarcophagus for which the archaeologist is responsible\"}},\"registerArchaeologist(string,uint256,uint256,uint256,uint256)\":{\"params\":{\"freeBond\":\"How much bond the archaeologist wants to deposit during the register call (if any)\",\"maximumResurrectionTime\":\"The time beyond which the archaeologist is not willing to accept new curses or rewraps\",\"maximumRewrapInterval\":\"The longest interval of time from a rewrap time the arch will accept for a resurrection\",\"minimumDiggingFeePerSecond\":\"The archaeologist's minimum amount to earn per second for being cursed\",\"peerId\":\"The libp2p identifier for the archaeologist\"}},\"updateArchaeologist(string,uint256,uint256,uint256,uint256)\":{\"params\":{\"maximumRewrapInterval\":\"The longest interval of time from a rewrap time the arch will accept for a resurrection freeBond How much bond the archaeologist wants to deposit during the update call (if any)\",\"minimumDiggingFeePerSecond\":\"The archaeologist's minimum amount to earn per second for being cursed\",\"peerId\":\"The libp2p identifier for the archaeologist\"}},\"withdrawFreeBond(uint256)\":{\"params\":{\"amount\":\"The amount to withdraw\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"ArchaeologistAlreadyPublishedPrivateKey(address)\":[{\"notice\":\"Archaeologist has attempted to publish a key for a sarcophagus twice\"}],\"ArchaeologistHasBeenAccused(address,bytes32)\":[{\"notice\":\"An archaeologist that has already been successfully accused has attempted to publish their private key\"}],\"ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)\":[{\"notice\":\"Archaeologist has attempted to publish the incorrect private key for a sarcophagus\"}],\"CannotSetZeroProfileValue()\":[{\"notice\":\"Archaeologist has attempted to set a zero minimumDiggingFeePerSecond or maximumRewrapInterval\"}],\"TooEarlyForPublish(uint256,uint256)\":[{\"notice\":\"Archaeologist has attempted to publish a key before the resurrection time\"}],\"TooLateForPublish(uint256,uint256)\":[{\"notice\":\"Archaeologist has attempted to publish a key after the end of the resurrection window\"}]},\"events\":{\"PublishPrivateKey(bytes32,bytes32,address)\":{\"notice\":\"Emitted when an archaeologist successfully publishes their private key for a sarcophagus\"}},\"kind\":\"user\",\"methods\":{\"depositFreeBond(uint256)\":{\"notice\":\"Deposits an archaeologist's free bond to the contract.\"},\"publishPrivateKey(bytes32,bytes32)\":{\"notice\":\"Publishes the private key for which the archaeologist is responsible during the sarcophagus resurrection window. Pays digging fees to the archaeologist and releases their locked bond. Cannot be called on a compromised or buried sarcophagus.\"},\"registerArchaeologist(string,uint256,uint256,uint256,uint256)\":{\"notice\":\"Registers the archaeologist profile\"},\"updateArchaeologist(string,uint256,uint256,uint256,uint256)\":{\"notice\":\"Updates the archaeologist profile\"},\"withdrawFreeBond(uint256)\":{\"notice\":\"Withdraws an archaeologist's free bond from the contract.\"},\"withdrawReward()\":{\"notice\":\"Withdraws all rewards from an archaeologist's reward pool\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/ArchaeologistFacet.sol\":\"ArchaeologistFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"contracts/facets/ArchaeologistFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport {LibPrivateKeys} from \\\"../libraries/LibPrivateKeys.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\n\\ncontract ArchaeologistFacet {\\n    /// @notice Emitted when an archaeologist successfully publishes their private key for a sarcophagus\\n    /// @param sarcoId ID of sarcophagus archaeologist has published the private key on\\n    /// @param privateKey private key that has been published\\n    event PublishPrivateKey(\\n        bytes32 indexed sarcoId,\\n        bytes32 privateKey,\\n        address indexed archaeologist\\n    );\\n\\n    event DepositFreeBond(address indexed archaeologist, uint256 depositedBond);\\n\\n    event RegisterArchaeologist(\\n        address indexed archaeologist,\\n        string peerId,\\n        uint256 minimumDiggingFee,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond,\\n        uint256 maximumResurrectionTime\\n    );\\n\\n    event UpdateArchaeologist(\\n        address indexed archaeologist,\\n        string peerId,\\n        uint256 minimumDiggingFee,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond,\\n        uint256 maximumResurrectionTime\\n    );\\n\\n    event WithdrawFreeBond(address indexed archaeologist, uint256 withdrawnBond);\\n\\n    event WithdrawReward(address indexed archaeologist, uint256 withdrawnReward);\\n\\n    /// @notice An archaeologist that has already been successfully accused has attempted to publish their private key\\n    /// @param archaeologistAddress Address of accused archaeologist who is attempting to publish their private key\\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a key on\\n    error ArchaeologistHasBeenAccused(address archaeologistAddress, bytes32 sarcoId);\\n\\n    /// @notice Archaeologist has attempted to publish a key before the resurrection time\\n    /// @param currentTime Timestamp of the failed publish attempt\\n    /// @param resurrectionTime Time after which the sarcophagus can be resurrected\\n    error TooEarlyForPublish(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Archaeologist has attempted to publish a key after the end of the resurrection window\\n    /// @param currentTime Timestamp of the failed publish attempt\\n    /// @param publishDeadline Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)\\n    error TooLateForPublish(uint256 currentTime, uint256 publishDeadline);\\n\\n    /// @notice Archaeologist has attempted to publish a key for a sarcophagus twice\\n    /// @param archaeologistAddress address of publishing archaeologist\\n    error ArchaeologistAlreadyPublishedPrivateKey(address archaeologistAddress);\\n\\n    /// @notice Archaeologist has attempted to set a zero minimumDiggingFeePerSecond or maximumRewrapInterval\\n    error CannotSetZeroProfileValue();\\n\\n    /// @notice Archaeologist has attempted to publish the incorrect private key for a sarcophagus\\n    /// @param archaeologistAddress address of publishing archaeologist\\n    /// @param publicKey publicKey stored for archaeologist on the sarcophagus\\n    /// @param privateKey privateKey the archaeologist has attempted to publish\\n    error ArchaeologistPublishedIncorrectPrivateKey(\\n        address archaeologistAddress,\\n        bytes publicKey,\\n        bytes32 privateKey\\n    );\\n\\n    /// @notice Registers the archaeologist profile\\n    /// @param peerId The libp2p identifier for the archaeologist\\n    /// @param minimumDiggingFeePerSecond The archaeologist's minimum amount to earn per second for being cursed\\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\\n    /// for a resurrection\\n    /// @param freeBond How much bond the archaeologist wants to deposit during the register call (if any)\\n    /// @param maximumResurrectionTime The time beyond which the archaeologist is not willing to accept new curses or rewraps\\n    function registerArchaeologist(\\n        string memory peerId,\\n        uint256 minimumDiggingFeePerSecond,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond,\\n        uint256 maximumResurrectionTime\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        // verify that the archaeologist does not already exist\\n        LibUtils.revertIfArchProfileExists(msg.sender);\\n\\n        if (maximumRewrapInterval == 0 || minimumDiggingFeePerSecond == 0) {\\n            revert CannotSetZeroProfileValue();\\n        }\\n\\n        // create a new archaeologist\\n        LibTypes.ArchaeologistProfile memory newArch = LibTypes.ArchaeologistProfile({\\n            peerId: peerId,\\n            minimumDiggingFeePerSecond: minimumDiggingFeePerSecond,\\n            maximumResurrectionTime: maximumResurrectionTime,\\n            maximumRewrapInterval: maximumRewrapInterval,\\n            freeBond: freeBond,\\n            cursedBond: 0\\n        });\\n\\n        // transfer SARCO tokens from the archaeologist to this contract, to be\\n        // used as their free bond. can be 0.\\n        if (freeBond > 0) {\\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\\n        }\\n\\n        // save the new archaeologist into relevant data structures\\n        s.archaeologistProfiles[msg.sender] = newArch;\\n        s.archaeologistProfileAddresses.push(msg.sender);\\n\\n        emit RegisterArchaeologist(\\n            msg.sender,\\n            newArch.peerId,\\n            newArch.minimumDiggingFeePerSecond,\\n            newArch.maximumRewrapInterval,\\n            newArch.freeBond,\\n            newArch.maximumResurrectionTime\\n        );\\n    }\\n\\n    /// @notice Updates the archaeologist profile\\n    /// @param peerId The libp2p identifier for the archaeologist\\n    /// @param minimumDiggingFeePerSecond The archaeologist's minimum amount to earn per second for being cursed\\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\\n    /// for a resurrection\\n    /// freeBond How much bond the archaeologist wants to deposit during the update call (if any)\\n    function updateArchaeologist(\\n        string memory peerId,\\n        uint256 minimumDiggingFeePerSecond,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond,\\n        uint256 maximumResurrectionTime\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        // verify that the archaeologist exists\\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\\n\\n        if (maximumRewrapInterval == 0 || minimumDiggingFeePerSecond == 0) {\\n            revert CannotSetZeroProfileValue();\\n        }\\n\\n        LibTypes.ArchaeologistProfile storage existingArch = s.archaeologistProfiles[msg.sender];\\n        existingArch.peerId = peerId;\\n        existingArch.minimumDiggingFeePerSecond = minimumDiggingFeePerSecond;\\n        existingArch.maximumRewrapInterval = maximumRewrapInterval;\\n        existingArch.maximumResurrectionTime = maximumResurrectionTime;\\n\\n        // transfer SARCO tokens from the archaeologist to this contract, to be\\n        // used as their free bond. can be 0.\\n        if (freeBond > 0) {\\n            s.archaeologistProfiles[msg.sender].freeBond += freeBond;\\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\\n        }\\n\\n        emit UpdateArchaeologist(\\n            msg.sender,\\n            existingArch.peerId,\\n            existingArch.minimumDiggingFeePerSecond,\\n            existingArch.maximumRewrapInterval,\\n            existingArch.freeBond,\\n            existingArch.maximumResurrectionTime\\n        );\\n    }\\n\\n    /// @notice Deposits an archaeologist's free bond to the contract.\\n    /// @param amount The amount to deposit\\n    function depositFreeBond(uint256 amount) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\\n        // Increase the archaeologist's free bond in app storage\\n        s.archaeologistProfiles[msg.sender].freeBond += amount;\\n\\n        // Transfer the amount of sarcoToken from the archaeologist to the contract\\n        s.sarcoToken.transferFrom(msg.sender, address(this), amount);\\n        // Emit an event\\n        emit DepositFreeBond(msg.sender, amount);\\n    }\\n\\n    /// @notice Withdraws an archaeologist's free bond from the contract.\\n    /// @param amount The amount to withdraw\\n    function withdrawFreeBond(uint256 amount) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\\n        // Decrease the archaeologist's free bond amount.\\n        // Reverts if there is not enough free bond on the contract.\\n        LibBonds.decreaseFreeBond(msg.sender, amount);\\n\\n        // Transfer the amount of sarcoToken to the archaeologist\\n        s.sarcoToken.transfer(msg.sender, amount);\\n\\n        // Emit an event\\n        emit WithdrawFreeBond(msg.sender, amount);\\n    }\\n\\n    /// @notice Withdraws all rewards from an archaeologist's reward pool\\n    function withdrawReward() external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        uint256 amountToWithdraw = s.archaeologistRewards[msg.sender];\\n        s.archaeologistRewards[msg.sender] = 0;\\n\\n        // Transfer the amount of sarcoToken to the archaeologist\\n        s.sarcoToken.transfer(msg.sender, amountToWithdraw);\\n\\n        emit WithdrawReward(msg.sender, amountToWithdraw);\\n    }\\n\\n    /// @notice Publishes the private key for which the archaeologist is responsible during the\\n    /// sarcophagus resurrection window.\\n    /// Pays digging fees to the archaeologist and releases their locked bond.\\n    /// Cannot be called on a compromised or buried sarcophagus.\\n    /// @param sarcoId The identifier of the sarcophagus for which the archaeologist is responsible\\n    /// @param privateKey The private key the archaeologist is publishing\\n    function publishPrivateKey(bytes32 sarcoId, bytes32 privateKey) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm current time is after resurrectionTime\\n        if (block.timestamp < sarcophagus.resurrectionTime) {\\n            revert TooEarlyForPublish(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm current time is within gracePeriod\\n        if (block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod) {\\n            revert TooLateForPublish(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\\n        }\\n\\n        // Confirm tx sender is an archaeologist on the sarcophagus\\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\\n            .sarcophagi[sarcoId]\\n            .cursedArchaeologists[msg.sender];\\n        if (cursedArchaeologist.publicKey.length == 0) {\\n            revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\\n        }\\n\\n        // Confirm archaeologist has not already leaked their private key\\n        if (cursedArchaeologist.isAccused) {\\n            revert ArchaeologistHasBeenAccused(msg.sender, sarcoId);\\n        }\\n\\n        // Confirm archaeologist has not already published their private key\\n        if (cursedArchaeologist.privateKey != 0) {\\n            revert ArchaeologistAlreadyPublishedPrivateKey(msg.sender);\\n        }\\n\\n        // Confirm that the private key being submitted matches the public key stored on the\\n        // sarcophagus for this archaeologist\\n        if (!LibPrivateKeys.isPublicKeyOfPrivateKey(privateKey, cursedArchaeologist.publicKey)) {\\n            revert ArchaeologistPublishedIncorrectPrivateKey(\\n                msg.sender,\\n                cursedArchaeologist.publicKey,\\n                privateKey\\n            );\\n        }\\n\\n        // Store the private key on cursed archaeologist\\n        cursedArchaeologist.privateKey = privateKey;\\n\\n        // Free archaeologist locked bond and transfer digging fees\\n        LibBonds.freeArchaeologist(sarcoId, msg.sender);\\n\\n        // Save the successful sarcophagus against the archaeologist\\n        s.archaeologistSuccesses[msg.sender].push(sarcoId);\\n\\n        emit PublishPrivateKey(sarcoId, privateKey, msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0x1b49172b1f5550d2846605bba1486446e954fe1aa544e7e24687265a80a3e2c5\",\"license\":\"Unlicense\"},\"contracts/facets/EmbalmerFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\n\\ncontract EmbalmerFacet {\\n    /// @notice Emitted when a sarcophagus is created\\n    /// @param sarcoId Id of the new sarcophagus\\n    /// @param name Name of the new sarcophagus\\n    /// @param resurrectionTime Resurrection time of the new sarcophagus\\n    /// @param embalmer Address of embalmer\\n    /// @param recipient Address of recipient\\n    /// @param cursedArchaeologists Array of addresses of cursed archaeologists\\n    /// @param totalDiggingFees Total digging fees charged to embalmer to create the sarcophagus\\n    /// @param createSarcophagusProtocolFees Total protocol fees charged to embalmer to create the sarcophagus\\n    /// @param arweaveTxId arweave tx id for the sarcophagus\\n    event CreateSarcophagus(\\n        bytes32 indexed sarcoId,\\n        string name,\\n        uint256 resurrectionTime,\\n        address embalmer,\\n        address recipient,\\n        address[] cursedArchaeologists,\\n        uint256 totalDiggingFees,\\n        uint256 createSarcophagusProtocolFees,\\n        string arweaveTxId\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is rewrapped\\n    /// @param sarcoId Id of sarcophagus that was rewrapped\\n    /// @param resurrectionTime New resurrection time for the sarcophagus\\n    /// @param totalDiggingFees Total digging fees charged to the embalmer for the rewrap\\n    /// @param rewrapSarcophagusProtocolFees Total protocol fees charged to the embalmer for the rewrap\\n    event RewrapSarcophagus(\\n        bytes32 indexed sarcoId,\\n        uint256 resurrectionTime,\\n        uint256 totalDiggingFees,\\n        uint256 rewrapSarcophagusProtocolFees\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is buried\\n    /// @param sarcoId Id of sarcophagus that was buried\\n    event BurySarcophagus(bytes32 indexed sarcoId);\\n\\n    /// @notice Parameters of a sarcophagus, supplied during sarcophagus creation\\n    struct SarcophagusParams {\\n        string name;\\n        // highest rewrap interval cursed archaeologists have agreed to accept for lifetime of sarcophagus\\n        uint256 maximumRewrapInterval;\\n        // The timestamp beyond which the sarcophagus can no longer be rewrapped\\n        uint256 maximumResurrectionTime;\\n        address recipientAddress;\\n        uint256 resurrectionTime;\\n        uint8 threshold;\\n        uint256 creationTime;\\n    }\\n\\n    /// @notice Parameters of an archaeologist's curse, supplied during sarcophagus creation\\n    struct CurseParams {\\n        bytes publicKey;\\n        address archAddress;\\n        uint256 diggingFeePerSecond;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an id that is already in use\\n    /// @param sarcoId Id that is already in use\\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with expired parameters\\n    /// @param currentTime Timestamp of the failed create attempt\\n    /// @param creationTime Time when the sarcophagus parameters were created\\n    /// @param creationDeadline Deadline for creation of a sarcophagus with the supplied parameters\\n    error SarcophagusParametersExpired(\\n        uint256 currentTime,\\n        uint256 creationTime,\\n        uint256 creationDeadline\\n    );\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with no archaeologists\\n    error NoArchaeologistsProvided();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a shamir secret sharing threshold of 0\\n    error ThresholdCannotBeZero();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with more required archaeologists than total archaeologists\\n    error ThresholdGreaterThanTotalNumberOfArchaeologists(\\n        uint8 threshold,\\n        uint256 totalNumberOfArchaeologists\\n    );\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an archaeologist list that contains the same archaeologist more than once\\n    error ArchaeologistListContainsDuplicate(address archaeologistAddress);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that has already passed\\n    /// @param currentTime Timestamp of the failed rewrap attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a public key that has already been assigned to another sarcophagus\\n    /// @param publicKey the duplicated public key\\n    error DuplicatePublicKey(bytes publicKey);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that exceeds the maximum rewrap interval\\n    /// @param resurrectionTime Resurrection timestamp which is too far in the future\\n    /// @param sarcophagusMaximumRewrapInterval Maximum rewrap interval set for the sarcophagus\\n    /// @param maximumPermissibleResurrectionTime Resurrection timestamp which is too far in the future\\n    error ResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    /// @notice Emitted when the resurrection time defined during sarcohpagus creation or rewrap goes past the max resurrection time\\n    /// @param resurrectionTime The resurrection time defined during the sarcophagus creation or rewrap\\n    /// @param maxResurrectionTime The maximum allowed resurrection time\\n    error ResurrectionTimePastMaxResurrectionTime(\\n        uint256 resurrectionTime,\\n        uint256 maxResurrectionTime\\n    );\\n\\n    error NewResurrectionTimeInPast(uint256 currentTime, uint256 newResurrectionTime);\\n\\n    error NewResurrectionTimeIsZero();\\n\\n    error NewResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    error ResurrectionTimeTooFarPastPreviousResurrectionTime(\\n        uint256 resurrectionTime,\\n        uint256 previousResurrectionTime\\n    );\\n\\n    /// @notice Creates a sarcophagus with the supplied parameters and locks\\n    /// a portion of each archaeologist's freeBond equal to the digging fees calculated for the duration\\n    /// of the sarcophagus until its resurrection time.\\n    ///\\n    /// Verifies that each supplied archaeologist has signed off on the sarcophagus negotiation parameters:\\n    ///    - `publicKey` that matches the private key the archaeologist is responsible for\\n    ///    - `maximumRewrapInterval` to be enforced for the lifetime of the sarcophagus. No new resurrection time for future rewraps may exceed this interval from time of rewrap.\\n    ///    - `creationTime` of sarcophagus\\n    ///    - `diggingFeePerSecond` agreed to be paid to the archaeologist during the lifetime of the sarcophagus. Constant.\\n    ///\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param sarcophagusParams params to set on sarcophagus being created\\n    /// @param selectedArchaeologists the archaeologists the embalmer has selected to curse\\n    /// @param arweaveTxId id of tx storing the sarcophagus payload on arweave\\n    function createSarcophagus(\\n        bytes32 sarcoId,\\n        SarcophagusParams calldata sarcophagusParams,\\n        CurseParams[] calldata selectedArchaeologists,\\n        string calldata arweaveTxId\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Confirm that sarcophagus with supplied id doesn't already exist\\n        if (s.sarcophagi[sarcoId].resurrectionTime > 0) {\\n            revert SarcophagusAlreadyExists(sarcoId);\\n        }\\n\\n        // Ensure too much time hasn't passed since the sarcophagus `creationTime` that has been signed\\n        // off by its cursed archaeologists.\\n        if (block.timestamp > sarcophagusParams.creationTime + s.expirationThreshold) {\\n            revert SarcophagusParametersExpired(\\n                block.timestamp,\\n                sarcophagusParams.creationTime,\\n                sarcophagusParams.creationTime + s.expirationThreshold\\n            );\\n        }\\n\\n        // Confirm that resurrection time is in the future\\n        if (block.timestamp >= sarcophagusParams.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagusParams.resurrectionTime);\\n        }\\n\\n        // Confirm that resurrection or rewrap will occur before the maximumRewrapInterval elapses\\n        if (\\n            block.timestamp + sarcophagusParams.maximumRewrapInterval <\\n            sarcophagusParams.resurrectionTime\\n        ) {\\n            revert ResurrectionTimeTooFarInFuture(\\n                sarcophagusParams.resurrectionTime,\\n                sarcophagusParams.maximumRewrapInterval,\\n                block.timestamp + sarcophagusParams.maximumRewrapInterval\\n            );\\n        }\\n\\n        // Confirm that the resurrection time is less than the max resurrection time\\n        if (sarcophagusParams.resurrectionTime > sarcophagusParams.maximumResurrectionTime) {\\n            revert ResurrectionTimePastMaxResurrectionTime(\\n                sarcophagusParams.resurrectionTime,\\n                sarcophagusParams.maximumResurrectionTime\\n            );\\n        }\\n\\n        // Validate archaeologist and threshold lengths\\n        if (selectedArchaeologists.length == 0) {\\n            revert NoArchaeologistsProvided();\\n        }\\n\\n        if (sarcophagusParams.threshold == 0) {\\n            revert ThresholdCannotBeZero();\\n        }\\n\\n        // Ensure that k <= n in the effective k-of-n shamir secret sharing scheme\\n        // used to distribute keyshares among archaeologists\\n        if (sarcophagusParams.threshold > selectedArchaeologists.length) {\\n            revert ThresholdGreaterThanTotalNumberOfArchaeologists(\\n                sarcophagusParams.threshold,\\n                selectedArchaeologists.length\\n            );\\n        }\\n\\n        // create the sarcophagus\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n        sarcophagus.name = sarcophagusParams.name;\\n        sarcophagus.threshold = sarcophagusParams.threshold;\\n        sarcophagus.resurrectionTime = sarcophagusParams.resurrectionTime;\\n        sarcophagus.previousRewrapTime = sarcophagusParams.creationTime;\\n        sarcophagus.maximumRewrapInterval = sarcophagusParams.maximumRewrapInterval;\\n        sarcophagus.maximumResurrectionTime = sarcophagusParams.maximumResurrectionTime;\\n        sarcophagus.arweaveTxId = arweaveTxId;\\n        sarcophagus.embalmerAddress = msg.sender;\\n        sarcophagus.recipientAddress = sarcophagusParams.recipientAddress;\\n        sarcophagus.cursedArchaeologistAddresses = new address[](selectedArchaeologists.length);\\n        sarcophagus.cursedBondPercentage = s.cursedBondPercentage;\\n\\n        // track total digging fees due upon creation of sarcophagus\\n        uint256 totalDiggingFees = 0;\\n\\n        for (uint256 i = 0; i < selectedArchaeologists.length; i++) {\\n            LibUtils.revertIfArchProfileDoesNotExist(selectedArchaeologists[i].archAddress);\\n\\n            // Confirm archaeologist isn't already cursed on this sarcophagus (no duplicates)\\n            if (\\n                sarcophagus\\n                    .cursedArchaeologists[selectedArchaeologists[i].archAddress]\\n                    .publicKey\\n                    .length != 0\\n            ) {\\n                revert ArchaeologistListContainsDuplicate(selectedArchaeologists[i].archAddress);\\n            }\\n\\n            // Confirm archaeologist is not re-using a key pair\\n            if (\\n                s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] != address(0)\\n            ) {\\n                revert DuplicatePublicKey(selectedArchaeologists[i].publicKey);\\n            }\\n\\n            LibUtils.verifyArchaeologistSignature(\\n                sarcophagusParams.maximumRewrapInterval,\\n                sarcophagusParams.maximumResurrectionTime,\\n                sarcophagusParams.creationTime,\\n                selectedArchaeologists[i]\\n            );\\n\\n            // Curse the archaeologist on this sarcophagus\\n            uint256 diggingFeesDue = LibBonds.curseArchaeologist(\\n                sarcoId,\\n                selectedArchaeologists[i],\\n                i\\n            );\\n\\n            totalDiggingFees += diggingFeesDue;\\n\\n            // \\\"Consume\\\" this public key so it cannot be reused in the future\\n            s.publicKeyToArchaeologistAddress[\\n                selectedArchaeologists[i].publicKey\\n            ] = selectedArchaeologists[i].archAddress;\\n        }\\n\\n        // Add this sarcophagus id to the embalmer's record\\n        s.embalmerSarcophagi[msg.sender].push(sarcoId);\\n\\n        // Add this sarcophagus id to the recipient's record\\n        s.recipientSarcophagi[sarcophagusParams.recipientAddress].push(sarcoId);\\n\\n        // Transfer totalDiggingFees and the protocolFees in SARCO from embalmer to this contract\\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n        s.totalProtocolFees += protocolFees;\\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\\n\\n        emit CreateSarcophagus(\\n            sarcoId,\\n            sarcophagusParams.name,\\n            sarcophagusParams.resurrectionTime,\\n            msg.sender,\\n            sarcophagusParams.recipientAddress,\\n            sarcophagus.cursedArchaeologistAddresses,\\n            totalDiggingFees,\\n            protocolFees,\\n            arweaveTxId\\n        );\\n    }\\n\\n    /// @notice Updates the resurrectionTime on a sarcophagus. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param resurrectionTime the new resurrection time\\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        if (resurrectionTime == 0) {\\n            revert NewResurrectionTimeIsZero();\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n\\n        // Confirm resurrection time has not yet passed\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time is in future\\n        if (block.timestamp >= resurrectionTime) {\\n            revert NewResurrectionTimeInPast(block.timestamp, resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time doesn't exceed sarcophagus's maximumRewrapInterval\\n        if (block.timestamp + sarcophagus.maximumRewrapInterval < resurrectionTime) {\\n            revert NewResurrectionTimeTooFarInFuture(\\n                resurrectionTime,\\n                sarcophagus.maximumRewrapInterval,\\n                block.timestamp + sarcophagus.maximumRewrapInterval\\n            );\\n        }\\n\\n        // Confirm that the new resurrection time doesn't exceed the maximumResurrectionTime\\n        if (sarcophagus.maximumResurrectionTime < resurrectionTime) {\\n            revert ResurrectionTimePastMaxResurrectionTime(\\n                resurrectionTime,\\n                sarcophagus.maximumResurrectionTime\\n            );\\n        }\\n\\n        // track total digging fees to be paid by embalmer across all archaeologists on the sarcophagus\\n        uint256 totalDiggingFees = 0;\\n\\n        // pay digging fee to each cursed archaeologist on the sarcophagus that has not been accused\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        uint256 cursedBondPercentage = sarcophagus.cursedBondPercentage;\\n\\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n\\n            if (!cursedArchaeologist.isAccused) {\\n                uint256 prevDiggingFees = cursedArchaeologist.diggingFeePerSecond *\\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n                uint256 newDiggingFees = cursedArchaeologist.diggingFeePerSecond *\\n                    (resurrectionTime - block.timestamp);\\n\\n                // If the new digging fees are greater than the previous digging fees, we need to\\n                // increase the archaeologist's locked bond\\n                if (newDiggingFees > prevDiggingFees) {\\n                    uint256 cursedBondIncrease = (newDiggingFees - prevDiggingFees) * cursedBondPercentage / 100;\\n\\n                    // If the previous cycle's rewards can't cover the cursed bond increase, revert\\n                    if (cursedBondIncrease > prevDiggingFees) {\\n                        revert ResurrectionTimeTooFarPastPreviousResurrectionTime(\\n                            resurrectionTime,\\n                            sarcophagus.resurrectionTime\\n                        );\\n                    }\\n\\n                    // Increase the archaeologist's cursed bond\\n                    s\\n                        .archaeologistProfiles[archaeologistAddresses[i]]\\n                        .cursedBond += cursedBondIncrease;\\n\\n                    // Rewards are now previous digging fees - difference\\n                    s.archaeologistRewards[archaeologistAddresses[i]] +=\\n                        prevDiggingFees -\\n                        cursedBondIncrease;\\n                } else if (newDiggingFees < prevDiggingFees) {\\n                    uint256 cursedBondDecrease = (prevDiggingFees - newDiggingFees) * cursedBondPercentage / 100;\\n\\n                    // Decrease archaeologist's cursed bond by the difference\\n                    s.archaeologistProfiles[archaeologistAddresses[i]].cursedBond -= cursedBondDecrease;\\n\\n                    // Increase archaeologist's free bond by the difference\\n                    s.archaeologistProfiles[archaeologistAddresses[i]].freeBond += cursedBondDecrease;\\n\\n                    // Rewards are equal to the previous digging fees\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\\n                } else {\\n                    // Rewards are equal to the previous digging fees\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\\n                }\\n\\n                // Add digging fees due for the new interval\\n                totalDiggingFees += newDiggingFees;\\n            }\\n        }\\n\\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n\\n        // Add the protocol fee to the total protocol fees in storage\\n        s.totalProtocolFees += protocolFees;\\n\\n        // Update the sarcophagus resurrectionTime and previousRewrapTime\\n        sarcophagus.resurrectionTime = resurrectionTime;\\n        sarcophagus.previousRewrapTime = block.timestamp;\\n\\n        // Transfer the new digging fees and protocol fees from embalmer to contract\\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\\n\\n        emit RewrapSarcophagus(sarcoId, resurrectionTime, totalDiggingFees, protocolFees);\\n    }\\n\\n    /// @notice Terminates a sarcophagus by setting its resurrection time to infinity and returning locked\\n    /// bonds to all innocent cursed archaeologists. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    function burySarcophagus(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n        // Confirm that the current resurrection time is in the future\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // for each archaeologist on the sarcophagus, unlock bond and pay digging fees\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n\\n            // if the archaeologist hasn't been accused transfer them their digging fees and return their locked bond\\n            if (!cursedArchaeologist.isAccused) {\\n                LibBonds.freeArchaeologist(sarcoId, archaeologistAddresses[i]);\\n            }\\n        }\\n\\n        // Set resurrection time to infinity\\n        sarcophagus.resurrectionTime = 2 ** 256 - 1;\\n\\n        emit BurySarcophagus(sarcoId);\\n    }\\n}\\n\",\"keccak256\":\"0xddcb0552d95e8a04591df316ee40831bf8f4268ee804423bc1cdc90cc9c84479\",\"license\":\"Unlicense\"},\"contracts/facets/ThirdPartyFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport {LibDiamond} from \\\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\ncontract ThirdPartyFacet {\\n    event AccuseArchaeologist(\\n        bytes32 indexed sarcoId,\\n        address indexed accuser,\\n        uint256 totalSlashedBondDistributed,\\n        uint256 totalDiggingFeesDistributed,\\n        address[] indexed accusedArchAddresses\\n    );\\n\\n    event Clean(bytes32 indexed sarcoId, address indexed cleaner);\\n\\n    /// @notice Clean has been called on a sarcophagus that has already been cleaned\\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a private key on\\n    error SarcophagusAlreadyCleaned(bytes32 sarcoId);\\n\\n    /// @notice Clean has been called before the deadline for archaeologists to publish private keys has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param publishDeadline Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\\n    error TooEarlyForClean(uint256 currentTime, uint256 publishDeadline);\\n\\n    /// @notice Clean has been called by someone other than the admin or embalmer of the sarcophagus\\n    /// @param senderAddress Address of sender\\n    error SenderNotEmbalmerOrAdmin(address senderAddress);\\n\\n    /// @notice Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error EmbalmerClaimWindowPassed(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error TooEarlyForAdminClean(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Emitted when a third party attempts to accuse an archaeologist on a sarcophagus where the resurrection time has already passed\\n    /// @param currentTime Timestamp of the failed accuse attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when accuse is called with an unequal numbers of public keys and signatures\\n    /// @param signatures the number of signatures passed into the accuse call\\n    /// @param publicKeys the number of public keys passed into the accuse call\\n    error DifferentNumberOfSignaturesAndPublicKeys(uint256 signatures, uint256 publicKeys);\\n\\n    /// @notice Emitted when accuse is called with an invalid signature for the supplied sarcoId, paymentAddress, and publicKey\\n    /// @param sarcoId that should have been signed\\n    /// @param paymentAddress payment address that should have been signed\\n    /// @param publicKey publicKey that should be derived from signing key\\n    /// @param signature invalid signature\\n    error InvalidAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes publicKey,\\n        LibTypes.Signature signature\\n    );\\n\\n    /// @notice If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod,\\n    /// their locked bonds and diggingFees may be claimed by either the embalmer or the admin\\n    /// embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will\\n    /// be able to claim remaining locked bond and diggingFees\\n    /// @param sarcoId The identifier of the sarcophagus to clean\\n    function clean(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer or admin\\n        if (msg.sender != sarcophagus.embalmerAddress && msg.sender != LibDiamond.contractOwner()) {\\n            revert SenderNotEmbalmerOrAdmin(msg.sender);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not already been cleaned\\n        if (sarcophagus.isCleaned) {\\n            revert SarcophagusAlreadyCleaned(sarcoId);\\n        }\\n\\n        // Confirm that the resurrectionTime + gracePeriod have passed\\n        if (block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod) {\\n            revert TooEarlyForClean(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\\n        }\\n\\n        // if sender is embalmer, confirm current time is within embalmerClaimWindow\\n        if (\\n            msg.sender == sarcophagus.embalmerAddress &&\\n            block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert EmbalmerClaimWindowPassed(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // if sender is admin, confirm embalmerClaimWindow has passed\\n        if (\\n            msg.sender == LibDiamond.contractOwner() &&\\n            block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert TooEarlyForAdminClean(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // sum of locked bonds and digging fees for all archaeologists that have failed to publish private keys before publish deadline and have not been accused\\n        uint256 totalDiggingFeesAndLockedBonds = 0;\\n\\n        for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]];\\n\\n            // Punish archaeologists that failed to publish their private key in time\\n            if (!cursedArchaeologist.isAccused && cursedArchaeologist.privateKey == 0) {\\n                uint256 diggingFeesDue = cursedArchaeologist.diggingFeePerSecond *\\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n                uint256 cursedBondDue = (diggingFeesDue * sarcophagus.cursedBondPercentage) / 100;\\n                totalDiggingFeesAndLockedBonds += diggingFeesDue + cursedBondDue;\\n\\n                // slash the archaeologist's locked bond for the sarcophagus\\n                LibBonds.decreaseCursedBond(\\n                    sarcophagus.cursedArchaeologistAddresses[i],\\n                    cursedBondDue\\n                );\\n\\n                // track that the archaeologist has had a clean on this sarcophagus\\n                s.archaeologistCleanups[sarcophagus.cursedArchaeologistAddresses[i]].push(sarcoId);\\n            }\\n        }\\n\\n        // Transfer total slashed locked bonds plus digging fees to the embalmer if they are the caller, otherwise add\\n        // this to the contract's protocol fees\\n        if (msg.sender == sarcophagus.embalmerAddress) {\\n            s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFeesAndLockedBonds);\\n        } else {\\n            s.totalProtocolFees += totalDiggingFeesAndLockedBonds;\\n        }\\n\\n        sarcophagus.isCleaned = true;\\n        emit Clean(sarcoId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id\\n     * and payment address generated with the leaked private keys\\n     * If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be\\n     * split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer\\n     *\\n     * If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus\\n     * state will be updated to Accused and bonds for all remaining unaccused archaeologists will be\\n     * returned\\n     *\\n     * @param sarcoId The identifier of the sarcophagus having leaked private keys\\n     * @param publicKeys an array of public keys corresponding to leaked private keys - order must match order of signatures\\n     * @param signatures an array of signatures of the sarcoId and payment address signed by the leaked private keys - order must match order of publicKeys\\n     * @param paymentAddress the address to which rewards should be sent if successful\\n     */\\n    function accuse(\\n        bytes32 sarcoId,\\n        bytes[] calldata publicKeys,\\n        LibTypes.Signature[] calldata signatures,\\n        address paymentAddress\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // verify that current time is not past resurrection time\\n        if (block.timestamp > sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        if (signatures.length != publicKeys.length) {\\n            revert DifferentNumberOfSignaturesAndPublicKeys(signatures.length, publicKeys.length);\\n        }\\n\\n        address[] memory accusedArchAddresses = new address[](signatures.length);\\n\\n        // track the combined locked bond across all archaeologists being accused in this call\\n        uint256 totalCursedBond = 0;\\n        uint256 accusalCount = 0;\\n        for (uint256 i = 0; i < signatures.length; i++) {\\n            if (\\n                !LibUtils.verifyAccusalSignature(\\n                    sarcoId,\\n                    paymentAddress,\\n                    publicKeys[i],\\n                    signatures[i]\\n                )\\n            ) {\\n                revert InvalidAccusalSignature(\\n                    sarcoId,\\n                    paymentAddress,\\n                    publicKeys[i],\\n                    signatures[i]\\n                );\\n            }\\n\\n            // look up the archaeologist responsible for the publicKey\\n            address accusedArchaeologistAddress = s.publicKeyToArchaeologistAddress[publicKeys[i]];\\n            LibTypes.CursedArchaeologist storage accusedArchaeologist = sarcophagus\\n                .cursedArchaeologists[accusedArchaeologistAddress];\\n\\n            // verify the accused archaeologist is cursed on the sarcophagus\\n            if (accusedArchaeologist.publicKey.length == 0) {\\n                revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\\n            }\\n\\n            // if the archaeologist has already been accused on this sarcophagus break without taking action\\n            if (accusedArchaeologist.isAccused) {\\n                break;\\n            }\\n\\n            // mark the archaeologist on the sarcophagus as having been accused\\n            accusedArchaeologist.isAccused = true;\\n            accusedArchAddresses[accusalCount++] = accusedArchaeologistAddress;\\n\\n            uint256 cursedBondDue = ((accusedArchaeologist.diggingFeePerSecond *\\n                (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime)) *\\n                sarcophagus.cursedBondPercentage) / 100;\\n\\n            totalCursedBond += cursedBondDue;\\n\\n            // Slash the offending archaeologists bond\\n            LibBonds.decreaseCursedBond(accusedArchaeologistAddress, cursedBondDue);\\n\\n            // Save this accusal against the archaeologist\\n            s.archaeologistAccusals[accusedArchaeologistAddress].push(sarcoId);\\n        }\\n\\n        // if none of the accusals were valid because the archaeologists have all already been accused, return without taking action\\n        if (accusalCount == 0) {\\n            return;\\n        }\\n\\n        // the sarcophagus is compromised if the current call has successfully accused the sss threshold of archaeologists\\n        if (accusalCount >= sarcophagus.threshold) {\\n            sarcophagus.isCompromised = true;\\n        } else {\\n            // if the current call hasn't resulted in at least sss threshold archaeologists being accused\\n            // check if total number of historical accusals on sarcophagus is greater than threshold\\n            uint256 totalAccusals = 0;\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                if (\\n                    sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    totalAccusals++;\\n                }\\n            }\\n            // the sarcophagus is compromised if k or more archaeologists have been accused over the lifetime of the sarcophagus\\n            if (totalAccusals >= sarcophagus.threshold) {\\n                sarcophagus.isCompromised = true;\\n            }\\n        }\\n\\n        // if k or more archaeologists have been accused over the lifetime of the sarcophagus, funds should\\n        // be returned to the remaining well behaved archaeologists\\n        if (sarcophagus.isCompromised) {\\n            // iterate through all archaeologist addresses on the sarcophagus\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                // if the archaeologist has never been accused, release their locked bond back to them\\n                if (\\n                    !sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    LibBonds.freeArchaeologist(\\n                        sarcoId,\\n                        sarcophagus.cursedArchaeologistAddresses[i]\\n                    );\\n                }\\n            }\\n        }\\n\\n        uint256 halfTotalCursedBond = totalCursedBond / 2;\\n        uint256 totalDiggingFees = totalCursedBond / (sarcophagus.cursedBondPercentage / 100);\\n        // transfer the cursed half, plus the current digging fees, to the embalmer\\n        s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFees + halfTotalCursedBond);\\n\\n        // transfer the other half of the cursed bond to the transaction caller\\n        s.sarcoToken.transfer(paymentAddress, halfTotalCursedBond);\\n\\n        emit AccuseArchaeologist(\\n            sarcoId,\\n            msg.sender,\\n            totalCursedBond,\\n            totalDiggingFees,\\n            accusedArchAddresses\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x29011ebc75e462be0ab0ac5ff6ab039ecc55b37f8e5e5ce3cf1229c6efcb907f\",\"license\":\"Unlicense\"},\"contracts/libraries/LibBonds.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"./LibErrors.sol\\\";\\n\\nimport \\\"../facets/EmbalmerFacet.sol\\\";\\n\\nlibrary LibBonds {\\n    /// @notice Decreases the amount stored in the freeBond mapping for an\\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\\n    /// the amount.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being decreased\\n    /// @param amount The amount to decrease the free bond by\\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current free bond\\n        if (amount > s.archaeologistProfiles[archaeologist].freeBond) {\\n            revert LibErrors.NotEnoughFreeBond(\\n                s.archaeologistProfiles[archaeologist].freeBond,\\n                amount\\n            );\\n        }\\n\\n        // Decrease the free bond amount\\n        s.archaeologistProfiles[archaeologist].freeBond -= amount;\\n    }\\n\\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\\n    /// archaeologist, without respectively increasing their free bond.\\n    /// @param archaeologist The address of the archaeologist\\n    /// @param amount The amount to slash\\n    function decreaseCursedBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current cursed bond\\n        if (amount > s.archaeologistProfiles[archaeologist].cursedBond) {\\n            revert LibErrors.NotEnoughCursedBond(\\n                s.archaeologistProfiles[archaeologist].cursedBond,\\n                amount\\n            );\\n        }\\n\\n        s.archaeologistProfiles[archaeologist].cursedBond -= amount;\\n    }\\n\\n    /// @notice Bonds the archaeologist to a sarcophagus.\\n    /// This does the following:\\n    ///   - adds the archaeologist's curse params and address to the sarcophagus\\n    ///   - calculates digging fees to be locked and later paid to archaeologist\\n    ///   - locks this amount from archaeologist's free bond; increases cursedBond by same\\n    ///   - Adds the sarcophagus' id to the archaeologist's record of bonded sarcophagi\\n    /// @param sarcoId Id of the sarcophagus with which to curse the archaeologist\\n    /// @param archaeologist The archaologist to curse, with associated parameters of the curse\\n    ///\\n    /// @return the amount of digging fees due the embalmer for this curse\\n    function curseArchaeologist(\\n        bytes32 sarcoId,\\n        EmbalmerFacet.CurseParams calldata archaeologist,\\n        uint256 index\\n    ) internal returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        sarcophagus.cursedArchaeologists[archaeologist.archAddress] = LibTypes.CursedArchaeologist({\\n            publicKey: archaeologist.publicKey,\\n            privateKey: 0,\\n            isAccused: false,\\n            diggingFeePerSecond: archaeologist.diggingFeePerSecond\\n        });\\n        sarcophagus.cursedArchaeologistAddresses[index] = archaeologist.archAddress;\\n\\n        // Calculate digging fees due for this time period (creationTime/previousRewrapTime -> resurrectionTime)\\n        uint256 diggingFeesDue = archaeologist.diggingFeePerSecond *\\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n        // Use cursed bond percentage to determine how much bond to lock up\\n        uint256 bondToCurse = (diggingFeesDue * s.cursedBondPercentage) / 100;\\n\\n        decreaseFreeBond(archaeologist.archAddress, bondToCurse);\\n        s.archaeologistProfiles[archaeologist.archAddress].cursedBond += bondToCurse;\\n\\n        s.archaeologistSarcophagi[archaeologist.archAddress].push(sarcoId);\\n\\n        return diggingFeesDue;\\n    }\\n\\n    /// @notice Calculates and unlocks an archaeologist's cursed bond. Pays due digging fees to the archaeologist.\\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\\n    /// @param archaeologistAddress the address of the archaeologist to free\\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\\n            .sarcophagi[sarcoId]\\n            .cursedArchaeologists[archaeologistAddress];\\n\\n        uint256 diggingFeeAmount = cursedArchaeologist.diggingFeePerSecond *\\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n        uint256 cursedBondAmount = diggingFeeAmount * sarcophagus.cursedBondPercentage / 100;\\n\\n        decreaseCursedBond(archaeologistAddress, cursedBondAmount);\\n        s.archaeologistProfiles[archaeologistAddress].freeBond += cursedBondAmount;\\n        s.archaeologistRewards[archaeologistAddress] += diggingFeeAmount;\\n    }\\n}\\n\",\"keccak256\":\"0xb5473904e43e2e8ef1e4dec6f2665ce1820ee9ae672d17a32b30ab676224822f\",\"license\":\"Unlicense\"},\"contracts/libraries/LibErrors.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title A collection of Errors\\n * @notice This library defines all of the Errors that the Sarcophagus system\\n * uses.\\n */\\nlibrary LibErrors {\\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\\n\\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\\n\\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\\n\\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\\n\\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\\n\\n    error SarcophagusInactive(bytes32 sarcoId);\\n\\n    error SarcophagusCompromised(bytes32 sarcoId);\\n\\n    error SenderNotEmbalmer(address sender, address embalmer);\\n\\n    error InvalidSignature(\\n        // address recovered from signature via ecrecover\\n        address recoveredAddress,\\n        // address we expected to have signed the data\\n        address expectedAddress\\n    );\\n}\\n\",\"keccak256\":\"0xe2e2e99c7e608571b8d072ceacc037b744ca637ad66633af1c2f10e935eb8567\",\"license\":\"Unlicense\"},\"contracts/libraries/LibPrivateKeys.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n\\n/**\\n * @title Private key verification\\n * @notice Implements a private key -> public key checking function\\n * @dev modified from https://github.com/1Address/ecsol, removes extra code\\n * which isn't necessary for our Sarcophagus implementation\\n */\\nlibrary LibPrivateKeys {\\n    /**\\n     * @notice Given a private key and a public key, determines if that public\\n     * key was derived from the private key\\n     * @dev based on https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n     * @param privKey an secp256k1 private key\\n     * @param pubKey an uncompressed 65 byte secp256k1 public key\\n     * @return bool indicating whether the public key is derived from the\\n     * private key\\n     */\\n    function isPublicKeyOfPrivateKey(bytes32 privKey, bytes storage pubKey) internal view returns (bool) {\\n        // removes the 0x04 prefix from an uncompressed public key\\n        bytes memory truncatedPublicKey = new bytes(pubKey.length-1);\\n        for (uint256 i = 1; i < pubKey.length; i++) {\\n            truncatedPublicKey[i-1] = pubKey[i];\\n        }\\n\\n        // generator point coordinates and order of secp256k1\\n        uint256 gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\\n        uint256 gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\\n        uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\\n\\n        address signer = ecrecover(\\n            0,\\n            gy % 2 != 0 ? 28 : 27,\\n            bytes32(gx),\\n            bytes32(mulmod(uint256(privKey), gx, m))\\n        );\\n\\n        address xyAddress = address(\\n            uint160(uint256(keccak256(truncatedPublicKey)) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        );\\n        return xyAddress == signer;\\n    }\\n}\\n\",\"keccak256\":\"0xd09b1a4699f04a34db00d8476900583681e7e714272f93b555873708a29a5416\",\"license\":\"MIT\"},\"contracts/libraries/LibTypes.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title Types shared across facets for the Sarcophagus diamond\\n */\\nlibrary LibTypes {\\n    struct Sarcophagus {\\n        // Also used for existence checks -- does not exist if 0\\n        uint256 resurrectionTime;\\n        uint256 previousRewrapTime;\\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\\n        bool isCompromised;\\n        bool isCleaned;\\n        uint8 threshold;\\n        string name;\\n        uint256 maximumRewrapInterval;\\n        uint256 maximumResurrectionTime;\\n        string arweaveTxId;\\n        address embalmerAddress;\\n        address recipientAddress;\\n        address[] cursedArchaeologistAddresses;\\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\\n        uint256 cursedBondPercentage;\\n    }\\n\\n    struct CursedArchaeologist {\\n        uint256 diggingFeePerSecond;\\n        // Also used for publish checks -- has not published if 0\\n        bytes32 privateKey;\\n        // Also used for curse checks -- is not bonded if length is 0\\n        bytes publicKey;\\n        bool isAccused;\\n    }\\n\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    struct ArchaeologistProfile {\\n        // Also used for existence checks -- does not exist if 0\\n        uint256 maximumRewrapInterval;\\n        uint256 maximumResurrectionTime;\\n        string peerId;\\n        uint256 minimumDiggingFeePerSecond;\\n        uint256 freeBond;\\n        uint256 cursedBond;\\n    }\\n}\\n\",\"keccak256\":\"0xb6ded0e9a252560ab14a589c47df996bcf1f0b9cd4910aa1bf0da6fd01c99232\",\"license\":\"Unlicense\"},\"contracts/libraries/LibUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport \\\"../facets/ThirdPartyFacet.sol\\\";\\nimport \\\"./LibTypes.sol\\\";\\nimport \\\"../facets/EmbalmerFacet.sol\\\";\\n\\n/**\\n * @title Utility functions used within the Sarcophagus system\\n * @notice This library implements various functions that are used throughout\\n * Sarcophagus, mainly to DRY up the codebase\\n * @dev these functions are all stateless, public, pure/view\\n */\\nlibrary LibUtils {\\n    /**\\n     * @notice The archaeologist needs to sign off on two pieces of data\\n     * to guarantee their unrwap will be successful\\n     *\\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\\n     * @param curseParams parameters of curse signed by archaeologist\\n     */\\n    function verifyArchaeologistSignature(\\n        uint256 agreedMaximumRewrapInterval,\\n        uint256 maximumResurrectionTime,\\n        uint256 timestamp,\\n        EmbalmerFacet.CurseParams calldata curseParams\\n    ) internal pure {\\n        // Hash the hash of the data payload\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encode(\\n                        curseParams.publicKey,\\n                        agreedMaximumRewrapInterval,\\n                        maximumResurrectionTime,\\n                        curseParams.diggingFeePerSecond,\\n                        timestamp\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Generate the address from the signature.\\n        // ecrecover should always return a valid address.\\n        address recoveredAddress = ecrecover(\\n            messageHash,\\n            curseParams.v,\\n            curseParams.r,\\n            curseParams.s\\n        );\\n\\n        if (recoveredAddress != curseParams.archAddress) {\\n            revert LibErrors.InvalidSignature(recoveredAddress, curseParams.archAddress);\\n        }\\n    }\\n\\n    /// @notice Verifies that a signature and public key were created from the same private key\\n    /// @param sarcoId the sarcoId that was signed\\n    /// @param paymentAddress the payment address that was signed\\n    /// @param publicKey an uncompressed 65 byte secp256k1 public key\\n    /// @param signature signature on the sarco id and payment address\\n    /// @return true if the signature was signed by the private key corresponding to the supplied public key\\n    function verifyAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes calldata publicKey,\\n        LibTypes.Signature calldata signature\\n    ) internal pure returns (bool) {\\n        // removes the 0x04 prefix from an uncompressed public key\\n        bytes memory truncatedPublicKey = new bytes(publicKey.length - 1);\\n        for (uint256 i = 1; i < publicKey.length; i++) {\\n            truncatedPublicKey[i - 1] = publicKey[i];\\n        }\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(abi.encode(sarcoId, paymentAddress))\\n            )\\n        );\\n        // Use ecrecover to get the address that signed the message\\n        address signingAddress = ecrecover(messageHash, signature.v, signature.r, signature.s);\\n\\n        address publicKeyAddress = address(\\n            uint160(\\n                uint256(keccak256(truncatedPublicKey)) &\\n                    0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n            )\\n        );\\n\\n        return signingAddress == publicKeyAddress;\\n    }\\n\\n    /// @notice Checks if an archaeologist profile exists and\\n    /// reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check existence of\\n    function revertIfArchProfileExists(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval != 0) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Checks if an archaeologist profile doesn't exist and reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check lack of existence of\\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval == 0) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\\n    /// @param totalDiggingFees to be paid. Protocol fee is a percentage of this\\n    /// @return The protocol fees amount\\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 100;\\n    }\\n}\\n\",\"keccak256\":\"0xfb87b9c1495d1044d9bf70a5a67bcc6e798b6584159a3df9c5a0ab297c693612\",\"license\":\"Unlicense\"},\"contracts/storage/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\n/**\\n * Global diamond storage struct to be shared across facets\\n * TODO: Implement diamond storage pattern and consider splitting storage into facet specific structs\\n */\\nstruct AppStorage {\\n    // SARCO token contract\\n    IERC20 sarcoToken;\\n    // total protocol fees available to be withdrawn by the admin\\n    uint256 totalProtocolFees;\\n    /**\\n     * Protocol level admin configurations\\n     */\\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap\\n    uint256 protocolFeeBasePercentage;\\n    // % of digging fees archaeologists must have locked up per curse in cursed bond\\n    uint256 cursedBondPercentage;\\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time\\n    uint256 gracePeriod;\\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated\\n    uint256 expirationThreshold;\\n    // window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\\n    uint256 embalmerClaimWindow;\\n\\n    // registered archaeologist addresses\\n    address[] archaeologistProfileAddresses;\\n\\n    /**\\n     * Ownership mappings\\n     */\\n    // embalmer address => ids of sarcophagi they've created\\n    mapping(address => bytes32[]) embalmerSarcophagi;\\n    // archaeologist address =>  ids of sarcophagi they're protecting\\n    mapping(address => bytes32[]) archaeologistSarcophagi;\\n    // recipient address =>  ids of sarcophagi they're recipient on\\n    mapping(address => bytes32[]) recipientSarcophagi;\\n    // public key => archaeologist address\\n    mapping(bytes => address) publicKeyToArchaeologistAddress;\\n    // sarcophagus id => sarcophagus object\\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\\n    // archaeologist address => profile\\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\\n    // current balance of rewards available for the archaeologist to withdraw\\n    mapping(address => uint256) archaeologistRewards;\\n    /**\\n     * Archaeologist reputation statistics: address => sarcoIds\\n     * todo: could these be organized differently?\\n     */\\n    mapping(address => bytes32[]) archaeologistSuccesses;\\n    mapping(address => bytes32[]) archaeologistAccusals;\\n    mapping(address => bytes32[]) archaeologistCleanups;\\n}\\n\\nlibrary LibAppStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"sarcophagus.storage.SarcophagusGoerliTest\\\");\\n\\n    function getAppStorage() internal pure returns (AppStorage storage s) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6b62d6888aeeffbb62ca7fb8a41cccd06524fbe1fc8df144b6f3089983c06564\",\"license\":\"Unlicense\"},\"hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x2205345e83eb86f5281f159a9215a096cb6d404782619f9b8e9d7a4a46c32a37\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506121df806100206000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c8063364e0801146100675780636a5ac74c146100835780637f06727a1461009f5780638355a17b146100bb578063a4110dbe146100d7578063c885bc58146100f3575b600080fd5b610081600480360381019061007c9190611751565b6100fd565b005b61009d60048036038101906100989190611751565b610211565b005b6100b960048036038101906100b491906118c4565b610378565b005b6100d560048036038101906100d091906118c4565b6105c8565b005b6100f160048036038101906100ec9190611991565b610870565b005b6100fb610ccb565b005b6000610107610e59565b905061011233610e86565b61011c3383610f22565b8060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33846040518363ffffffff1660e01b815260040161017b929190611a21565b6020604051808303816000875af115801561019a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101be9190611a82565b503373ffffffffffffffffffffffffffffffffffffffff167fd91b1e491a880123721b161dbbf8249668b0c546077d7ba4d0016441ca9d8f45836040516102059190611aaf565b60405180910390a25050565b600061021b610e59565b905061022633610e86565b8181600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600401600082825461027a9190611af9565b925050819055508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330856040518463ffffffff1660e01b81526004016102e293929190611b4f565b6020604051808303816000875af1158015610301573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103259190611a82565b503373ffffffffffffffffffffffffffffffffffffffff167ff882a0847c57aefe6f6c7df2098dd0afd122eb0e886199e223651b8e45fda8238360405161036c9190611aaf565b60405180910390a25050565b6000610382610e59565b905061038d33610e86565b600084148061039c5750600085145b156103d3576040517fdec9919f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600081600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905086816002019080519060200190610430929190611664565b508581600301819055508481600001819055508281600101819055506000841115610556578382600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546104a99190611af9565b925050819055508160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330876040518463ffffffff1660e01b815260040161051193929190611b4f565b6020604051808303816000875af1158015610530573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105549190611a82565b505b3373ffffffffffffffffffffffffffffffffffffffff167f8937618657bc05b4e1f529d147029377f8e0e6886ecf59183d212f263bd1bfa18260020183600301548460000154856004015486600101546040516105b7959493929190611c8c565b60405180910390a250505050505050565b60006105d2610e59565b90506105dd3361105d565b60008414806105ec5750600085145b15610623576040517fdec9919f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006040518060c00160405280868152602001848152602001888152602001878152602001858152602001600081525090506000841115610704578160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330876040518463ffffffff1660e01b81526004016106bf93929190611b4f565b6020604051808303816000875af11580156106de573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107029190611a82565b505b8082600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000155602082015181600101556040820151816002019080519060200190610776929190611664565b50606082015181600301556080820151816004015560a0820151816005015590505081600701339080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167f4d7b40490f4c8e19031e2c3248c8e1da3d74d5779beb3b7e2d7295194a58edd98260400151836060015184600001518560800151866020015160405161085f959493929190611d5d565b60405180910390a250505050505050565b600061087a610e59565b9050600081600c016000858152602001908152602001600020905060008160000154036108de57836040517f018da6880000000000000000000000000000000000000000000000000000000081526004016108d59190611dc6565b60405180910390fd5b8060020160009054906101000a900460ff161561093257836040517f9af72b860000000000000000000000000000000000000000000000000000000081526004016109299190611dc6565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81600001540361099a57836040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016109919190611dc6565b60405180910390fd5b80600001544210156109e9574281600001546040517f482768090000000000000000000000000000000000000000000000000000000081526004016109e0929190611de1565b60405180910390fd5b816004015481600001546109fd9190611af9565b421115610a56574282600401548260000154610a199190611af9565b6040517f4ccffab1000000000000000000000000000000000000000000000000000000008152600401610a4d929190611de1565b60405180910390fd5b600082600c016000868152602001908152602001600020600a0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000816002018054610ac090611bb5565b905003610b0457336040517f82881f03000000000000000000000000000000000000000000000000000000008152600401610afb9190611e0a565b60405180910390fd5b8060030160009054906101000a900460ff1615610b5a5733856040517fa40b4423000000000000000000000000000000000000000000000000000000008152600401610b51929190611e25565b60405180910390fd5b6000801b816001015414610ba557336040517f7b06b177000000000000000000000000000000000000000000000000000000008152600401610b9c9190611e0a565b60405180910390fd5b610bb284826002016110f9565b610bfa573381600201856040517f5a95e91c000000000000000000000000000000000000000000000000000000008152600401610bf193929190611ef4565b60405180910390fd5b838160010181905550610c0d853361139e565b82600f0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208590806001815401808255809150506001900390600052602060002001600090919091909150553373ffffffffffffffffffffffffffffffffffffffff16857f110eca32dd0b1dbdeaa29671186ba025abb2a6d9c193469a7214ee3244ef740486604051610cbc9190611dc6565b60405180910390a35050505050565b6000610cd5610e59565b9050600081600e0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050600082600e0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33836040518363ffffffff1660e01b8152600401610dc3929190611a21565b6020604051808303816000875af1158015610de2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e069190611a82565b503373ffffffffffffffffffffffffffffffffffffffff167fbc84835063c693975166f00cffb19f01a94c2db55b1bf259238c5da3594e506682604051610e4d9190611aaf565b60405180910390a25050565b6000807f1464b352a39efde2dd07892d0f2f274ce8052e8749182fc4ead14ba82366194490508091505090565b6000610e90610e59565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015403610f1e576001826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401610f15929190611f41565b60405180910390fd5b5050565b6000610f2c610e59565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154821115610ffd5780600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154826040517fa4e3bead000000000000000000000000000000000000000000000000000000008152600401610ff4929190611de1565b60405180910390fd5b8181600d0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546110519190611f6a565b92505081905550505050565b6000611067610e59565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000154146110f5576000826040517f2eeb35710000000000000000000000000000000000000000000000000000000081526004016110ec929190611f41565b60405180910390fd5b5050565b600080600183805461110a90611bb5565b90506111169190611f6a565b67ffffffffffffffff81111561112f5761112e611799565b5b6040519080825280601f01601f1916602001820160405280156111615781602001600182028036833780820191505090505b5090506000600190505b83805461117790611bb5565b9050811015611242578381815461118d90611bb5565b811061119c5761119b611f9e565b5b8154600116156111bb5790600052602060002090602091828204019190065b9054901a7f010000000000000000000000000000000000000000000000000000000000000002826001836111ef9190611f6a565b81518110611200576111ff611f9e565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061123a90611fcd565b91505061116b565b5060007f79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798905060007f483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8905060007ffffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd03641419050600060016000806002866112c69190612044565b036112d257601b6112d5565b601c5b8660001b85806112e8576112e7612015565b5b888d60001c0960001b6040516000815260200160405260405161130e94939291906120d9565b6020604051602081039080840390855afa158015611330573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff868051906020012060001c1690508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614965050505050505092915050565b60006113a8610e59565b9050600081600c0160008581526020019081526020016000209050600082600c016000868152602001908152602001600020600a0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000826001015483600001546114329190611f6a565b8260000154611441919061211e565b90506000606484600b015483611457919061211e565b6114619190612178565b905061146d8682611529565b8085600d0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546114c19190611af9565b925050819055508185600e0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546115199190611af9565b9250508190555050505050505050565b6000611533610e59565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600501548211156116045780600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154826040517faf5a111b0000000000000000000000000000000000000000000000000000000081526004016115fb929190611de1565b60405180910390fd5b8181600d0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546116589190611f6a565b92505081905550505050565b82805461167090611bb5565b90600052602060002090601f01602090048101928261169257600085556116d9565b82601f106116ab57805160ff19168380011785556116d9565b828001600101855582156116d9579182015b828111156116d85782518255916020019190600101906116bd565b5b5090506116e691906116ea565b5090565b5b808211156117035760008160009055506001016116eb565b5090565b6000604051905090565b600080fd5b600080fd5b6000819050919050565b61172e8161171b565b811461173957600080fd5b50565b60008135905061174b81611725565b92915050565b60006020828403121561176757611766611711565b5b60006117758482850161173c565b91505092915050565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6117d182611788565b810181811067ffffffffffffffff821117156117f0576117ef611799565b5b80604052505050565b6000611803611707565b905061180f82826117c8565b919050565b600067ffffffffffffffff82111561182f5761182e611799565b5b61183882611788565b9050602081019050919050565b82818337600083830152505050565b600061186761186284611814565b6117f9565b90508281526020810184848401111561188357611882611783565b5b61188e848285611845565b509392505050565b600082601f8301126118ab576118aa61177e565b5b81356118bb848260208601611854565b91505092915050565b600080600080600060a086880312156118e0576118df611711565b5b600086013567ffffffffffffffff8111156118fe576118fd611716565b5b61190a88828901611896565b955050602061191b8882890161173c565b945050604061192c8882890161173c565b935050606061193d8882890161173c565b925050608061194e8882890161173c565b9150509295509295909350565b6000819050919050565b61196e8161195b565b811461197957600080fd5b50565b60008135905061198b81611965565b92915050565b600080604083850312156119a8576119a7611711565b5b60006119b68582860161197c565b92505060206119c78582860161197c565b9150509250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006119fc826119d1565b9050919050565b611a0c816119f1565b82525050565b611a1b8161171b565b82525050565b6000604082019050611a366000830185611a03565b611a436020830184611a12565b9392505050565b60008115159050919050565b611a5f81611a4a565b8114611a6a57600080fd5b50565b600081519050611a7c81611a56565b92915050565b600060208284031215611a9857611a97611711565b5b6000611aa684828501611a6d565b91505092915050565b6000602082019050611ac46000830184611a12565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611b048261171b565b9150611b0f8361171b565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115611b4457611b43611aca565b5b828201905092915050565b6000606082019050611b646000830186611a03565b611b716020830185611a03565b611b7e6040830184611a12565b949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611bcd57607f821691505b602082108103611be057611bdf611b86565b5b50919050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b60008154611c1981611bb5565b611c238186611be6565b94506001821660008114611c3e5760018114611c5057611c83565b60ff1983168652602086019350611c83565b611c5985611bf7565b60005b83811015611c7b57815481890152600182019150602081019050611c5c565b808801955050505b50505092915050565b600060a0820190508181036000830152611ca68188611c0c565b9050611cb56020830187611a12565b611cc26040830186611a12565b611ccf6060830185611a12565b611cdc6080830184611a12565b9695505050505050565b600081519050919050565b60005b83811015611d0f578082015181840152602081019050611cf4565b83811115611d1e576000848401525b50505050565b6000611d2f82611ce6565b611d398185611be6565b9350611d49818560208601611cf1565b611d5281611788565b840191505092915050565b600060a0820190508181036000830152611d778188611d24565b9050611d866020830187611a12565b611d936040830186611a12565b611da06060830185611a12565b611dad6080830184611a12565b9695505050505050565b611dc08161195b565b82525050565b6000602082019050611ddb6000830184611db7565b92915050565b6000604082019050611df66000830185611a12565b611e036020830184611a12565b9392505050565b6000602082019050611e1f6000830184611a03565b92915050565b6000604082019050611e3a6000830185611a03565b611e476020830184611db7565b9392505050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b60008154611e8181611bb5565b611e8b8186611e4e565b94506001821660008114611ea65760018114611eb857611eeb565b60ff1983168652602086019350611eeb565b611ec185611e5f565b60005b83811015611ee357815481890152600182019150602081019050611ec4565b808801955050505b50505092915050565b6000606082019050611f096000830186611a03565b8181036020830152611f1b8185611e74565b9050611f2a6040830184611db7565b949350505050565b611f3b81611a4a565b82525050565b6000604082019050611f566000830185611f32565b611f636020830184611a03565b9392505050565b6000611f758261171b565b9150611f808361171b565b925082821015611f9357611f92611aca565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000611fd88261171b565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361200a57612009611aca565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061204f8261171b565b915061205a8361171b565b92508261206a57612069612015565b5b828206905092915050565b6000819050919050565b60008160001b9050919050565b60006120a76120a261209d84612075565b61207f565b61195b565b9050919050565b6120b78161208c565b82525050565b600060ff82169050919050565b6120d3816120bd565b82525050565b60006080820190506120ee60008301876120ae565b6120fb60208301866120ca565b6121086040830185611db7565b6121156060830184611db7565b95945050505050565b60006121298261171b565b91506121348361171b565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561216d5761216c611aca565b5b828202905092915050565b60006121838261171b565b915061218e8361171b565b92508261219e5761219d612015565b5b82820490509291505056fea26469706673582212202b57532e4ac5d4fdfabf8d63a5a79e1b985a12583c79d8a6f8f4f565789fce4164736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100625760003560e01c8063364e0801146100675780636a5ac74c146100835780637f06727a1461009f5780638355a17b146100bb578063a4110dbe146100d7578063c885bc58146100f3575b600080fd5b610081600480360381019061007c9190611751565b6100fd565b005b61009d60048036038101906100989190611751565b610211565b005b6100b960048036038101906100b491906118c4565b610378565b005b6100d560048036038101906100d091906118c4565b6105c8565b005b6100f160048036038101906100ec9190611991565b610870565b005b6100fb610ccb565b005b6000610107610e59565b905061011233610e86565b61011c3383610f22565b8060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33846040518363ffffffff1660e01b815260040161017b929190611a21565b6020604051808303816000875af115801561019a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101be9190611a82565b503373ffffffffffffffffffffffffffffffffffffffff167fd91b1e491a880123721b161dbbf8249668b0c546077d7ba4d0016441ca9d8f45836040516102059190611aaf565b60405180910390a25050565b600061021b610e59565b905061022633610e86565b8181600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600401600082825461027a9190611af9565b925050819055508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330856040518463ffffffff1660e01b81526004016102e293929190611b4f565b6020604051808303816000875af1158015610301573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103259190611a82565b503373ffffffffffffffffffffffffffffffffffffffff167ff882a0847c57aefe6f6c7df2098dd0afd122eb0e886199e223651b8e45fda8238360405161036c9190611aaf565b60405180910390a25050565b6000610382610e59565b905061038d33610e86565b600084148061039c5750600085145b156103d3576040517fdec9919f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600081600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905086816002019080519060200190610430929190611664565b508581600301819055508481600001819055508281600101819055506000841115610556578382600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546104a99190611af9565b925050819055508160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330876040518463ffffffff1660e01b815260040161051193929190611b4f565b6020604051808303816000875af1158015610530573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105549190611a82565b505b3373ffffffffffffffffffffffffffffffffffffffff167f8937618657bc05b4e1f529d147029377f8e0e6886ecf59183d212f263bd1bfa18260020183600301548460000154856004015486600101546040516105b7959493929190611c8c565b60405180910390a250505050505050565b60006105d2610e59565b90506105dd3361105d565b60008414806105ec5750600085145b15610623576040517fdec9919f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006040518060c00160405280868152602001848152602001888152602001878152602001858152602001600081525090506000841115610704578160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330876040518463ffffffff1660e01b81526004016106bf93929190611b4f565b6020604051808303816000875af11580156106de573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107029190611a82565b505b8082600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000155602082015181600101556040820151816002019080519060200190610776929190611664565b50606082015181600301556080820151816004015560a0820151816005015590505081600701339080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167f4d7b40490f4c8e19031e2c3248c8e1da3d74d5779beb3b7e2d7295194a58edd98260400151836060015184600001518560800151866020015160405161085f959493929190611d5d565b60405180910390a250505050505050565b600061087a610e59565b9050600081600c016000858152602001908152602001600020905060008160000154036108de57836040517f018da6880000000000000000000000000000000000000000000000000000000081526004016108d59190611dc6565b60405180910390fd5b8060020160009054906101000a900460ff161561093257836040517f9af72b860000000000000000000000000000000000000000000000000000000081526004016109299190611dc6565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81600001540361099a57836040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016109919190611dc6565b60405180910390fd5b80600001544210156109e9574281600001546040517f482768090000000000000000000000000000000000000000000000000000000081526004016109e0929190611de1565b60405180910390fd5b816004015481600001546109fd9190611af9565b421115610a56574282600401548260000154610a199190611af9565b6040517f4ccffab1000000000000000000000000000000000000000000000000000000008152600401610a4d929190611de1565b60405180910390fd5b600082600c016000868152602001908152602001600020600a0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000816002018054610ac090611bb5565b905003610b0457336040517f82881f03000000000000000000000000000000000000000000000000000000008152600401610afb9190611e0a565b60405180910390fd5b8060030160009054906101000a900460ff1615610b5a5733856040517fa40b4423000000000000000000000000000000000000000000000000000000008152600401610b51929190611e25565b60405180910390fd5b6000801b816001015414610ba557336040517f7b06b177000000000000000000000000000000000000000000000000000000008152600401610b9c9190611e0a565b60405180910390fd5b610bb284826002016110f9565b610bfa573381600201856040517f5a95e91c000000000000000000000000000000000000000000000000000000008152600401610bf193929190611ef4565b60405180910390fd5b838160010181905550610c0d853361139e565b82600f0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208590806001815401808255809150506001900390600052602060002001600090919091909150553373ffffffffffffffffffffffffffffffffffffffff16857f110eca32dd0b1dbdeaa29671186ba025abb2a6d9c193469a7214ee3244ef740486604051610cbc9190611dc6565b60405180910390a35050505050565b6000610cd5610e59565b9050600081600e0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050600082600e0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33836040518363ffffffff1660e01b8152600401610dc3929190611a21565b6020604051808303816000875af1158015610de2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e069190611a82565b503373ffffffffffffffffffffffffffffffffffffffff167fbc84835063c693975166f00cffb19f01a94c2db55b1bf259238c5da3594e506682604051610e4d9190611aaf565b60405180910390a25050565b6000807f1464b352a39efde2dd07892d0f2f274ce8052e8749182fc4ead14ba82366194490508091505090565b6000610e90610e59565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015403610f1e576001826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401610f15929190611f41565b60405180910390fd5b5050565b6000610f2c610e59565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154821115610ffd5780600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154826040517fa4e3bead000000000000000000000000000000000000000000000000000000008152600401610ff4929190611de1565b60405180910390fd5b8181600d0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546110519190611f6a565b92505081905550505050565b6000611067610e59565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000154146110f5576000826040517f2eeb35710000000000000000000000000000000000000000000000000000000081526004016110ec929190611f41565b60405180910390fd5b5050565b600080600183805461110a90611bb5565b90506111169190611f6a565b67ffffffffffffffff81111561112f5761112e611799565b5b6040519080825280601f01601f1916602001820160405280156111615781602001600182028036833780820191505090505b5090506000600190505b83805461117790611bb5565b9050811015611242578381815461118d90611bb5565b811061119c5761119b611f9e565b5b8154600116156111bb5790600052602060002090602091828204019190065b9054901a7f010000000000000000000000000000000000000000000000000000000000000002826001836111ef9190611f6a565b81518110611200576111ff611f9e565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808061123a90611fcd565b91505061116b565b5060007f79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798905060007f483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8905060007ffffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd03641419050600060016000806002866112c69190612044565b036112d257601b6112d5565b601c5b8660001b85806112e8576112e7612015565b5b888d60001c0960001b6040516000815260200160405260405161130e94939291906120d9565b6020604051602081039080840390855afa158015611330573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff868051906020012060001c1690508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614965050505050505092915050565b60006113a8610e59565b9050600081600c0160008581526020019081526020016000209050600082600c016000868152602001908152602001600020600a0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000826001015483600001546114329190611f6a565b8260000154611441919061211e565b90506000606484600b015483611457919061211e565b6114619190612178565b905061146d8682611529565b8085600d0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546114c19190611af9565b925050819055508185600e0160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546115199190611af9565b9250508190555050505050505050565b6000611533610e59565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600501548211156116045780600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154826040517faf5a111b0000000000000000000000000000000000000000000000000000000081526004016115fb929190611de1565b60405180910390fd5b8181600d0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546116589190611f6a565b92505081905550505050565b82805461167090611bb5565b90600052602060002090601f01602090048101928261169257600085556116d9565b82601f106116ab57805160ff19168380011785556116d9565b828001600101855582156116d9579182015b828111156116d85782518255916020019190600101906116bd565b5b5090506116e691906116ea565b5090565b5b808211156117035760008160009055506001016116eb565b5090565b6000604051905090565b600080fd5b600080fd5b6000819050919050565b61172e8161171b565b811461173957600080fd5b50565b60008135905061174b81611725565b92915050565b60006020828403121561176757611766611711565b5b60006117758482850161173c565b91505092915050565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6117d182611788565b810181811067ffffffffffffffff821117156117f0576117ef611799565b5b80604052505050565b6000611803611707565b905061180f82826117c8565b919050565b600067ffffffffffffffff82111561182f5761182e611799565b5b61183882611788565b9050602081019050919050565b82818337600083830152505050565b600061186761186284611814565b6117f9565b90508281526020810184848401111561188357611882611783565b5b61188e848285611845565b509392505050565b600082601f8301126118ab576118aa61177e565b5b81356118bb848260208601611854565b91505092915050565b600080600080600060a086880312156118e0576118df611711565b5b600086013567ffffffffffffffff8111156118fe576118fd611716565b5b61190a88828901611896565b955050602061191b8882890161173c565b945050604061192c8882890161173c565b935050606061193d8882890161173c565b925050608061194e8882890161173c565b9150509295509295909350565b6000819050919050565b61196e8161195b565b811461197957600080fd5b50565b60008135905061198b81611965565b92915050565b600080604083850312156119a8576119a7611711565b5b60006119b68582860161197c565b92505060206119c78582860161197c565b9150509250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006119fc826119d1565b9050919050565b611a0c816119f1565b82525050565b611a1b8161171b565b82525050565b6000604082019050611a366000830185611a03565b611a436020830184611a12565b9392505050565b60008115159050919050565b611a5f81611a4a565b8114611a6a57600080fd5b50565b600081519050611a7c81611a56565b92915050565b600060208284031215611a9857611a97611711565b5b6000611aa684828501611a6d565b91505092915050565b6000602082019050611ac46000830184611a12565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611b048261171b565b9150611b0f8361171b565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115611b4457611b43611aca565b5b828201905092915050565b6000606082019050611b646000830186611a03565b611b716020830185611a03565b611b7e6040830184611a12565b949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611bcd57607f821691505b602082108103611be057611bdf611b86565b5b50919050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b60008154611c1981611bb5565b611c238186611be6565b94506001821660008114611c3e5760018114611c5057611c83565b60ff1983168652602086019350611c83565b611c5985611bf7565b60005b83811015611c7b57815481890152600182019150602081019050611c5c565b808801955050505b50505092915050565b600060a0820190508181036000830152611ca68188611c0c565b9050611cb56020830187611a12565b611cc26040830186611a12565b611ccf6060830185611a12565b611cdc6080830184611a12565b9695505050505050565b600081519050919050565b60005b83811015611d0f578082015181840152602081019050611cf4565b83811115611d1e576000848401525b50505050565b6000611d2f82611ce6565b611d398185611be6565b9350611d49818560208601611cf1565b611d5281611788565b840191505092915050565b600060a0820190508181036000830152611d778188611d24565b9050611d866020830187611a12565b611d936040830186611a12565b611da06060830185611a12565b611dad6080830184611a12565b9695505050505050565b611dc08161195b565b82525050565b6000602082019050611ddb6000830184611db7565b92915050565b6000604082019050611df66000830185611a12565b611e036020830184611a12565b9392505050565b6000602082019050611e1f6000830184611a03565b92915050565b6000604082019050611e3a6000830185611a03565b611e476020830184611db7565b9392505050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b60008154611e8181611bb5565b611e8b8186611e4e565b94506001821660008114611ea65760018114611eb857611eeb565b60ff1983168652602086019350611eeb565b611ec185611e5f565b60005b83811015611ee357815481890152600182019150602081019050611ec4565b808801955050505b50505092915050565b6000606082019050611f096000830186611a03565b8181036020830152611f1b8185611e74565b9050611f2a6040830184611db7565b949350505050565b611f3b81611a4a565b82525050565b6000604082019050611f566000830185611f32565b611f636020830184611a03565b9392505050565b6000611f758261171b565b9150611f808361171b565b925082821015611f9357611f92611aca565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000611fd88261171b565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361200a57612009611aca565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061204f8261171b565b915061205a8361171b565b92508261206a57612069612015565b5b828206905092915050565b6000819050919050565b60008160001b9050919050565b60006120a76120a261209d84612075565b61207f565b61195b565b9050919050565b6120b78161208c565b82525050565b600060ff82169050919050565b6120d3816120bd565b82525050565b60006080820190506120ee60008301876120ae565b6120fb60208301866120ca565b6121086040830185611db7565b6121156060830184611db7565b95945050505050565b60006121298261171b565b91506121348361171b565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561216d5761216c611aca565b5b828202905092915050565b60006121838261171b565b915061218e8361171b565b92508261219e5761219d612015565b5b82820490509291505056fea26469706673582212202b57532e4ac5d4fdfabf8d63a5a79e1b985a12583c79d8a6f8f4f565789fce4164736f6c634300080d0033",
  "devdoc": {
    "errors": {
      "ArchaeologistAlreadyPublishedPrivateKey(address)": [
        {
          "params": {
            "archaeologistAddress": "address of publishing archaeologist"
          }
        }
      ],
      "ArchaeologistHasBeenAccused(address,bytes32)": [
        {
          "params": {
            "archaeologistAddress": "Address of accused archaeologist who is attempting to publish their private key",
            "sarcoId": "ID of sarcophagus archaeologist has attempted to publish a key on"
          }
        }
      ],
      "ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)": [
        {
          "params": {
            "archaeologistAddress": "address of publishing archaeologist",
            "privateKey": "privateKey the archaeologist has attempted to publish",
            "publicKey": "publicKey stored for archaeologist on the sarcophagus"
          }
        }
      ],
      "TooEarlyForPublish(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed publish attempt",
            "resurrectionTime": "Time after which the sarcophagus can be resurrected"
          }
        }
      ],
      "TooLateForPublish(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed publish attempt",
            "publishDeadline": "Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)"
          }
        }
      ]
    },
    "events": {
      "PublishPrivateKey(bytes32,bytes32,address)": {
        "params": {
          "privateKey": "private key that has been published",
          "sarcoId": "ID of sarcophagus archaeologist has published the private key on"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "depositFreeBond(uint256)": {
        "params": {
          "amount": "The amount to deposit"
        }
      },
      "publishPrivateKey(bytes32,bytes32)": {
        "params": {
          "privateKey": "The private key the archaeologist is publishing",
          "sarcoId": "The identifier of the sarcophagus for which the archaeologist is responsible"
        }
      },
      "registerArchaeologist(string,uint256,uint256,uint256,uint256)": {
        "params": {
          "freeBond": "How much bond the archaeologist wants to deposit during the register call (if any)",
          "maximumResurrectionTime": "The time beyond which the archaeologist is not willing to accept new curses or rewraps",
          "maximumRewrapInterval": "The longest interval of time from a rewrap time the arch will accept for a resurrection",
          "minimumDiggingFeePerSecond": "The archaeologist's minimum amount to earn per second for being cursed",
          "peerId": "The libp2p identifier for the archaeologist"
        }
      },
      "updateArchaeologist(string,uint256,uint256,uint256,uint256)": {
        "params": {
          "maximumRewrapInterval": "The longest interval of time from a rewrap time the arch will accept for a resurrection freeBond How much bond the archaeologist wants to deposit during the update call (if any)",
          "minimumDiggingFeePerSecond": "The archaeologist's minimum amount to earn per second for being cursed",
          "peerId": "The libp2p identifier for the archaeologist"
        }
      },
      "withdrawFreeBond(uint256)": {
        "params": {
          "amount": "The amount to withdraw"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "ArchaeologistAlreadyPublishedPrivateKey(address)": [
        {
          "notice": "Archaeologist has attempted to publish a key for a sarcophagus twice"
        }
      ],
      "ArchaeologistHasBeenAccused(address,bytes32)": [
        {
          "notice": "An archaeologist that has already been successfully accused has attempted to publish their private key"
        }
      ],
      "ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)": [
        {
          "notice": "Archaeologist has attempted to publish the incorrect private key for a sarcophagus"
        }
      ],
      "CannotSetZeroProfileValue()": [
        {
          "notice": "Archaeologist has attempted to set a zero minimumDiggingFeePerSecond or maximumRewrapInterval"
        }
      ],
      "TooEarlyForPublish(uint256,uint256)": [
        {
          "notice": "Archaeologist has attempted to publish a key before the resurrection time"
        }
      ],
      "TooLateForPublish(uint256,uint256)": [
        {
          "notice": "Archaeologist has attempted to publish a key after the end of the resurrection window"
        }
      ]
    },
    "events": {
      "PublishPrivateKey(bytes32,bytes32,address)": {
        "notice": "Emitted when an archaeologist successfully publishes their private key for a sarcophagus"
      }
    },
    "kind": "user",
    "methods": {
      "depositFreeBond(uint256)": {
        "notice": "Deposits an archaeologist's free bond to the contract."
      },
      "publishPrivateKey(bytes32,bytes32)": {
        "notice": "Publishes the private key for which the archaeologist is responsible during the sarcophagus resurrection window. Pays digging fees to the archaeologist and releases their locked bond. Cannot be called on a compromised or buried sarcophagus."
      },
      "registerArchaeologist(string,uint256,uint256,uint256,uint256)": {
        "notice": "Registers the archaeologist profile"
      },
      "updateArchaeologist(string,uint256,uint256,uint256,uint256)": {
        "notice": "Updates the archaeologist profile"
      },
      "withdrawFreeBond(uint256)": {
        "notice": "Withdraws an archaeologist's free bond from the contract."
      },
      "withdrawReward()": {
        "notice": "Withdraws all rewards from an archaeologist's reward pool"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}