{
  "address": "0x40cBb4A31731e6c15B47804476E83dA10BaB9AfD",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "exists",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "ArchaeologistProfileExistsShouldBe",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "archaeologistAccusalsIdentifier",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "archaeologistCleanupsIdentifier",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "archaeologistSuccessesIdentifier",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getArchaeologistAccusalsCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getArchaeologistCleanupsCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getArchaeologistProfile",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "maximumRewrapInterval",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumResurrectionTime",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "peerId",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "minimumDiggingFeePerSecond",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "freeBond",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cursedBond",
              "type": "uint256"
            }
          ],
          "internalType": "struct LibTypes.ArchaeologistProfile",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "getArchaeologistProfileAddressAtIndex",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getArchaeologistProfileAddresses",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "addresses",
          "type": "address[]"
        }
      ],
      "name": "getArchaeologistProfiles",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "maximumRewrapInterval",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumResurrectionTime",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "peerId",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "minimumDiggingFeePerSecond",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "freeBond",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cursedBond",
              "type": "uint256"
            }
          ],
          "internalType": "struct LibTypes.ArchaeologistProfile[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getArchaeologistSarcophagi",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "getArchaeologistSuccessOnSarcophagus",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getArchaeologistSuccessesCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "addresses",
          "type": "address[]"
        }
      ],
      "name": "getArchaeologistsStatistics",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "successes",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "accusals",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cleanups",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "failures",
              "type": "uint256"
            }
          ],
          "internalType": "struct ViewStateFacet.ArchaeologistStatistics[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getCursedBond",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCursedBondPercentage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getEmbalmerClaimWindow",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "embalmer",
          "type": "address"
        }
      ],
      "name": "getEmbalmerSarcophagi",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getExpirationThreshold",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getFreeBond",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getGracePeriod",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProtocolFeeBasePercentage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "getRecipientSarcophagi",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getRewards",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "getSarcophagus",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "resurrectionTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "previousRewrapTime",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "isCompromised",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isCleaned",
              "type": "bool"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "uint8",
              "name": "threshold",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "maximumRewrapInterval",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "arweaveTxId",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "embalmerAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipientAddress",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "archaeologistAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint8",
              "name": "publishedPrivateKeyCount",
              "type": "uint8"
            },
            {
              "internalType": "bool",
              "name": "hasLockedBond",
              "type": "bool"
            }
          ],
          "internalType": "struct ViewStateFacet.SarcophagusResponse",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "getSarcophagusArchaeologist",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "diggingFeePerSecond",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "privateKey",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "publicKey",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "isAccused",
              "type": "bool"
            }
          ],
          "internalType": "struct LibTypes.CursedArchaeologist",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTotalProtocolFees",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x978d037d10efd5ea4fc522b419fe8ae4b187578682866ee1275de4e0d66b8682",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x026820C8F89B0Ea06a28fe67D690EEb9caF8329D",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "2533122",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x428027630d30772079ee675cc2e58563215a75c84cbde05d84c3ae13de5ad827",
    "transactionHash": "0x978d037d10efd5ea4fc522b419fe8ae4b187578682866ee1275de4e0d66b8682",
    "logs": [],
    "blockNumber": 2920879,
    "cumulativeGasUsed": "2533122",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "02cdb842f5b9caff3fd1c503289458b6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"ArchaeologistProfileExistsShouldBe\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"archaeologistAccusalsIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"archaeologistCleanupsIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"archaeologistSuccessesIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getArchaeologistAccusalsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getArchaeologistCleanupsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getArchaeologistProfile\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFeePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cursedBond\",\"type\":\"uint256\"}],\"internalType\":\"struct LibTypes.ArchaeologistProfile\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getArchaeologistProfileAddressAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getArchaeologistProfileAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getArchaeologistProfiles\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFeePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cursedBond\",\"type\":\"uint256\"}],\"internalType\":\"struct LibTypes.ArchaeologistProfile[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getArchaeologistSarcophagi\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"getArchaeologistSuccessOnSarcophagus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getArchaeologistSuccessesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getArchaeologistsStatistics\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"successes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accusals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cleanups\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"failures\",\"type\":\"uint256\"}],\"internalType\":\"struct ViewStateFacet.ArchaeologistStatistics[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getCursedBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCursedBondPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEmbalmerClaimWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"embalmer\",\"type\":\"address\"}],\"name\":\"getEmbalmerSarcophagi\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExpirationThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getFreeBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGracePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolFeeBasePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"getRecipientSarcophagi\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"getSarcophagus\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"resurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousRewrapTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCompromised\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCleaned\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"threshold\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"arweaveTxId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"embalmerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"archaeologistAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"publishedPrivateKeyCount\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hasLockedBond\",\"type\":\"bool\"}],\"internalType\":\"struct ViewStateFacet.SarcophagusResponse\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"getSarcophagusArchaeologist\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"diggingFeePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"isAccused\",\"type\":\"bool\"}],\"internalType\":\"struct LibTypes.CursedArchaeologist\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalProtocolFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"archaeologistAccusalsIdentifier(address,uint256)\":{\"params\":{\"archaeologist\":\"The address of an archaeologist\",\"index\":\"The index of the archaeologist's accused sarcophagi\"},\"returns\":{\"_0\":\"the identifier associated with the index of the archaeologist's accused sarcophagi\"}},\"archaeologistCleanupsIdentifier(address,uint256)\":{\"params\":{\"archaeologist\":\"The address of an archaeologist\",\"index\":\"The index of the archaeologist's cleaned-up sarcophagi\"},\"returns\":{\"_0\":\"the identifier associated with the index of the archaeologist's cleaned-up sarcophagi\"}},\"archaeologistSuccessesIdentifier(address,uint256)\":{\"params\":{\"archaeologist\":\"The address of an archaeologist\",\"index\":\"The index of the archaeologist's unwrapped sarcophagi\"},\"returns\":{\"_0\":\"the identifier associated with the index of the archaeologist's unwrapped sarcophagi\"}},\"getArchaeologistAccusalsCount(address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose accusations count is being returned\"}},\"getArchaeologistCleanupsCount(address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose cleanups count is being returned\"}},\"getArchaeologistProfile(address)\":{\"params\":{\"archaeologist\":\"The archaeologist account's address\"},\"returns\":{\"_0\":\"the Archaeologist object\"}},\"getArchaeologistProfileAddressAtIndex(uint256)\":{\"params\":{\"index\":\"The index of the registered archaeologist\"},\"returns\":{\"_0\":\"address of the archaeologist\"}},\"getArchaeologistProfileAddresses()\":{\"returns\":{\"_0\":\"addresses of registered archaeologists\"}},\"getArchaeologistProfiles(address[])\":{\"params\":{\"addresses\":\"The list of archaeologist addresses\"},\"returns\":{\"_0\":\"The list of archaeologist profiles\"}},\"getArchaeologistSarcophagi(address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose sarcophagi are being returned\"}},\"getArchaeologistSuccessOnSarcophagus(address,bytes32)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist\",\"sarcoId\":\"the sarcophagus to check if unwrapping occured\"}},\"getArchaeologistSuccessesCount(address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose success\"}},\"getArchaeologistsStatistics(address[])\":{\"params\":{\"addresses\":\"The list of archaeologist addresses\"},\"returns\":{\"_0\":\"The list of archaeologist statistics\"}},\"getCursedBond(address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose cursed bond is being returned\"}},\"getCursedBondPercentage()\":{\"returns\":{\"_0\":\"The cursed bond percentage - cursedBondPercentage\"}},\"getEmbalmerClaimWindow()\":{\"returns\":{\"_0\":\"The embalmer claim window\"}},\"getEmbalmerSarcophagi(address)\":{\"params\":{\"embalmer\":\"The address of the embalmer whose sarcophagi are being returned\"}},\"getExpirationThreshold()\":{\"returns\":{\"_0\":\"The expiration threshold\"}},\"getFreeBond(address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose free bond is being returned\"}},\"getGracePeriod()\":{\"returns\":{\"_0\":\"The resurrection grace period\"}},\"getProtocolFeeBasePercentage()\":{\"returns\":{\"_0\":\"The protocol fee base percentage - protocolFeeBasePercentage\"}},\"getRecipientSarcophagi(address)\":{\"params\":{\"recipient\":\"The address of the recipient whose sarcophagi are being returned\"}},\"getRewards(address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose reward is being returned\"}},\"getSarcophagus(bytes32)\":{\"params\":{\"sarcoId\":\"The identifier of the sarcophagus being returned\"}},\"getSarcophagusArchaeologist(bytes32,address)\":{\"params\":{\"archaeologist\":\"The address of the archaeologist whose data is being returned\",\"sarcoId\":\"The identifier of the sarcophagus whose data is being returned\"}},\"getTotalProtocolFees()\":{\"returns\":{\"_0\":\"The total protocol fees\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"archaeologistAccusalsIdentifier(address,uint256)\":{\"notice\":\"Returns the sarcophagus unique identifier for a given archaeologist and index of the accused sarcophagi\"},\"archaeologistCleanupsIdentifier(address,uint256)\":{\"notice\":\"Returns the sarcophagus unique identifier for a given archaeologist and index of the cleaned-up sarcophagi\"},\"archaeologistSuccessesIdentifier(address,uint256)\":{\"notice\":\"Returns the sarcophagus unique identifier for a given archaeologist and index of the successfully unwrapped sarcophagi\"},\"getArchaeologistAccusalsCount(address)\":{\"notice\":\"Returns the number of accusations for an archaeologist.\"},\"getArchaeologistCleanupsCount(address)\":{\"notice\":\"Returns the number of cleanups for an archaeologist.\"},\"getArchaeologistProfile(address)\":{\"notice\":\"Given an archaeologist address, return that archaeologist's profile\"},\"getArchaeologistProfileAddressAtIndex(uint256)\":{\"notice\":\"Given an index (of the full archaeologist array), return the archaeologist address at that index\"},\"getArchaeologistProfileAddresses()\":{\"notice\":\"Return the list of registereed archaeologist addresses.\"},\"getArchaeologistProfiles(address[])\":{\"notice\":\"Gets archaeologist profiles given a list of archaeologist addresses. If an invalid address is included, simply leaves it out of the list.\"},\"getArchaeologistSarcophagi(address)\":{\"notice\":\"Given an archaeologist's address, returns the identifiers of all sarcophagi that the archaeologist has participated in.\"},\"getArchaeologistSuccessOnSarcophagus(address,bytes32)\":{\"notice\":\"Returns whether an archaeologist completed an unwrap for a sarcophagus\"},\"getArchaeologistSuccessesCount(address)\":{\"notice\":\"Returns the number of successful unwraps for an archaeologist.\"},\"getArchaeologistsStatistics(address[])\":{\"notice\":\"Gets all reputation statistics for each archaeologist Contains a list of counts for each category.\"},\"getCursedBond(address)\":{\"notice\":\"Returns the amount of cursed bond stored in the contract for an archaeologist.\"},\"getCursedBondPercentage()\":{\"notice\":\"Get the cursed bond percentage from the contract.\"},\"getEmbalmerClaimWindow()\":{\"notice\":\"Gets the window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\"},\"getEmbalmerSarcophagi(address)\":{\"notice\":\"Given an embalmer's address, returns the identifiers of all sarcophagi that the embalmer has created.\"},\"getExpirationThreshold()\":{\"notice\":\"Gets the expiration threshold after which a sarcophagus must be renegotiated\"},\"getFreeBond(address)\":{\"notice\":\"Returns the amount of free bond stored in the contract for an archaeologist.\"},\"getGracePeriod()\":{\"notice\":\"Gets the grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time passes\"},\"getProtocolFeeBasePercentage()\":{\"notice\":\"Get the protocol fee base percentage from the contract.\"},\"getRecipientSarcophagi(address)\":{\"notice\":\"Given a recipient's address, returns the identifiers of all sarcophagi that the recipient has participated in.\"},\"getRewards(address)\":{\"notice\":\"Returns the amount of rewards stored in the contract for an archaeologist.\"},\"getSarcophagus(bytes32)\":{\"notice\":\"Returns data on the sarcophagus with the supplied id includes aggregate data on cursed archaeologists associated with the sarcophagus     - publishedPrivateKeyCount - the total number of private keys published by archaeologists on the sarcophagus     - hasLockedBond - true if archaeologists still have bond locked in the contract for this sarcophagus\"},\"getSarcophagusArchaeologist(bytes32,address)\":{\"notice\":\"Returns the data stored on a sarcophagus for an archaeologist.\"},\"getTotalProtocolFees()\":{\"notice\":\"Gets the total protocol fees from the contract.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/ViewStateFacet.sol\":\"ViewStateFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"contracts/facets/EmbalmerFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\n\\ncontract EmbalmerFacet {\\n    /// @notice Emitted when a sarcophagus is created\\n    /// @param sarcoId Id of the new sarcophagus\\n    /// @param name Name of the new sarcophagus\\n    /// @param resurrectionTime Resurrection time of the new sarcophagus\\n    /// @param embalmer Address of embalmer\\n    /// @param recipient Address of recipient\\n    /// @param cursedArchaeologists Array of addresses of cursed archaeologists\\n    /// @param totalDiggingFees Total digging fees charged to embalmer to create the sarcophagus\\n    /// @param createSarcophagusProtocolFees Total protocol fees charged to embalmer to create the sarcophagus\\n    /// @param arweaveTxId arweave tx id for the sarcophagus\\n    event CreateSarcophagus(\\n        bytes32 indexed sarcoId,\\n        string name,\\n        uint256 resurrectionTime,\\n        address embalmer,\\n        address recipient,\\n        address[] cursedArchaeologists,\\n        uint256 totalDiggingFees,\\n        uint256 createSarcophagusProtocolFees,\\n        string arweaveTxId\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is rewrapped\\n    /// @param sarcoId Id of sarcophagus that was rewrapped\\n    /// @param resurrectionTime New resurrection time for the sarcophagus\\n    /// @param totalDiggingFees Total digging fees charged to the embalmer for the rewrap\\n    /// @param rewrapSarcophagusProtocolFees Total protocol fees charged to the embalmer for the rewrap\\n    event RewrapSarcophagus(\\n        bytes32 indexed sarcoId,\\n        uint256 resurrectionTime,\\n        uint256 totalDiggingFees,\\n        uint256 rewrapSarcophagusProtocolFees\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is buried\\n    /// @param sarcoId Id of sarcophagus that was buried\\n    event BurySarcophagus(bytes32 indexed sarcoId);\\n\\n    /// @notice Parameters of a sarcophagus, supplied during sarcophagus creation\\n    struct SarcophagusParams {\\n        string name;\\n        // highest rewrap interval cursed archaeologists have agreed to accept for lifetime of sarcophagus\\n        uint256 maximumRewrapInterval;\\n        // The timestamp beyond which the sarcophagus can no longer be rewrapped\\n        uint256 maximumResurrectionTime;\\n        address recipientAddress;\\n        uint256 resurrectionTime;\\n        uint8 threshold;\\n        uint256 creationTime;\\n    }\\n\\n    /// @notice Parameters of an archaeologist's curse, supplied during sarcophagus creation\\n    struct CurseParams {\\n        bytes publicKey;\\n        address archAddress;\\n        uint256 diggingFeePerSecond;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an id that is already in use\\n    /// @param sarcoId Id that is already in use\\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with expired parameters\\n    /// @param currentTime Timestamp of the failed create attempt\\n    /// @param creationTime Time when the sarcophagus parameters were created\\n    /// @param creationDeadline Deadline for creation of a sarcophagus with the supplied parameters\\n    error SarcophagusParametersExpired(\\n        uint256 currentTime,\\n        uint256 creationTime,\\n        uint256 creationDeadline\\n    );\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with no archaeologists\\n    error NoArchaeologistsProvided();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a shamir secret sharing threshold of 0\\n    error ThresholdCannotBeZero();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with more required archaeologists than total archaeologists\\n    error ThresholdGreaterThanTotalNumberOfArchaeologists(\\n        uint8 threshold,\\n        uint256 totalNumberOfArchaeologists\\n    );\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an archaeologist list that contains the same archaeologist more than once\\n    error ArchaeologistListContainsDuplicate(address archaeologistAddress);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that has already passed\\n    /// @param currentTime Timestamp of the failed rewrap attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a public key that has already been assigned to another sarcophagus\\n    /// @param publicKey the duplicated public key\\n    error DuplicatePublicKey(bytes publicKey);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that exceeds the maximum rewrap interval\\n    /// @param resurrectionTime Resurrection timestamp which is too far in the future\\n    /// @param sarcophagusMaximumRewrapInterval Maximum rewrap interval set for the sarcophagus\\n    /// @param maximumPermissibleResurrectionTime Resurrection timestamp which is too far in the future\\n    error ResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    /// @notice Emitted when the resurrection time defined during sarcohpagus creation or rewrap goes past the max resurrection time\\n    /// @param resurrectionTime The resurrection time defined during the sarcophagus creation or rewrap\\n    /// @param maxResurrectionTime The maximum allowed resurrection time\\n    error ResurrectionTimePastMaxResurrectionTime(\\n        uint256 resurrectionTime,\\n        uint256 maxResurrectionTime\\n    );\\n\\n    error NewResurrectionTimeInPast(uint256 currentTime, uint256 newResurrectionTime);\\n\\n    error NewResurrectionTimeIsZero();\\n\\n    error NewResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    error ResurrectionTimeTooFarPastPreviousResurrectionTime(\\n        uint256 resurrectionTime,\\n        uint256 previousResurrectionTime\\n    );\\n\\n    /// @notice Creates a sarcophagus with the supplied parameters and locks\\n    /// a portion of each archaeologist's freeBond equal to the digging fees calculated for the duration\\n    /// of the sarcophagus until its resurrection time.\\n    ///\\n    /// Verifies that each supplied archaeologist has signed off on the sarcophagus negotiation parameters:\\n    ///    - `publicKey` that matches the private key the archaeologist is responsible for\\n    ///    - `maximumRewrapInterval` to be enforced for the lifetime of the sarcophagus. No new resurrection time for future rewraps may exceed this interval from time of rewrap.\\n    ///    - `creationTime` of sarcophagus\\n    ///    - `diggingFeePerSecond` agreed to be paid to the archaeologist during the lifetime of the sarcophagus. Constant.\\n    ///\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param sarcophagusParams params to set on sarcophagus being created\\n    /// @param selectedArchaeologists the archaeologists the embalmer has selected to curse\\n    /// @param arweaveTxId id of tx storing the sarcophagus payload on arweave\\n    function createSarcophagus(\\n        bytes32 sarcoId,\\n        SarcophagusParams calldata sarcophagusParams,\\n        CurseParams[] calldata selectedArchaeologists,\\n        string calldata arweaveTxId\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Confirm that sarcophagus with supplied id doesn't already exist\\n        if (s.sarcophagi[sarcoId].resurrectionTime > 0) {\\n            revert SarcophagusAlreadyExists(sarcoId);\\n        }\\n\\n        // Ensure too much time hasn't passed since the sarcophagus `creationTime` that has been signed\\n        // off by its cursed archaeologists.\\n        if (block.timestamp > sarcophagusParams.creationTime + s.expirationThreshold) {\\n            revert SarcophagusParametersExpired(\\n                block.timestamp,\\n                sarcophagusParams.creationTime,\\n                sarcophagusParams.creationTime + s.expirationThreshold\\n            );\\n        }\\n\\n        // Confirm that resurrection time is in the future\\n        if (block.timestamp >= sarcophagusParams.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagusParams.resurrectionTime);\\n        }\\n\\n        // Confirm that resurrection or rewrap will occur before the maximumRewrapInterval elapses\\n        if (\\n            block.timestamp + sarcophagusParams.maximumRewrapInterval <\\n            sarcophagusParams.resurrectionTime\\n        ) {\\n            revert ResurrectionTimeTooFarInFuture(\\n                sarcophagusParams.resurrectionTime,\\n                sarcophagusParams.maximumRewrapInterval,\\n                block.timestamp + sarcophagusParams.maximumRewrapInterval\\n            );\\n        }\\n\\n        // Confirm that the resurrection time is less than the max resurrection time\\n        if (sarcophagusParams.resurrectionTime > sarcophagusParams.maximumResurrectionTime) {\\n            revert ResurrectionTimePastMaxResurrectionTime(\\n                sarcophagusParams.resurrectionTime,\\n                sarcophagusParams.maximumResurrectionTime\\n            );\\n        }\\n\\n        // Validate archaeologist and threshold lengths\\n        if (selectedArchaeologists.length == 0) {\\n            revert NoArchaeologistsProvided();\\n        }\\n\\n        if (sarcophagusParams.threshold == 0) {\\n            revert ThresholdCannotBeZero();\\n        }\\n\\n        // Ensure that k <= n in the effective k-of-n shamir secret sharing scheme\\n        // used to distribute keyshares among archaeologists\\n        if (sarcophagusParams.threshold > selectedArchaeologists.length) {\\n            revert ThresholdGreaterThanTotalNumberOfArchaeologists(\\n                sarcophagusParams.threshold,\\n                selectedArchaeologists.length\\n            );\\n        }\\n\\n        // create the sarcophagus\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n        sarcophagus.name = sarcophagusParams.name;\\n        sarcophagus.threshold = sarcophagusParams.threshold;\\n        sarcophagus.resurrectionTime = sarcophagusParams.resurrectionTime;\\n        sarcophagus.previousRewrapTime = sarcophagusParams.creationTime;\\n        sarcophagus.maximumRewrapInterval = sarcophagusParams.maximumRewrapInterval;\\n        sarcophagus.maximumResurrectionTime = sarcophagusParams.maximumResurrectionTime;\\n        sarcophagus.arweaveTxId = arweaveTxId;\\n        sarcophagus.embalmerAddress = msg.sender;\\n        sarcophagus.recipientAddress = sarcophagusParams.recipientAddress;\\n        sarcophagus.cursedArchaeologistAddresses = new address[](selectedArchaeologists.length);\\n        sarcophagus.cursedBondPercentage = s.cursedBondPercentage;\\n\\n        // track total digging fees due upon creation of sarcophagus\\n        uint256 totalDiggingFees = 0;\\n\\n        for (uint256 i = 0; i < selectedArchaeologists.length; i++) {\\n            LibUtils.revertIfArchProfileDoesNotExist(selectedArchaeologists[i].archAddress);\\n\\n            // Confirm archaeologist isn't already cursed on this sarcophagus (no duplicates)\\n            if (\\n                sarcophagus\\n                    .cursedArchaeologists[selectedArchaeologists[i].archAddress]\\n                    .publicKey\\n                    .length != 0\\n            ) {\\n                revert ArchaeologistListContainsDuplicate(selectedArchaeologists[i].archAddress);\\n            }\\n\\n            // Confirm archaeologist is not re-using a key pair\\n            if (\\n                s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] != address(0)\\n            ) {\\n                revert DuplicatePublicKey(selectedArchaeologists[i].publicKey);\\n            }\\n\\n            LibUtils.verifyArchaeologistSignature(\\n                sarcophagusParams.maximumRewrapInterval,\\n                sarcophagusParams.maximumResurrectionTime,\\n                sarcophagusParams.creationTime,\\n                selectedArchaeologists[i]\\n            );\\n\\n            // Curse the archaeologist on this sarcophagus\\n            uint256 diggingFeesDue = LibBonds.curseArchaeologist(\\n                sarcoId,\\n                selectedArchaeologists[i],\\n                i\\n            );\\n\\n            totalDiggingFees += diggingFeesDue;\\n\\n            // \\\"Consume\\\" this public key so it cannot be reused in the future\\n            s.publicKeyToArchaeologistAddress[\\n                selectedArchaeologists[i].publicKey\\n            ] = selectedArchaeologists[i].archAddress;\\n        }\\n\\n        // Add this sarcophagus id to the embalmer's record\\n        s.embalmerSarcophagi[msg.sender].push(sarcoId);\\n\\n        // Add this sarcophagus id to the recipient's record\\n        s.recipientSarcophagi[sarcophagusParams.recipientAddress].push(sarcoId);\\n\\n        // Transfer totalDiggingFees and the protocolFees in SARCO from embalmer to this contract\\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n        s.totalProtocolFees += protocolFees;\\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\\n\\n        emit CreateSarcophagus(\\n            sarcoId,\\n            sarcophagusParams.name,\\n            sarcophagusParams.resurrectionTime,\\n            msg.sender,\\n            sarcophagusParams.recipientAddress,\\n            sarcophagus.cursedArchaeologistAddresses,\\n            totalDiggingFees,\\n            protocolFees,\\n            arweaveTxId\\n        );\\n    }\\n\\n    /// @notice Updates the resurrectionTime on a sarcophagus. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param resurrectionTime the new resurrection time\\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        if (resurrectionTime == 0) {\\n            revert NewResurrectionTimeIsZero();\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n\\n        // Confirm resurrection time has not yet passed\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time is in future\\n        if (block.timestamp >= resurrectionTime) {\\n            revert NewResurrectionTimeInPast(block.timestamp, resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time doesn't exceed sarcophagus's maximumRewrapInterval\\n        if (block.timestamp + sarcophagus.maximumRewrapInterval < resurrectionTime) {\\n            revert NewResurrectionTimeTooFarInFuture(\\n                resurrectionTime,\\n                sarcophagus.maximumRewrapInterval,\\n                block.timestamp + sarcophagus.maximumRewrapInterval\\n            );\\n        }\\n\\n        // Confirm that the new resurrection time doesn't exceed the maximumResurrectionTime\\n        if (sarcophagus.maximumResurrectionTime < resurrectionTime) {\\n            revert ResurrectionTimePastMaxResurrectionTime(\\n                resurrectionTime,\\n                sarcophagus.maximumResurrectionTime\\n            );\\n        }\\n\\n        // track total digging fees to be paid by embalmer across all archaeologists on the sarcophagus\\n        uint256 totalDiggingFees = 0;\\n\\n        // pay digging fee to each cursed archaeologist on the sarcophagus that has not been accused\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        uint256 cursedBondPercentage = sarcophagus.cursedBondPercentage;\\n\\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n\\n            if (!cursedArchaeologist.isAccused) {\\n                uint256 prevDiggingFees = cursedArchaeologist.diggingFeePerSecond *\\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n                uint256 newDiggingFees = cursedArchaeologist.diggingFeePerSecond *\\n                    (resurrectionTime - block.timestamp);\\n\\n                // If the new digging fees are greater than the previous digging fees, we need to\\n                // increase the archaeologist's locked bond\\n                if (newDiggingFees > prevDiggingFees) {\\n                    uint256 diggingFeeDifference = newDiggingFees - prevDiggingFees;\\n                    uint256 cursedBondIncrease = diggingFeeDifference * cursedBondPercentage / 100;\\n\\n                    // If the previous cycle's rewards can't cover the cursed bond increase, revert\\n                    if (cursedBondIncrease > prevDiggingFees) {\\n                        revert ResurrectionTimeTooFarPastPreviousResurrectionTime(\\n                            resurrectionTime,\\n                            sarcophagus.resurrectionTime\\n                        );\\n                    }\\n\\n                    // Increase the archaeologist's cursed bond\\n                    s\\n                        .archaeologistProfiles[archaeologistAddresses[i]]\\n                        .cursedBond += cursedBondIncrease;\\n\\n                    // Rewards are now previous digging fees - difference\\n                    s.archaeologistRewards[archaeologistAddresses[i]] +=\\n                        prevDiggingFees -\\n                        cursedBondIncrease;\\n                } else if (newDiggingFees < prevDiggingFees) {\\n                    uint256 diggingFeeDifference = prevDiggingFees - newDiggingFees;\\n                    uint256 cursedBondDecrease = diggingFeeDifference * cursedBondPercentage / 100;\\n\\n                    // Decrease archaeologist's cursed bond by the difference\\n                    s.archaeologistProfiles[archaeologistAddresses[i]].cursedBond -= cursedBondDecrease;\\n\\n                    // Increase archaeologist's free bond by the difference\\n                    s.archaeologistProfiles[archaeologistAddresses[i]].freeBond += cursedBondDecrease;\\n\\n                    // Rewards are equal to the previous digging fees\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\\n                } else {\\n                    // Rewards are equal to the previous digging fees\\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\\n                }\\n\\n                // Add digging fees due for the new interval\\n                totalDiggingFees += newDiggingFees;\\n            }\\n        }\\n\\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n\\n        // Add the protocol fee to the total protocol fees in storage\\n        s.totalProtocolFees += protocolFees;\\n\\n        // Update the sarcophagus resurrectionTime and previousRewrapTime\\n        sarcophagus.resurrectionTime = resurrectionTime;\\n        sarcophagus.previousRewrapTime = block.timestamp;\\n\\n        // Transfer the new digging fees and protocol fees from embalmer to contract\\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\\n\\n        emit RewrapSarcophagus(sarcoId, resurrectionTime, totalDiggingFees, protocolFees);\\n    }\\n\\n    /// @notice Terminates a sarcophagus by setting its resurrection time to infinity and returning locked\\n    /// bonds to all innocent cursed archaeologists. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    function burySarcophagus(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n        // Confirm that the current resurrection time is in the future\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // for each archaeologist on the sarcophagus, unlock bond and pay digging fees\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n\\n            // if the archaeologist hasn't been accused transfer them their digging fees and return their locked bond\\n            if (!cursedArchaeologist.isAccused) {\\n                LibBonds.freeArchaeologist(sarcoId, archaeologistAddresses[i]);\\n            }\\n        }\\n\\n        // Set resurrection time to infinity\\n        sarcophagus.resurrectionTime = 2 ** 256 - 1;\\n\\n        emit BurySarcophagus(sarcoId);\\n    }\\n}\\n\",\"keccak256\":\"0xf2454bc0a81660f2ea09764a64ea8e22723e8fa591d675e39862d34e311c656a\",\"license\":\"Unlicense\"},\"contracts/facets/ThirdPartyFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport {LibDiamond} from \\\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\ncontract ThirdPartyFacet {\\n    event AccuseArchaeologist(\\n        bytes32 indexed sarcoId,\\n        address indexed accuser,\\n        uint256 totalSlashedBondDistributed,\\n        uint256 totalDiggingFeesDistributed\\n    );\\n\\n    event Clean(bytes32 indexed sarcoId, address indexed cleaner);\\n\\n    /// @notice Clean has been called on a sarcophagus that has already been cleaned\\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a private key on\\n    error SarcophagusAlreadyCleaned(bytes32 sarcoId);\\n\\n    /// @notice Clean has been called before the deadline for archaeologists to publish private keys has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param publishDeadline Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\\n    error TooEarlyForClean(uint256 currentTime, uint256 publishDeadline);\\n\\n    /// @notice Clean has been called by someone other than the admin or embalmer of the sarcophagus\\n    /// @param senderAddress Address of sender\\n    error SenderNotEmbalmerOrAdmin(address senderAddress);\\n\\n    /// @notice Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error EmbalmerClaimWindowPassed(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error TooEarlyForAdminClean(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Emitted when a third party attempts to accuse an archaeologist on a sarcophagus where the resurrection time has already passed\\n    /// @param currentTime Timestamp of the failed accuse attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when accuse is called with an unequal numbers of public keys and signatures\\n    /// @param signatures the number of signatures passed into the accuse call\\n    /// @param publicKeys the number of public keys passed into the accuse call\\n    error DifferentNumberOfSignaturesAndPublicKeys(uint256 signatures, uint256 publicKeys);\\n\\n    /// @notice Emitted when accuse is called with an invalid signature for the supplied sarcoId, paymentAddress, and publicKey\\n    /// @param sarcoId that should have been signed\\n    /// @param paymentAddress payment address that should have been signed\\n    /// @param publicKey publicKey that should be derived from signing key\\n    /// @param signature invalid signature\\n    error InvalidAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes publicKey,\\n        LibTypes.Signature signature\\n    );\\n\\n    /// @notice If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod,\\n    /// their locked bonds and diggingFees may be claimed by either the embalmer or the admin\\n    /// embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will\\n    /// be able to claim remaining locked bond and diggingFees\\n    /// @param sarcoId The identifier of the sarcophagus to clean\\n    function clean(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer or admin\\n        if (msg.sender != sarcophagus.embalmerAddress && msg.sender != LibDiamond.contractOwner()) {\\n            revert SenderNotEmbalmerOrAdmin(msg.sender);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not already been cleaned\\n        if (sarcophagus.isCleaned) {\\n            revert SarcophagusAlreadyCleaned(sarcoId);\\n        }\\n\\n        // Confirm that the resurrectionTime + gracePeriod have passed\\n        if (block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod) {\\n            revert TooEarlyForClean(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\\n        }\\n\\n        // if sender is embalmer, confirm current time is within embalmerClaimWindow\\n        if (\\n            msg.sender == sarcophagus.embalmerAddress &&\\n            block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert EmbalmerClaimWindowPassed(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // if sender is admin, confirm embalmerClaimWindow has passed\\n        if (\\n            msg.sender == LibDiamond.contractOwner() &&\\n            block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert TooEarlyForAdminClean(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // sum of locked bonds and digging fees for all archaeologists that have failed to publish private keys before publish deadline and have not been accused\\n        uint256 totalDiggingFeesAndLockedBonds = 0;\\n\\n        for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]];\\n\\n            // Punish archaeologists that failed to publish their private key in time\\n            if (!cursedArchaeologist.isAccused && cursedArchaeologist.privateKey == 0) {\\n                uint256 diggingFeesDue = cursedArchaeologist.diggingFeePerSecond *\\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n                uint256 cursedBondDue = diggingFeesDue * sarcophagus.cursedBondPercentage / 100;\\n                totalDiggingFeesAndLockedBonds += diggingFeesDue + cursedBondDue;\\n\\n                // slash the archaeologist's locked bond for the sarcophagus\\n                LibBonds.decreaseCursedBond(\\n                    sarcophagus.cursedArchaeologistAddresses[i], cursedBondDue\\n                );\\n\\n                // track that the archaeologist has had a clean on this sarcophagus\\n                s.archaeologistCleanups[sarcophagus.cursedArchaeologistAddresses[i]].push(sarcoId);\\n            }\\n        }\\n\\n        // Transfer total slashed locked bonds plus digging fees to the embalmer if they are the caller, otherwise add\\n        // this to the contract's protocol fees\\n        if (msg.sender == sarcophagus.embalmerAddress) {\\n            s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFeesAndLockedBonds);\\n        } else {\\n            s.totalProtocolFees += totalDiggingFeesAndLockedBonds;\\n        }\\n\\n        sarcophagus.isCleaned = true;\\n        emit Clean(sarcoId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id\\n     * and payment address generated with the leaked private keys\\n     * If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be\\n     * split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer\\n     *\\n     * If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus\\n     * state will be updated to Accused and bonds for all remaining unaccused archaeologists will be\\n     * returned\\n     *\\n     * @param sarcoId The identifier of the sarcophagus having leaked private keys\\n     * @param publicKeys an array of public keys corresponding to leaked private keys - order must match order of signatures\\n     * @param signatures an array of signatures of the sarcoId and payment address signed by the leaked private keys - order must match order of publicKeys\\n     * @param paymentAddress the address to which rewards should be sent if successful\\n     */\\n    function accuse(\\n        bytes32 sarcoId,\\n        bytes[] calldata publicKeys,\\n        LibTypes.Signature[] calldata signatures,\\n        address paymentAddress\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // verify that current time is not past resurrection time\\n        if (block.timestamp > sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        if (signatures.length != publicKeys.length) {\\n            revert DifferentNumberOfSignaturesAndPublicKeys(signatures.length, publicKeys.length);\\n        }\\n\\n        address[] memory accusedArchAddresses = new address[](signatures.length);\\n\\n        // track the combined locked bond across all archaeologists being accused in this call\\n        uint256 totalCursedBond = 0;\\n        uint256 accusalCount = 0;\\n        for (uint256 i = 0; i < signatures.length; i++) {\\n            if (\\n                !LibUtils.verifyAccusalSignature(\\n                    sarcoId,\\n                    paymentAddress,\\n                    publicKeys[i],\\n                    signatures[i]\\n                )\\n            ) {\\n                revert InvalidAccusalSignature(\\n                    sarcoId,\\n                    paymentAddress,\\n                    publicKeys[i],\\n                    signatures[i]\\n                );\\n            }\\n\\n            // look up the archaeologist responsible for the publicKey\\n            address accusedArchaeologistAddress = s.publicKeyToArchaeologistAddress[publicKeys[i]];\\n            LibTypes.CursedArchaeologist storage accusedArchaeologist = sarcophagus\\n                .cursedArchaeologists[accusedArchaeologistAddress];\\n\\n            // verify the accused archaeologist is cursed on the sarcophagus\\n            if (accusedArchaeologist.publicKey.length == 0) {\\n                revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\\n            }\\n\\n            // if the archaeologist has already been accused on this sarcophagus break without taking action\\n            if (accusedArchaeologist.isAccused) {\\n                break;\\n            }\\n\\n            // mark the archaeologist on the sarcophagus as having been accused\\n            accusedArchaeologist.isAccused = true;\\n            accusedArchAddresses[accusalCount++] = accusedArchaeologistAddress;\\n\\n            uint256 cursedBondDue = (accusedArchaeologist.diggingFeePerSecond *\\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime)) * sarcophagus.cursedBondPercentage / 100;\\n\\n            totalCursedBond += cursedBondDue;\\n\\n            // Slash the offending archaeologists bond\\n            LibBonds.decreaseCursedBond(accusedArchaeologistAddress, cursedBondDue);\\n\\n            // Save this accusal against the archaeologist\\n            s.archaeologistAccusals[accusedArchaeologistAddress].push(sarcoId);\\n        }\\n\\n        // if none of the accusals were valid because the archaeologists have all already been accused, return without taking action\\n        if (accusalCount == 0) {\\n            return;\\n        }\\n\\n        // the sarcophagus is compromised if the current call has successfully accused the sss threshold of archaeologists\\n        if (accusalCount >= sarcophagus.threshold) {\\n            sarcophagus.isCompromised = true;\\n        } else {\\n            // if the current call hasn't resulted in at least sss threshold archaeologists being accused\\n            // check if total number of historical accusals on sarcophagus is greater than threshold\\n            uint256 totalAccusals = 0;\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                if (\\n                    sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    totalAccusals++;\\n                }\\n            }\\n            // the sarcophagus is compromised if k or more archaeologists have been accused over the lifetime of the sarcophagus\\n            if (totalAccusals >= sarcophagus.threshold) {\\n                sarcophagus.isCompromised = true;\\n            }\\n        }\\n\\n        // if k or more archaeologists have been accused over the lifetime of the sarcophagus, funds should\\n        // be returned to the remaining well behaved archaeologists\\n        if (sarcophagus.isCompromised) {\\n            // iterate through all archaeologist addresses on the sarcophagus\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                // if the archaeologist has never been accused, release their locked bond back to them\\n                if (\\n                    !sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    LibBonds.freeArchaeologist(\\n                        sarcoId,\\n                        sarcophagus.cursedArchaeologistAddresses[i]\\n                    );\\n                }\\n            }\\n        }\\n\\n        uint256 halfTotalCursedBond = totalCursedBond / 2;\\n        uint256 totalDiggingFees = totalCursedBond / (sarcophagus.cursedBondPercentage / 100);\\n        // transfer the cursed half, plus the current digging fees, to the embalmer\\n        s.sarcoToken.transfer(\\n            sarcophagus.embalmerAddress,\\n            totalDiggingFees + halfTotalCursedBond\\n        );\\n\\n        // transfer the other half of the cursed bond to the transaction caller\\n        s.sarcoToken.transfer(paymentAddress, halfTotalCursedBond);\\n\\n        emit AccuseArchaeologist(sarcoId, msg.sender, totalCursedBond, totalDiggingFees);\\n    }\\n}\\n\",\"keccak256\":\"0x2c78bc7c354b93cc2ed21902c48180b1b65441c0fa36ed1032b9fc6b76bc094b\",\"license\":\"Unlicense\"},\"contracts/facets/ViewStateFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport \\\"../libraries/LibUtils.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\n\\ncontract ViewStateFacet {\\n    /// @notice Gets the total protocol fees from the contract.\\n    /// @return The total protocol fees\\n    function getTotalProtocolFees() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.totalProtocolFees;\\n    }\\n\\n    /// @notice Get the protocol fee base percentage from the contract.\\n    /// @return The protocol fee base percentage - protocolFeeBasePercentage\\n    function getProtocolFeeBasePercentage() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.protocolFeeBasePercentage;\\n    }\\n\\n    /// @notice Get the cursed bond percentage from the contract.\\n    /// @return The cursed bond percentage - cursedBondPercentage\\n    function getCursedBondPercentage() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.cursedBondPercentage;\\n    }\\n\\n    /// @notice Gets archaeologist profiles given a list of archaeologist addresses.\\n    /// If an invalid address is included, simply leaves it out of the list.\\n    /// @param addresses The list of archaeologist addresses\\n    /// @return The list of archaeologist profiles\\n    function getArchaeologistProfiles(\\n        address[] memory addresses\\n    ) external view returns (LibTypes.ArchaeologistProfile[] memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.ArchaeologistProfile[] memory profiles = new LibTypes.ArchaeologistProfile[](\\n            addresses.length\\n        );\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            // Skip unregistered archaeologists\\n            if (s.archaeologistProfiles[addresses[i]].maximumRewrapInterval == 0) {\\n                continue;\\n            }\\n            profiles[i] = s.archaeologistProfiles[addresses[i]];\\n        }\\n\\n        return profiles;\\n    }\\n\\n    /// @notice Gets the grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time passes\\n    /// @return The resurrection grace period\\n    function getGracePeriod() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.gracePeriod;\\n    }\\n\\n    /// @notice Gets the window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\\n    /// @return The embalmer claim window\\n    function getEmbalmerClaimWindow() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.embalmerClaimWindow;\\n    }\\n\\n    /// @notice Gets the expiration threshold after which a sarcophagus must be renegotiated\\n    /// @return The expiration threshold\\n    function getExpirationThreshold() external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.expirationThreshold;\\n    }\\n\\n    /// @notice Given an archaeologist address, return that archaeologist's\\n    /// profile\\n    /// @param archaeologist The archaeologist account's address\\n    /// @return the Archaeologist object\\n    function getArchaeologistProfile(\\n        address archaeologist\\n    ) external view returns (LibTypes.ArchaeologistProfile memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibUtils.revertIfArchProfileDoesNotExist(archaeologist);\\n        return s.archaeologistProfiles[archaeologist];\\n    }\\n\\n    /// @notice Return the list of registereed archaeologist addresses.\\n    /// @return addresses of registered archaeologists\\n    function getArchaeologistProfileAddresses() external view returns (address[] memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistProfileAddresses;\\n    }\\n\\n    /// @notice Given an index (of the full archaeologist array), return the\\n    /// archaeologist address at that index\\n    /// @param index The index of the registered archaeologist\\n    /// @return address of the archaeologist\\n    function getArchaeologistProfileAddressAtIndex(uint256 index) external view returns (address) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistProfileAddresses[index];\\n    }\\n\\n    /// @notice Returns the amount of free bond stored in the contract for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being returned\\n    function getFreeBond(address archaeologist) external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistProfiles[archaeologist].freeBond;\\n    }\\n\\n    /// @notice Returns the amount of rewards stored in the contract for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// reward is being returned\\n    function getRewards(address archaeologist) external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistRewards[archaeologist];\\n    }\\n\\n    /// @notice Returns the amount of cursed bond stored in the contract for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// cursed bond is being returned\\n    function getCursedBond(address archaeologist) external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistProfiles[archaeologist].cursedBond;\\n    }\\n\\n    /// @notice Returns whether an archaeologist completed an unwrap for a sarcophagus\\n    /// @param archaeologist The address of the archaeologist\\n    /// @param sarcoId the sarcophagus to check if unwrapping occured\\n    function getArchaeologistSuccessOnSarcophagus(\\n        address archaeologist,\\n        bytes32 sarcoId\\n    ) external view returns (bool) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.sarcophagi[sarcoId].cursedArchaeologists[archaeologist].privateKey != 0;\\n    }\\n\\n    /// @notice Returns the number of successful unwraps for an archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose success\\n    //  count is being returned\\n    function getArchaeologistSuccessesCount(address archaeologist) external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistSuccesses[archaeologist].length;\\n    }\\n\\n    /// @notice Returns the sarcophagus unique identifier for a given\\n    /// archaeologist and index of the successfully unwrapped sarcophagi\\n    /// @param archaeologist The address of an archaeologist\\n    /// @param index The index of the archaeologist's unwrapped sarcophagi\\n    /// @return the identifier associated with the index of the archaeologist's\\n    /// unwrapped sarcophagi\\n    function archaeologistSuccessesIdentifier(\\n        address archaeologist,\\n        uint256 index\\n    ) external view returns (bytes32) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistSuccesses[archaeologist][index];\\n    }\\n\\n    /// @notice Returns the number of accusations for an archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose accusations\\n    /// count is being returned\\n    function getArchaeologistAccusalsCount(address archaeologist) external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistAccusals[archaeologist].length;\\n    }\\n\\n    /// @notice Returns the sarcophagus unique identifier for a given\\n    /// archaeologist and index of the accused sarcophagi\\n    /// @param archaeologist The address of an archaeologist\\n    /// @param index The index of the archaeologist's accused sarcophagi\\n    /// @return the identifier associated with the index of the archaeologist's\\n    /// accused sarcophagi\\n    function archaeologistAccusalsIdentifier(\\n        address archaeologist,\\n        uint256 index\\n    ) external view returns (bytes32) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistAccusals[archaeologist][index];\\n    }\\n\\n    /// @notice Returns the number of cleanups for an archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose cleanups\\n    /// count is being returned\\n    function getArchaeologistCleanupsCount(address archaeologist) external view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistCleanups[archaeologist].length;\\n    }\\n\\n    /// @notice Returns the sarcophagus unique identifier for a given\\n    /// archaeologist and index of the cleaned-up sarcophagi\\n    /// @param archaeologist The address of an archaeologist\\n    /// @param index The index of the archaeologist's cleaned-up sarcophagi\\n    /// @return the identifier associated with the index of the archaeologist's\\n    /// cleaned-up sarcophagi\\n    function archaeologistCleanupsIdentifier(\\n        address archaeologist,\\n        uint256 index\\n    ) external view returns (bytes32) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistCleanups[archaeologist][index];\\n    }\\n\\n    // Only used in the ViewStateFacet to return statistics data.\\n    // Contains a list of sarcoIds for each category. We could simply return the counts of the\\n    // arrays but we are already storing the lists of sarcoIds so we may as well use them.\\n    struct ArchaeologistStatistics {\\n        uint256 successes;\\n        uint256 accusals;\\n        uint256 cleanups;\\n        uint256 failures;\\n    }\\n\\n    /// @notice Gets all reputation statistics for each archaeologist\\n    /// Contains a list of counts for each category.\\n    /// @param addresses The list of archaeologist addresses\\n    /// @return The list of archaeologist statistics\\n    function getArchaeologistsStatistics(\\n        address[] memory addresses\\n    ) external view returns (ArchaeologistStatistics[] memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        ArchaeologistStatistics[] memory statsList = new ArchaeologistStatistics[](\\n            addresses.length\\n        );\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            // Count the failures for the arch\\n            uint256 failures = 0;\\n\\n            // Get arch sarco ids\\n            bytes32[] storage sarcoIds = s.archaeologistSarcophagi[addresses[i]];\\n\\n            // For each sarco id, if the sarco id is not included in successes and resurrection time\\n            // has passed, it's a failure\\n            for (uint j = 0; j < sarcoIds.length; j++) {\\n                LibTypes.Sarcophagus storage sarco = s.sarcophagi[sarcoIds[j]];\\n                if (\\n                    !this.getArchaeologistSuccessOnSarcophagus(addresses[i], sarcoIds[j]) &&\\n                    sarco.resurrectionTime != 2 ** 256 - 1 &&\\n                    block.timestamp > sarco.resurrectionTime + s.gracePeriod\\n                ) {\\n                    failures += 1;\\n                }\\n            }\\n\\n            statsList[i] = ArchaeologistStatistics(\\n                this.getArchaeologistSuccessesCount(addresses[i]),\\n                this.getArchaeologistAccusalsCount(addresses[i]),\\n                this.getArchaeologistCleanupsCount(addresses[i]),\\n                failures\\n            );\\n        }\\n\\n        return statsList;\\n    }\\n\\n    struct SarcophagusResponse {\\n        uint256 resurrectionTime;\\n        uint256 previousRewrapTime;\\n        bool isCompromised;\\n        bool isCleaned;\\n        string name;\\n        uint8 threshold;\\n        uint256 maximumRewrapInterval;\\n        string arweaveTxId;\\n        address embalmerAddress;\\n        address recipientAddress;\\n        address[] archaeologistAddresses;\\n        uint8 publishedPrivateKeyCount;\\n        bool hasLockedBond;\\n    }\\n\\n    /// @notice Returns data on the sarcophagus with the supplied id\\n    /// includes aggregate data on cursed archaeologists associated with the sarcophagus\\n    ///     - publishedPrivateKeyCount - the total number of private keys published by archaeologists on the sarcophagus\\n    ///     - hasLockedBond - true if archaeologists still have bond locked in the contract for this sarcophagus\\n    /// @param sarcoId The identifier of the sarcophagus being returned\\n    function getSarcophagus(bytes32 sarcoId) external view returns (SarcophagusResponse memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        uint8 publishedPrivateKeyCount = 0;\\n        bool hasLockedBond = false;\\n        for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n            // archaeologist has published a private key\\n            if (\\n                sarcophagus\\n                    .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                    .privateKey != 0\\n            ) {\\n                publishedPrivateKeyCount++;\\n            } else if (\\n                !sarcophagus\\n                    .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                    .isAccused &&\\n                !sarcophagus.isCompromised &&\\n                !sarcophagus.isCleaned &&\\n                sarcophagus.resurrectionTime != 2 ** 256 - 1\\n            ) {\\n                // if the sarcophagus is not compromised, buried, or cleaned and\\n                // one or more unaccused archaeologists hasn't published a private key there is locked bond on the sarcophagus\\n                hasLockedBond = true;\\n            }\\n        }\\n\\n        return\\n            SarcophagusResponse({\\n                resurrectionTime: sarcophagus.resurrectionTime,\\n                previousRewrapTime: sarcophagus.previousRewrapTime,\\n                isCompromised: sarcophagus.isCompromised,\\n                isCleaned: sarcophagus.isCleaned,\\n                name: sarcophagus.name,\\n                threshold: sarcophagus.threshold,\\n                maximumRewrapInterval: sarcophagus.maximumRewrapInterval,\\n                arweaveTxId: sarcophagus.arweaveTxId,\\n                embalmerAddress: sarcophagus.embalmerAddress,\\n                recipientAddress: sarcophagus.recipientAddress,\\n                archaeologistAddresses: sarcophagus.cursedArchaeologistAddresses,\\n                publishedPrivateKeyCount: publishedPrivateKeyCount,\\n                hasLockedBond: hasLockedBond\\n            });\\n    }\\n\\n    /// @notice Given an embalmer's address, returns the identifiers of all\\n    /// sarcophagi that the embalmer has created.\\n    /// @param embalmer The address of the embalmer whose sarcophagi are being\\n    /// returned\\n    function getEmbalmerSarcophagi(address embalmer) external view returns (bytes32[] memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.embalmerSarcophagi[embalmer];\\n    }\\n\\n    /// @notice Given an archaeologist's address, returns the identifiers of all\\n    /// sarcophagi that the archaeologist has participated in.\\n    /// @param archaeologist The address of the archaeologist whose sarcophagi\\n    /// are being returned\\n    function getArchaeologistSarcophagi(\\n        address archaeologist\\n    ) external view returns (bytes32[] memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.archaeologistSarcophagi[archaeologist];\\n    }\\n\\n    /// @notice Given a recipient's address, returns the identifiers of all\\n    /// sarcophagi that the recipient has participated in.\\n    /// @param recipient The address of the recipient whose sarcophagi are being\\n    /// returned\\n    function getRecipientSarcophagi(address recipient) external view returns (bytes32[] memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.recipientSarcophagi[recipient];\\n    }\\n\\n    /// @notice Returns the data stored on a sarcophagus for an archaeologist.\\n    /// @param sarcoId The identifier of the sarcophagus whose data is being\\n    /// returned\\n    /// @param archaeologist The address of the archaeologist whose data is\\n    /// being returned\\n    function getSarcophagusArchaeologist(\\n        bytes32 sarcoId,\\n        address archaeologist\\n    ) external view returns (LibTypes.CursedArchaeologist memory) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        return s.sarcophagi[sarcoId].cursedArchaeologists[archaeologist];\\n    }\\n}\\n\",\"keccak256\":\"0x19cafacac5e4e8e7b13d4ce4fb4ffc964efdf39cd35bed534962abf757321de2\",\"license\":\"Unlicense\"},\"contracts/libraries/LibBonds.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"./LibErrors.sol\\\";\\n\\nimport \\\"../facets/EmbalmerFacet.sol\\\";\\n\\nlibrary LibBonds {\\n    /// @notice Decreases the amount stored in the freeBond mapping for an\\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\\n    /// the amount.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being decreased\\n    /// @param amount The amount to decrease the free bond by\\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current free bond\\n        if (amount > s.archaeologistProfiles[archaeologist].freeBond) {\\n            revert LibErrors.NotEnoughFreeBond(\\n                s.archaeologistProfiles[archaeologist].freeBond,\\n                amount\\n            );\\n        }\\n\\n        // Decrease the free bond amount\\n        s.archaeologistProfiles[archaeologist].freeBond -= amount;\\n    }\\n\\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\\n    /// archaeologist, without respectively increasing their free bond.\\n    /// @param archaeologist The address of the archaeologist\\n    /// @param amount The amount to slash\\n    function decreaseCursedBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current cursed bond\\n        if (amount > s.archaeologistProfiles[archaeologist].cursedBond) {\\n            revert LibErrors.NotEnoughCursedBond(\\n                s.archaeologistProfiles[archaeologist].cursedBond,\\n                amount\\n            );\\n        }\\n\\n        s.archaeologistProfiles[archaeologist].cursedBond -= amount;\\n    }\\n\\n    /// @notice Bonds the archaeologist to a sarcophagus.\\n    /// This does the following:\\n    ///   - adds the archaeologist's curse params and address to the sarcophagus\\n    ///   - calculates digging fees to be locked and later paid to archaeologist\\n    ///   - locks this amount from archaeologist's free bond; increases cursedBond by same\\n    ///   - Adds the sarcophagus' id to the archaeologist's record of bonded sarcophagi\\n    /// @param sarcoId Id of the sarcophagus with which to curse the archaeologist\\n    /// @param archaeologist The archaologist to curse, with associated parameters of the curse\\n    ///\\n    /// @return the amount of digging fees due the embalmer for this curse\\n    function curseArchaeologist(\\n        bytes32 sarcoId,\\n        EmbalmerFacet.CurseParams calldata archaeologist,\\n        uint256 index\\n    ) internal returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        sarcophagus.cursedArchaeologists[archaeologist.archAddress] = LibTypes.CursedArchaeologist({\\n            publicKey: archaeologist.publicKey,\\n            privateKey: 0,\\n            isAccused: false,\\n            diggingFeePerSecond: archaeologist.diggingFeePerSecond\\n        });\\n        sarcophagus.cursedArchaeologistAddresses[index] = archaeologist.archAddress;\\n\\n        // Calculate digging fees due for this time period (creationTime/previousRewrapTime -> resurrectionTime)\\n        uint256 diggingFeesDue = archaeologist.diggingFeePerSecond *\\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n        // Use cursed bond percentage to determine how much bond to lock up\\n        uint256 bondToCurse = (diggingFeesDue * s.cursedBondPercentage) / 100;\\n\\n        decreaseFreeBond(archaeologist.archAddress, bondToCurse);\\n        s.archaeologistProfiles[archaeologist.archAddress].cursedBond += bondToCurse;\\n\\n        s.archaeologistSarcophagi[archaeologist.archAddress].push(sarcoId);\\n\\n        return diggingFeesDue;\\n    }\\n\\n    /// @notice Calculates and unlocks an archaeologist's cursed bond. Pays due digging fees to the archaeologist.\\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\\n    /// @param archaeologistAddress the address of the archaeologist to free\\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\\n            .sarcophagi[sarcoId]\\n            .cursedArchaeologists[archaeologistAddress];\\n\\n        uint256 diggingFeeAmount = cursedArchaeologist.diggingFeePerSecond *\\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\\n\\n        uint256 cursedBondAmount = diggingFeeAmount * sarcophagus.cursedBondPercentage / 100;\\n\\n        decreaseCursedBond(archaeologistAddress, cursedBondAmount);\\n        s.archaeologistProfiles[archaeologistAddress].freeBond += cursedBondAmount;\\n        s.archaeologistRewards[archaeologistAddress] += diggingFeeAmount;\\n    }\\n}\\n\",\"keccak256\":\"0xb5473904e43e2e8ef1e4dec6f2665ce1820ee9ae672d17a32b30ab676224822f\",\"license\":\"Unlicense\"},\"contracts/libraries/LibErrors.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title A collection of Errors\\n * @notice This library defines all of the Errors that the Sarcophagus system\\n * uses.\\n */\\nlibrary LibErrors {\\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\\n\\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\\n\\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\\n\\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\\n\\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\\n\\n    error SarcophagusInactive(bytes32 sarcoId);\\n\\n    error SarcophagusCompromised(bytes32 sarcoId);\\n\\n    error SenderNotEmbalmer(address sender, address embalmer);\\n\\n    error InvalidSignature(\\n        // address recovered from signature via ecrecover\\n        address recoveredAddress,\\n        // address we expected to have signed the data\\n        address expectedAddress\\n    );\\n}\\n\",\"keccak256\":\"0xe2e2e99c7e608571b8d072ceacc037b744ca637ad66633af1c2f10e935eb8567\",\"license\":\"Unlicense\"},\"contracts/libraries/LibTypes.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title Types shared across facets for the Sarcophagus diamond\\n */\\nlibrary LibTypes {\\n    struct Sarcophagus {\\n        // Also used for existence checks -- does not exist if 0\\n        uint256 resurrectionTime;\\n        uint256 previousRewrapTime;\\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\\n        bool isCompromised;\\n        bool isCleaned;\\n        uint8 threshold;\\n        string name;\\n        uint256 maximumRewrapInterval;\\n        uint256 maximumResurrectionTime;\\n        string arweaveTxId;\\n        address embalmerAddress;\\n        address recipientAddress;\\n        address[] cursedArchaeologistAddresses;\\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\\n        uint256 cursedBondPercentage;\\n    }\\n\\n    struct CursedArchaeologist {\\n        uint256 diggingFeePerSecond;\\n        // Also used for publish checks -- has not published if 0\\n        bytes32 privateKey;\\n        // Also used for curse checks -- is not bonded if length is 0\\n        bytes publicKey;\\n        bool isAccused;\\n    }\\n\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    struct ArchaeologistProfile {\\n        // Also used for existence checks -- does not exist if 0\\n        uint256 maximumRewrapInterval;\\n        uint256 maximumResurrectionTime;\\n        string peerId;\\n        uint256 minimumDiggingFeePerSecond;\\n        uint256 freeBond;\\n        uint256 cursedBond;\\n    }\\n}\\n\",\"keccak256\":\"0xb6ded0e9a252560ab14a589c47df996bcf1f0b9cd4910aa1bf0da6fd01c99232\",\"license\":\"Unlicense\"},\"contracts/libraries/LibUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport \\\"../facets/ThirdPartyFacet.sol\\\";\\nimport \\\"./LibTypes.sol\\\";\\nimport \\\"../facets/EmbalmerFacet.sol\\\";\\n\\n/**\\n * @title Utility functions used within the Sarcophagus system\\n * @notice This library implements various functions that are used throughout\\n * Sarcophagus, mainly to DRY up the codebase\\n * @dev these functions are all stateless, public, pure/view\\n */\\nlibrary LibUtils {\\n    /**\\n     * @notice The archaeologist needs to sign off on two pieces of data\\n     * to guarantee their unrwap will be successful\\n     *\\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\\n     * @param curseParams parameters of curse signed by archaeologist\\n     */\\n    function verifyArchaeologistSignature(\\n        uint256 agreedMaximumRewrapInterval,\\n        uint256 maximumResurrectionTime,\\n        uint256 timestamp,\\n        EmbalmerFacet.CurseParams calldata curseParams\\n    ) internal pure {\\n        // Hash the hash of the data payload\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encode(\\n                        curseParams.publicKey,\\n                        agreedMaximumRewrapInterval,\\n                        maximumResurrectionTime,\\n                        curseParams.diggingFeePerSecond,\\n                        timestamp\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Generate the address from the signature.\\n        // ecrecover should always return a valid address.\\n        address recoveredAddress = ecrecover(\\n            messageHash,\\n            curseParams.v,\\n            curseParams.r,\\n            curseParams.s\\n        );\\n\\n        if (recoveredAddress != curseParams.archAddress) {\\n            revert LibErrors.InvalidSignature(recoveredAddress, curseParams.archAddress);\\n        }\\n    }\\n\\n    /// @notice Verifies that a signature and public key were created from the same private key\\n    /// @param sarcoId the sarcoId that was signed\\n    /// @param paymentAddress the payment address that was signed\\n    /// @param publicKey an uncompressed 65 byte secp256k1 public key\\n    /// @param signature signature on the sarco id and payment address\\n    /// @return true if the signature was signed by the private key corresponding to the supplied public key\\n    function verifyAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes calldata publicKey,\\n        LibTypes.Signature calldata signature\\n    ) internal pure returns (bool) {\\n        // removes the 0x04 prefix from an uncompressed public key\\n        bytes memory truncatedPublicKey = new bytes(publicKey.length - 1);\\n        for (uint256 i = 1; i < publicKey.length; i++) {\\n            truncatedPublicKey[i - 1] = publicKey[i];\\n        }\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(abi.encode(sarcoId, paymentAddress))\\n            )\\n        );\\n        // Use ecrecover to get the address that signed the message\\n        address signingAddress = ecrecover(messageHash, signature.v, signature.r, signature.s);\\n\\n        address publicKeyAddress = address(\\n            uint160(\\n                uint256(keccak256(truncatedPublicKey)) &\\n                    0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n            )\\n        );\\n\\n        return signingAddress == publicKeyAddress;\\n    }\\n\\n    /// @notice Checks if an archaeologist profile exists and\\n    /// reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check existence of\\n    function revertIfArchProfileExists(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval != 0) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Checks if an archaeologist profile doesn't exist and reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check lack of existence of\\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval == 0) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\\n    /// @param totalDiggingFees to be paid. Protocol fee is a percentage of this\\n    /// @return The protocol fees amount\\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 100;\\n    }\\n}\\n\",\"keccak256\":\"0xfb87b9c1495d1044d9bf70a5a67bcc6e798b6584159a3df9c5a0ab297c693612\",\"license\":\"Unlicense\"},\"contracts/storage/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\n/**\\n * Global diamond storage struct to be shared across facets\\n * TODO: Implement diamond storage pattern and consider splitting storage into facet specific structs\\n */\\nstruct AppStorage {\\n    // SARCO token contract\\n    IERC20 sarcoToken;\\n    // total protocol fees available to be withdrawn by the admin\\n    uint256 totalProtocolFees;\\n    /**\\n     * Protocol level admin configurations\\n     */\\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap\\n    uint256 protocolFeeBasePercentage;\\n    // % of digging fees archaeologists must have locked up per curse in cursed bond\\n    uint256 cursedBondPercentage;\\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time\\n    uint256 gracePeriod;\\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated\\n    uint256 expirationThreshold;\\n    // window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\\n    uint256 embalmerClaimWindow;\\n\\n    // registered archaeologist addresses\\n    address[] archaeologistProfileAddresses;\\n\\n    /**\\n     * Ownership mappings\\n     */\\n    // embalmer address => ids of sarcophagi they've created\\n    mapping(address => bytes32[]) embalmerSarcophagi;\\n    // archaeologist address =>  ids of sarcophagi they're protecting\\n    mapping(address => bytes32[]) archaeologistSarcophagi;\\n    // recipient address =>  ids of sarcophagi they're recipient on\\n    mapping(address => bytes32[]) recipientSarcophagi;\\n    // public key => archaeologist address\\n    mapping(bytes => address) publicKeyToArchaeologistAddress;\\n    // sarcophagus id => sarcophagus object\\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\\n    // archaeologist address => profile\\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\\n    // current balance of rewards available for the archaeologist to withdraw\\n    mapping(address => uint256) archaeologistRewards;\\n    /**\\n     * Archaeologist reputation statistics: address => sarcoIds\\n     * todo: could these be organized differently?\\n     */\\n    mapping(address => bytes32[]) archaeologistSuccesses;\\n    mapping(address => bytes32[]) archaeologistAccusals;\\n    mapping(address => bytes32[]) archaeologistCleanups;\\n}\\n\\nlibrary LibAppStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"sarcophagus.storage.dev2\\\");\\n\\n    function getAppStorage() internal pure returns (AppStorage storage s) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xded21cf0fb81963d474fb0a2f4aaf1d2855c374b9a26b478559cc7fcd3c59c5f\",\"license\":\"Unlicense\"},\"hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x2205345e83eb86f5281f159a9215a096cb6d404782619f9b8e9d7a4a46c32a37\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612cd3806100206000396000f3fe608060405234801561001057600080fd5b506004361061018e5760003560e01c80638fbd55d2116100de578063daa4d21b11610097578063dcfcb90111610071578063dcfcb90114610547578063de116f0614610565578063ef60e4e714610595578063fb6fffb5146105c55761018e565b8063daa4d21b146104c9578063dbd18388146104f9578063dc231f43146105175761018e565b80638fbd55d2146103cd5780639c545639146103fd5780639fdaded11461041b578063a9328dcc14610439578063c34e9bff14610469578063d31dedd1146104995761018e565b806357babbaf1161014b5780636c99bedc116101255780636c99bedc1461031f57806379ee54f71461034f5780637aa9fd2f1461037f57806387927ce61461039d5761018e565b806357babbaf1461028f5780636b74d55a146102bf5780636ba5c8ef146102ef5761018e565b80632569090214610193578063284f34de146101c357806331baea67146101f35780633fbb89301461021157806342e10bc81461022f5780634d0b67671461025f575b600080fd5b6101ad60048036038101906101a89190611dd0565b6105f5565b6040516101ba9190611e16565b60405180910390f35b6101dd60048036038101906101d89190611e5d565b61064f565b6040516101ea9190611eb6565b60405180910390f35b6101fb6106c3565b6040516102089190611e16565b60405180910390f35b6102196106db565b6040516102269190611f8f565b60405180910390f35b61024960048036038101906102449190611dd0565b610778565b60405161025691906120e2565b60405180910390f35b61027960048036038101906102749190611dd0565b6108ad565b60405161028691906121c2565b60405180910390f35b6102a960048036038101906102a491906121e4565b610953565b6040516102b69190612220565b60405180910390f35b6102d960048036038101906102d49190612383565b6109a9565b6040516102e691906124d0565b60405180910390f35b6103096004803603810190610304919061251e565b610e05565b6040516103169190612579565b60405180910390f35b61033960048036038101906103349190611e5d565b610e7a565b6040516103469190611eb6565b60405180910390f35b61036960048036038101906103649190611dd0565b610eee565b6040516103769190611e16565b60405180910390f35b610387610f45565b6040516103949190611e16565b60405180910390f35b6103b760048036038101906103b29190611dd0565b610f5d565b6040516103c49190611e16565b60405180910390f35b6103e760048036038101906103e29190611dd0565b610fb7565b6040516103f49190611e16565b60405180910390f35b610405611011565b6040516104129190611e16565b60405180910390f35b610423611029565b6040516104309190611e16565b60405180910390f35b610453600480360381019061044e9190612383565b611041565b60405161046091906126df565b60405180910390f35b610483600480360381019061047e9190611dd0565b611282565b60405161049091906121c2565b60405180910390f35b6104b360048036038101906104ae9190611dd0565b611328565b6040516104c09190611e16565b60405180910390f35b6104e360048036038101906104de9190611dd0565b611382565b6040516104f09190611e16565b60405180910390f35b6105016113dc565b60405161050e9190611e16565b60405180910390f35b610531600480360381019061052c9190612701565b6113f4565b60405161053e9190612808565b60405180910390f35b61054f611532565b60405161055c9190611e16565b60405180910390f35b61057f600480360381019061057a919061282a565b61154a565b60405161058c9190612a09565b60405180910390f35b6105af60048036038101906105aa9190611dd0565b611a50565b6040516105bc91906121c2565b60405180910390f35b6105df60048036038101906105da9190611e5d565b611af6565b6040516105ec9190611eb6565b60405180910390f35b600080610600611b6a565b905080600f0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080549050915050919050565b60008061065a611b6a565b905080600f0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002083815481106106af576106ae612a2b565b5b906000526020600020015491505092915050565b6000806106ce611b6a565b9050806006015491505090565b606060006106e7611b6a565b90508060070180548060200260200160405190810160405280929190818152602001828054801561076d57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311610723575b505050505091505090565b610780611c33565b600061078a611b6a565b905061079583611b97565b80600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060c0016040529081600082015481526020016001820154815260200160028201805461080590612a89565b80601f016020809104026020016040519081016040528092919081815260200182805461083190612a89565b801561087e5780601f106108535761010080835404028352916020019161087e565b820191906000526020600020905b81548152906001019060200180831161086157829003601f168201915b505050505081526020016003820154815260200160048201548152602001600582015481525050915050919050565b606060006108b9611b6a565b905080600a0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561094657602002820191906000526020600020905b815481526020019060010190808311610932575b5050505050915050919050565b60008061095e611b6a565b905080600701838154811061097657610975612a2b565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b606060006109b5611b6a565b90506000835167ffffffffffffffff8111156109d4576109d3612240565b5b604051908082528060200260200182016040528015610a0d57816020015b6109fa611c69565b8152602001906001900390816109f25790505b50905060005b8451811015610dfa57600080846009016000888581518110610a3857610a37612a2b565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060005b8180549050811015610bec57600086600c016000848481548110610aa657610aa5612a2b565b5b9060005260206000200154815260200190815260200160002090503073ffffffffffffffffffffffffffffffffffffffff16636ba5c8ef8a8781518110610af057610aef612a2b565b5b6020026020010151858581548110610b0b57610b0a612a2b565b5b90600052602060002001546040518363ffffffff1660e01b8152600401610b33929190612aba565b602060405180830381865afa158015610b50573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b749190612b0f565b158015610ba557507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff816000015414155b8015610bc3575086600401548160000154610bc09190612b6b565b42115b15610bd857600184610bd59190612b6b565b93505b508080610be490612bc1565b915050610a7f565b5060405180608001604052803073ffffffffffffffffffffffffffffffffffffffff1663256909028a8781518110610c2757610c26612a2b565b5b60200260200101516040518263ffffffff1660e01b8152600401610c4b9190612220565b602060405180830381865afa158015610c68573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c8c9190612c1e565b81526020013073ffffffffffffffffffffffffffffffffffffffff1663daa4d21b8a8781518110610cc057610cbf612a2b565b5b60200260200101516040518263ffffffff1660e01b8152600401610ce49190612220565b602060405180830381865afa158015610d01573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d259190612c1e565b81526020013073ffffffffffffffffffffffffffffffffffffffff1663d31dedd18a8781518110610d5957610d58612a2b565b5b60200260200101516040518263ffffffff1660e01b8152600401610d7d9190612220565b602060405180830381865afa158015610d9a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dbe9190612c1e565b815260200183815250848481518110610dda57610dd9612a2b565b5b602002602001018190525050508080610df290612bc1565b915050610a13565b508092505050919050565b600080610e10611b6a565b90506000801b81600c016000858152602001908152602001600020600a0160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010154141591505092915050565b600080610e85611b6a565b90508060100160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208381548110610eda57610ed9612a2b565b5b906000526020600020015491505092915050565b600080610ef9611b6a565b905080600e0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054915050919050565b600080610f50611b6a565b9050806005015491505090565b600080610f68611b6a565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154915050919050565b600080610fc2611b6a565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154915050919050565b60008061101c611b6a565b9050806001015491505090565b600080611034611b6a565b9050806002015491505090565b6060600061104d611b6a565b90506000835167ffffffffffffffff81111561106c5761106b612240565b5b6040519080825280602002602001820160405280156110a557816020015b611092611c33565b81526020019060019003908161108a5790505b50905060005b845181101561127757600083600d0160008784815181106110cf576110ce612a2b565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015403156112645782600d01600086838151811061113457611133612a2b565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060c001604052908160008201548152602001600182015481526020016002820180546111a590612a89565b80601f01602080910402602001604051908101604052809291908181526020018280546111d190612a89565b801561121e5780601f106111f35761010080835404028352916020019161121e565b820191906000526020600020905b81548152906001019060200180831161120157829003601f168201915b50505050508152602001600382015481526020016004820154815260200160058201548152505082828151811061125857611257612a2b565b5b60200260200101819052505b808061126f90612bc1565b9150506110ab565b508092505050919050565b6060600061128e611b6a565b90508060080160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561131b57602002820191906000526020600020905b815481526020019060010190808311611307575b5050505050915050919050565b600080611333611b6a565b90508060110160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080549050915050919050565b60008061138d611b6a565b90508060100160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080549050915050919050565b6000806113e7611b6a565b9050806004015491505090565b6113fc611c91565b6000611406611b6a565b905080600c016000858152602001908152602001600020600a0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020604051806080016040529081600082015481526020016001820154815260200160028201805461148c90612a89565b80601f01602080910402602001604051908101604052809291908181526020018280546114b890612a89565b80156115055780601f106114da57610100808354040283529160200191611505565b820191906000526020600020905b8154815290600101906020018083116114e857829003601f168201915b505050505081526020016003820160009054906101000a900460ff16151515158152505091505092915050565b60008061153d611b6a565b9050806003015491505090565b611552611cbe565b600061155c611b6a565b9050600081600c016000858152602001908152602001600020905060008160000154036115c057836040517f018da6880000000000000000000000000000000000000000000000000000000081526004016115b79190611eb6565b60405180910390fd5b60008060005b836009018054905081101561178d576000801b84600a0160008660090184815481106115f5576115f4612a2b565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600101541461167657828061166e90612c4b565b93505061177a565b83600a01600085600901838154811061169257611691612a2b565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160009054906101000a900460ff1615801561172457508360020160009054906101000a900460ff16155b801561173f57508360020160019054906101000a900460ff16155b801561176f57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff846000015414155b1561177957600191505b5b808061178590612bc1565b9150506115c6565b50604051806101a0016040528084600001548152602001846001015481526020018460020160009054906101000a900460ff16151581526020018460020160019054906101000a900460ff16151581526020018460030180546117ef90612a89565b80601f016020809104026020016040519081016040528092919081815260200182805461181b90612a89565b80156118685780601f1061183d57610100808354040283529160200191611868565b820191906000526020600020905b81548152906001019060200180831161184b57829003601f168201915b505050505081526020018460020160029054906101000a900460ff1660ff168152602001846004015481526020018460060180546118a590612a89565b80601f01602080910402602001604051908101604052809291908181526020018280546118d190612a89565b801561191e5780601f106118f35761010080835404028352916020019161191e565b820191906000526020600020905b81548152906001019060200180831161190157829003601f168201915b505050505081526020018460070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018460080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200184600901805480602002602001604051908101604052809291908181526020018280548015611a2c57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116119e2575b505050505081526020018360ff168152602001821515815250945050505050919050565b60606000611a5c611b6a565b90508060090160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015611ae957602002820191906000526020600020905b815481526020019060010190808311611ad5575b5050505050915050919050565b600080611b01611b6a565b90508060110160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208381548110611b5657611b55612a2b565b5b906000526020600020015491505092915050565b6000807f2319d9fa277d38834e73ba5e2482efd90323373359a32bb0c96b78353987994190508091505090565b6000611ba1611b6a565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015403611c2f576001826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401611c26929190612c74565b60405180910390fd5b5050565b6040518060c001604052806000815260200160008152602001606081526020016000815260200160008152602001600081525090565b6040518060800160405280600081526020016000815260200160008152602001600081525090565b60405180608001604052806000815260200160008019168152602001606081526020016000151581525090565b604051806101a00160405280600081526020016000815260200160001515815260200160001515815260200160608152602001600060ff1681526020016000815260200160608152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160608152602001600060ff1681526020016000151581525090565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611d9d82611d72565b9050919050565b611dad81611d92565b8114611db857600080fd5b50565b600081359050611dca81611da4565b92915050565b600060208284031215611de657611de5611d68565b5b6000611df484828501611dbb565b91505092915050565b6000819050919050565b611e1081611dfd565b82525050565b6000602082019050611e2b6000830184611e07565b92915050565b611e3a81611dfd565b8114611e4557600080fd5b50565b600081359050611e5781611e31565b92915050565b60008060408385031215611e7457611e73611d68565b5b6000611e8285828601611dbb565b9250506020611e9385828601611e48565b9150509250929050565b6000819050919050565b611eb081611e9d565b82525050565b6000602082019050611ecb6000830184611ea7565b92915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b611f0681611d92565b82525050565b6000611f188383611efd565b60208301905092915050565b6000602082019050919050565b6000611f3c82611ed1565b611f468185611edc565b9350611f5183611eed565b8060005b83811015611f82578151611f698882611f0c565b9750611f7483611f24565b925050600181019050611f55565b5085935050505092915050565b60006020820190508181036000830152611fa98184611f31565b905092915050565b611fba81611dfd565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611ffa578082015181840152602081019050611fdf565b83811115612009576000848401525b50505050565b6000601f19601f8301169050919050565b600061202b82611fc0565b6120358185611fcb565b9350612045818560208601611fdc565b61204e8161200f565b840191505092915050565b600060c0830160008301516120716000860182611fb1565b5060208301516120846020860182611fb1565b506040830151848203604086015261209c8282612020565b91505060608301516120b16060860182611fb1565b5060808301516120c46080860182611fb1565b5060a08301516120d760a0860182611fb1565b508091505092915050565b600060208201905081810360008301526120fc8184612059565b905092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61213981611e9d565b82525050565b600061214b8383612130565b60208301905092915050565b6000602082019050919050565b600061216f82612104565b612179818561210f565b935061218483612120565b8060005b838110156121b557815161219c888261213f565b97506121a783612157565b925050600181019050612188565b5085935050505092915050565b600060208201905081810360008301526121dc8184612164565b905092915050565b6000602082840312156121fa576121f9611d68565b5b600061220884828501611e48565b91505092915050565b61221a81611d92565b82525050565b60006020820190506122356000830184612211565b92915050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6122788261200f565b810181811067ffffffffffffffff8211171561229757612296612240565b5b80604052505050565b60006122aa611d5e565b90506122b6828261226f565b919050565b600067ffffffffffffffff8211156122d6576122d5612240565b5b602082029050602081019050919050565b600080fd5b60006122ff6122fa846122bb565b6122a0565b90508083825260208201905060208402830185811115612322576123216122e7565b5b835b8181101561234b57806123378882611dbb565b845260208401935050602081019050612324565b5050509392505050565b600082601f83011261236a5761236961223b565b5b813561237a8482602086016122ec565b91505092915050565b60006020828403121561239957612398611d68565b5b600082013567ffffffffffffffff8111156123b7576123b6611d6d565b5b6123c384828501612355565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b60808201600082015161240e6000850182611fb1565b5060208201516124216020850182611fb1565b5060408201516124346040850182611fb1565b5060608201516124476060850182611fb1565b50505050565b600061245983836123f8565b60808301905092915050565b6000602082019050919050565b600061247d826123cc565b61248781856123d7565b9350612492836123e8565b8060005b838110156124c35781516124aa888261244d565b97506124b583612465565b925050600181019050612496565b5085935050505092915050565b600060208201905081810360008301526124ea8184612472565b905092915050565b6124fb81611e9d565b811461250657600080fd5b50565b600081359050612518816124f2565b92915050565b6000806040838503121561253557612534611d68565b5b600061254385828601611dbb565b925050602061255485828601612509565b9150509250929050565b60008115159050919050565b6125738161255e565b82525050565b600060208201905061258e600083018461256a565b92915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600060c0830160008301516125d86000860182611fb1565b5060208301516125eb6020860182611fb1565b50604083015184820360408601526126038282612020565b91505060608301516126186060860182611fb1565b50608083015161262b6080860182611fb1565b5060a083015161263e60a0860182611fb1565b508091505092915050565b600061265583836125c0565b905092915050565b6000602082019050919050565b600061267582612594565b61267f818561259f565b935083602082028501612691856125b0565b8060005b858110156126cd57848403895281516126ae8582612649565b94506126b98361265d565b925060208a01995050600181019050612695565b50829750879550505050505092915050565b600060208201905081810360008301526126f9818461266a565b905092915050565b6000806040838503121561271857612717611d68565b5b600061272685828601612509565b925050602061273785828601611dbb565b9150509250929050565b600081519050919050565b600082825260208201905092915050565b600061276882612741565b612772818561274c565b9350612782818560208601611fdc565b61278b8161200f565b840191505092915050565b61279f8161255e565b82525050565b60006080830160008301516127bd6000860182611fb1565b5060208301516127d06020860182612130565b50604083015184820360408601526127e8828261275d565b91505060608301516127fd6060860182612796565b508091505092915050565b6000602082019050818103600083015261282281846127a5565b905092915050565b6000602082840312156128405761283f611d68565b5b600061284e84828501612509565b91505092915050565b600060ff82169050919050565b61286d81612857565b82525050565b600082825260208201905092915050565b600061288f82611ed1565b6128998185612873565b93506128a483611eed565b8060005b838110156128d55781516128bc8882611f0c565b97506128c783611f24565b9250506001810190506128a8565b5085935050505092915050565b60006101a0830160008301516128fb6000860182611fb1565b50602083015161290e6020860182611fb1565b5060408301516129216040860182612796565b5060608301516129346060860182612796565b506080830151848203608086015261294c8282612020565b91505060a083015161296160a0860182612864565b5060c083015161297460c0860182611fb1565b5060e083015184820360e086015261298c8282612020565b9150506101008301516129a3610100860182611efd565b506101208301516129b8610120860182611efd565b506101408301518482036101408601526129d28282612884565b9150506101608301516129e9610160860182612864565b506101808301516129fe610180860182612796565b508091505092915050565b60006020820190508181036000830152612a2381846128e2565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680612aa157607f821691505b602082108103612ab457612ab3612a5a565b5b50919050565b6000604082019050612acf6000830185612211565b612adc6020830184611ea7565b9392505050565b612aec8161255e565b8114612af757600080fd5b50565b600081519050612b0981612ae3565b92915050565b600060208284031215612b2557612b24611d68565b5b6000612b3384828501612afa565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000612b7682611dfd565b9150612b8183611dfd565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115612bb657612bb5612b3c565b5b828201905092915050565b6000612bcc82611dfd565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612bfe57612bfd612b3c565b5b600182019050919050565b600081519050612c1881611e31565b92915050565b600060208284031215612c3457612c33611d68565b5b6000612c4284828501612c09565b91505092915050565b6000612c5682612857565b915060ff8203612c6957612c68612b3c565b5b600182019050919050565b6000604082019050612c89600083018561256a565b612c966020830184612211565b939250505056fea2646970667358221220830700e476802ad7bd8dceec2eed3791fe959adf6649d8bbbf42100e1ba299f264736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061018e5760003560e01c80638fbd55d2116100de578063daa4d21b11610097578063dcfcb90111610071578063dcfcb90114610547578063de116f0614610565578063ef60e4e714610595578063fb6fffb5146105c55761018e565b8063daa4d21b146104c9578063dbd18388146104f9578063dc231f43146105175761018e565b80638fbd55d2146103cd5780639c545639146103fd5780639fdaded11461041b578063a9328dcc14610439578063c34e9bff14610469578063d31dedd1146104995761018e565b806357babbaf1161014b5780636c99bedc116101255780636c99bedc1461031f57806379ee54f71461034f5780637aa9fd2f1461037f57806387927ce61461039d5761018e565b806357babbaf1461028f5780636b74d55a146102bf5780636ba5c8ef146102ef5761018e565b80632569090214610193578063284f34de146101c357806331baea67146101f35780633fbb89301461021157806342e10bc81461022f5780634d0b67671461025f575b600080fd5b6101ad60048036038101906101a89190611dd0565b6105f5565b6040516101ba9190611e16565b60405180910390f35b6101dd60048036038101906101d89190611e5d565b61064f565b6040516101ea9190611eb6565b60405180910390f35b6101fb6106c3565b6040516102089190611e16565b60405180910390f35b6102196106db565b6040516102269190611f8f565b60405180910390f35b61024960048036038101906102449190611dd0565b610778565b60405161025691906120e2565b60405180910390f35b61027960048036038101906102749190611dd0565b6108ad565b60405161028691906121c2565b60405180910390f35b6102a960048036038101906102a491906121e4565b610953565b6040516102b69190612220565b60405180910390f35b6102d960048036038101906102d49190612383565b6109a9565b6040516102e691906124d0565b60405180910390f35b6103096004803603810190610304919061251e565b610e05565b6040516103169190612579565b60405180910390f35b61033960048036038101906103349190611e5d565b610e7a565b6040516103469190611eb6565b60405180910390f35b61036960048036038101906103649190611dd0565b610eee565b6040516103769190611e16565b60405180910390f35b610387610f45565b6040516103949190611e16565b60405180910390f35b6103b760048036038101906103b29190611dd0565b610f5d565b6040516103c49190611e16565b60405180910390f35b6103e760048036038101906103e29190611dd0565b610fb7565b6040516103f49190611e16565b60405180910390f35b610405611011565b6040516104129190611e16565b60405180910390f35b610423611029565b6040516104309190611e16565b60405180910390f35b610453600480360381019061044e9190612383565b611041565b60405161046091906126df565b60405180910390f35b610483600480360381019061047e9190611dd0565b611282565b60405161049091906121c2565b60405180910390f35b6104b360048036038101906104ae9190611dd0565b611328565b6040516104c09190611e16565b60405180910390f35b6104e360048036038101906104de9190611dd0565b611382565b6040516104f09190611e16565b60405180910390f35b6105016113dc565b60405161050e9190611e16565b60405180910390f35b610531600480360381019061052c9190612701565b6113f4565b60405161053e9190612808565b60405180910390f35b61054f611532565b60405161055c9190611e16565b60405180910390f35b61057f600480360381019061057a919061282a565b61154a565b60405161058c9190612a09565b60405180910390f35b6105af60048036038101906105aa9190611dd0565b611a50565b6040516105bc91906121c2565b60405180910390f35b6105df60048036038101906105da9190611e5d565b611af6565b6040516105ec9190611eb6565b60405180910390f35b600080610600611b6a565b905080600f0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080549050915050919050565b60008061065a611b6a565b905080600f0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002083815481106106af576106ae612a2b565b5b906000526020600020015491505092915050565b6000806106ce611b6a565b9050806006015491505090565b606060006106e7611b6a565b90508060070180548060200260200160405190810160405280929190818152602001828054801561076d57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311610723575b505050505091505090565b610780611c33565b600061078a611b6a565b905061079583611b97565b80600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060c0016040529081600082015481526020016001820154815260200160028201805461080590612a89565b80601f016020809104026020016040519081016040528092919081815260200182805461083190612a89565b801561087e5780601f106108535761010080835404028352916020019161087e565b820191906000526020600020905b81548152906001019060200180831161086157829003601f168201915b505050505081526020016003820154815260200160048201548152602001600582015481525050915050919050565b606060006108b9611b6a565b905080600a0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561094657602002820191906000526020600020905b815481526020019060010190808311610932575b5050505050915050919050565b60008061095e611b6a565b905080600701838154811061097657610975612a2b565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b606060006109b5611b6a565b90506000835167ffffffffffffffff8111156109d4576109d3612240565b5b604051908082528060200260200182016040528015610a0d57816020015b6109fa611c69565b8152602001906001900390816109f25790505b50905060005b8451811015610dfa57600080846009016000888581518110610a3857610a37612a2b565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060005b8180549050811015610bec57600086600c016000848481548110610aa657610aa5612a2b565b5b9060005260206000200154815260200190815260200160002090503073ffffffffffffffffffffffffffffffffffffffff16636ba5c8ef8a8781518110610af057610aef612a2b565b5b6020026020010151858581548110610b0b57610b0a612a2b565b5b90600052602060002001546040518363ffffffff1660e01b8152600401610b33929190612aba565b602060405180830381865afa158015610b50573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b749190612b0f565b158015610ba557507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff816000015414155b8015610bc3575086600401548160000154610bc09190612b6b565b42115b15610bd857600184610bd59190612b6b565b93505b508080610be490612bc1565b915050610a7f565b5060405180608001604052803073ffffffffffffffffffffffffffffffffffffffff1663256909028a8781518110610c2757610c26612a2b565b5b60200260200101516040518263ffffffff1660e01b8152600401610c4b9190612220565b602060405180830381865afa158015610c68573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c8c9190612c1e565b81526020013073ffffffffffffffffffffffffffffffffffffffff1663daa4d21b8a8781518110610cc057610cbf612a2b565b5b60200260200101516040518263ffffffff1660e01b8152600401610ce49190612220565b602060405180830381865afa158015610d01573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d259190612c1e565b81526020013073ffffffffffffffffffffffffffffffffffffffff1663d31dedd18a8781518110610d5957610d58612a2b565b5b60200260200101516040518263ffffffff1660e01b8152600401610d7d9190612220565b602060405180830381865afa158015610d9a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dbe9190612c1e565b815260200183815250848481518110610dda57610dd9612a2b565b5b602002602001018190525050508080610df290612bc1565b915050610a13565b508092505050919050565b600080610e10611b6a565b90506000801b81600c016000858152602001908152602001600020600a0160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060010154141591505092915050565b600080610e85611b6a565b90508060100160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208381548110610eda57610ed9612a2b565b5b906000526020600020015491505092915050565b600080610ef9611b6a565b905080600e0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054915050919050565b600080610f50611b6a565b9050806005015491505090565b600080610f68611b6a565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154915050919050565b600080610fc2611b6a565b905080600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154915050919050565b60008061101c611b6a565b9050806001015491505090565b600080611034611b6a565b9050806002015491505090565b6060600061104d611b6a565b90506000835167ffffffffffffffff81111561106c5761106b612240565b5b6040519080825280602002602001820160405280156110a557816020015b611092611c33565b81526020019060019003908161108a5790505b50905060005b845181101561127757600083600d0160008784815181106110cf576110ce612a2b565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015403156112645782600d01600086838151811061113457611133612a2b565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060c001604052908160008201548152602001600182015481526020016002820180546111a590612a89565b80601f01602080910402602001604051908101604052809291908181526020018280546111d190612a89565b801561121e5780601f106111f35761010080835404028352916020019161121e565b820191906000526020600020905b81548152906001019060200180831161120157829003601f168201915b50505050508152602001600382015481526020016004820154815260200160058201548152505082828151811061125857611257612a2b565b5b60200260200101819052505b808061126f90612bc1565b9150506110ab565b508092505050919050565b6060600061128e611b6a565b90508060080160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561131b57602002820191906000526020600020905b815481526020019060010190808311611307575b5050505050915050919050565b600080611333611b6a565b90508060110160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080549050915050919050565b60008061138d611b6a565b90508060100160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080549050915050919050565b6000806113e7611b6a565b9050806004015491505090565b6113fc611c91565b6000611406611b6a565b905080600c016000858152602001908152602001600020600a0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020604051806080016040529081600082015481526020016001820154815260200160028201805461148c90612a89565b80601f01602080910402602001604051908101604052809291908181526020018280546114b890612a89565b80156115055780601f106114da57610100808354040283529160200191611505565b820191906000526020600020905b8154815290600101906020018083116114e857829003601f168201915b505050505081526020016003820160009054906101000a900460ff16151515158152505091505092915050565b60008061153d611b6a565b9050806003015491505090565b611552611cbe565b600061155c611b6a565b9050600081600c016000858152602001908152602001600020905060008160000154036115c057836040517f018da6880000000000000000000000000000000000000000000000000000000081526004016115b79190611eb6565b60405180910390fd5b60008060005b836009018054905081101561178d576000801b84600a0160008660090184815481106115f5576115f4612a2b565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600101541461167657828061166e90612c4b565b93505061177a565b83600a01600085600901838154811061169257611691612a2b565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060030160009054906101000a900460ff1615801561172457508360020160009054906101000a900460ff16155b801561173f57508360020160019054906101000a900460ff16155b801561176f57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff846000015414155b1561177957600191505b5b808061178590612bc1565b9150506115c6565b50604051806101a0016040528084600001548152602001846001015481526020018460020160009054906101000a900460ff16151581526020018460020160019054906101000a900460ff16151581526020018460030180546117ef90612a89565b80601f016020809104026020016040519081016040528092919081815260200182805461181b90612a89565b80156118685780601f1061183d57610100808354040283529160200191611868565b820191906000526020600020905b81548152906001019060200180831161184b57829003601f168201915b505050505081526020018460020160029054906101000a900460ff1660ff168152602001846004015481526020018460060180546118a590612a89565b80601f01602080910402602001604051908101604052809291908181526020018280546118d190612a89565b801561191e5780601f106118f35761010080835404028352916020019161191e565b820191906000526020600020905b81548152906001019060200180831161190157829003601f168201915b505050505081526020018460070160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018460080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200184600901805480602002602001604051908101604052809291908181526020018280548015611a2c57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116119e2575b505050505081526020018360ff168152602001821515815250945050505050919050565b60606000611a5c611b6a565b90508060090160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015611ae957602002820191906000526020600020905b815481526020019060010190808311611ad5575b5050505050915050919050565b600080611b01611b6a565b90508060110160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208381548110611b5657611b55612a2b565b5b906000526020600020015491505092915050565b6000807f2319d9fa277d38834e73ba5e2482efd90323373359a32bb0c96b78353987994190508091505090565b6000611ba1611b6a565b9050600081600d0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000015403611c2f576001826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401611c26929190612c74565b60405180910390fd5b5050565b6040518060c001604052806000815260200160008152602001606081526020016000815260200160008152602001600081525090565b6040518060800160405280600081526020016000815260200160008152602001600081525090565b60405180608001604052806000815260200160008019168152602001606081526020016000151581525090565b604051806101a00160405280600081526020016000815260200160001515815260200160001515815260200160608152602001600060ff1681526020016000815260200160608152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160608152602001600060ff1681526020016000151581525090565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611d9d82611d72565b9050919050565b611dad81611d92565b8114611db857600080fd5b50565b600081359050611dca81611da4565b92915050565b600060208284031215611de657611de5611d68565b5b6000611df484828501611dbb565b91505092915050565b6000819050919050565b611e1081611dfd565b82525050565b6000602082019050611e2b6000830184611e07565b92915050565b611e3a81611dfd565b8114611e4557600080fd5b50565b600081359050611e5781611e31565b92915050565b60008060408385031215611e7457611e73611d68565b5b6000611e8285828601611dbb565b9250506020611e9385828601611e48565b9150509250929050565b6000819050919050565b611eb081611e9d565b82525050565b6000602082019050611ecb6000830184611ea7565b92915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b611f0681611d92565b82525050565b6000611f188383611efd565b60208301905092915050565b6000602082019050919050565b6000611f3c82611ed1565b611f468185611edc565b9350611f5183611eed565b8060005b83811015611f82578151611f698882611f0c565b9750611f7483611f24565b925050600181019050611f55565b5085935050505092915050565b60006020820190508181036000830152611fa98184611f31565b905092915050565b611fba81611dfd565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611ffa578082015181840152602081019050611fdf565b83811115612009576000848401525b50505050565b6000601f19601f8301169050919050565b600061202b82611fc0565b6120358185611fcb565b9350612045818560208601611fdc565b61204e8161200f565b840191505092915050565b600060c0830160008301516120716000860182611fb1565b5060208301516120846020860182611fb1565b506040830151848203604086015261209c8282612020565b91505060608301516120b16060860182611fb1565b5060808301516120c46080860182611fb1565b5060a08301516120d760a0860182611fb1565b508091505092915050565b600060208201905081810360008301526120fc8184612059565b905092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61213981611e9d565b82525050565b600061214b8383612130565b60208301905092915050565b6000602082019050919050565b600061216f82612104565b612179818561210f565b935061218483612120565b8060005b838110156121b557815161219c888261213f565b97506121a783612157565b925050600181019050612188565b5085935050505092915050565b600060208201905081810360008301526121dc8184612164565b905092915050565b6000602082840312156121fa576121f9611d68565b5b600061220884828501611e48565b91505092915050565b61221a81611d92565b82525050565b60006020820190506122356000830184612211565b92915050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6122788261200f565b810181811067ffffffffffffffff8211171561229757612296612240565b5b80604052505050565b60006122aa611d5e565b90506122b6828261226f565b919050565b600067ffffffffffffffff8211156122d6576122d5612240565b5b602082029050602081019050919050565b600080fd5b60006122ff6122fa846122bb565b6122a0565b90508083825260208201905060208402830185811115612322576123216122e7565b5b835b8181101561234b57806123378882611dbb565b845260208401935050602081019050612324565b5050509392505050565b600082601f83011261236a5761236961223b565b5b813561237a8482602086016122ec565b91505092915050565b60006020828403121561239957612398611d68565b5b600082013567ffffffffffffffff8111156123b7576123b6611d6d565b5b6123c384828501612355565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b60808201600082015161240e6000850182611fb1565b5060208201516124216020850182611fb1565b5060408201516124346040850182611fb1565b5060608201516124476060850182611fb1565b50505050565b600061245983836123f8565b60808301905092915050565b6000602082019050919050565b600061247d826123cc565b61248781856123d7565b9350612492836123e8565b8060005b838110156124c35781516124aa888261244d565b97506124b583612465565b925050600181019050612496565b5085935050505092915050565b600060208201905081810360008301526124ea8184612472565b905092915050565b6124fb81611e9d565b811461250657600080fd5b50565b600081359050612518816124f2565b92915050565b6000806040838503121561253557612534611d68565b5b600061254385828601611dbb565b925050602061255485828601612509565b9150509250929050565b60008115159050919050565b6125738161255e565b82525050565b600060208201905061258e600083018461256a565b92915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600060c0830160008301516125d86000860182611fb1565b5060208301516125eb6020860182611fb1565b50604083015184820360408601526126038282612020565b91505060608301516126186060860182611fb1565b50608083015161262b6080860182611fb1565b5060a083015161263e60a0860182611fb1565b508091505092915050565b600061265583836125c0565b905092915050565b6000602082019050919050565b600061267582612594565b61267f818561259f565b935083602082028501612691856125b0565b8060005b858110156126cd57848403895281516126ae8582612649565b94506126b98361265d565b925060208a01995050600181019050612695565b50829750879550505050505092915050565b600060208201905081810360008301526126f9818461266a565b905092915050565b6000806040838503121561271857612717611d68565b5b600061272685828601612509565b925050602061273785828601611dbb565b9150509250929050565b600081519050919050565b600082825260208201905092915050565b600061276882612741565b612772818561274c565b9350612782818560208601611fdc565b61278b8161200f565b840191505092915050565b61279f8161255e565b82525050565b60006080830160008301516127bd6000860182611fb1565b5060208301516127d06020860182612130565b50604083015184820360408601526127e8828261275d565b91505060608301516127fd6060860182612796565b508091505092915050565b6000602082019050818103600083015261282281846127a5565b905092915050565b6000602082840312156128405761283f611d68565b5b600061284e84828501612509565b91505092915050565b600060ff82169050919050565b61286d81612857565b82525050565b600082825260208201905092915050565b600061288f82611ed1565b6128998185612873565b93506128a483611eed565b8060005b838110156128d55781516128bc8882611f0c565b97506128c783611f24565b9250506001810190506128a8565b5085935050505092915050565b60006101a0830160008301516128fb6000860182611fb1565b50602083015161290e6020860182611fb1565b5060408301516129216040860182612796565b5060608301516129346060860182612796565b506080830151848203608086015261294c8282612020565b91505060a083015161296160a0860182612864565b5060c083015161297460c0860182611fb1565b5060e083015184820360e086015261298c8282612020565b9150506101008301516129a3610100860182611efd565b506101208301516129b8610120860182611efd565b506101408301518482036101408601526129d28282612884565b9150506101608301516129e9610160860182612864565b506101808301516129fe610180860182612796565b508091505092915050565b60006020820190508181036000830152612a2381846128e2565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680612aa157607f821691505b602082108103612ab457612ab3612a5a565b5b50919050565b6000604082019050612acf6000830185612211565b612adc6020830184611ea7565b9392505050565b612aec8161255e565b8114612af757600080fd5b50565b600081519050612b0981612ae3565b92915050565b600060208284031215612b2557612b24611d68565b5b6000612b3384828501612afa565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000612b7682611dfd565b9150612b8183611dfd565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115612bb657612bb5612b3c565b5b828201905092915050565b6000612bcc82611dfd565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612bfe57612bfd612b3c565b5b600182019050919050565b600081519050612c1881611e31565b92915050565b600060208284031215612c3457612c33611d68565b5b6000612c4284828501612c09565b91505092915050565b6000612c5682612857565b915060ff8203612c6957612c68612b3c565b5b600182019050919050565b6000604082019050612c89600083018561256a565b612c966020830184612211565b939250505056fea2646970667358221220830700e476802ad7bd8dceec2eed3791fe959adf6649d8bbbf42100e1ba299f264736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "archaeologistAccusalsIdentifier(address,uint256)": {
        "params": {
          "archaeologist": "The address of an archaeologist",
          "index": "The index of the archaeologist's accused sarcophagi"
        },
        "returns": {
          "_0": "the identifier associated with the index of the archaeologist's accused sarcophagi"
        }
      },
      "archaeologistCleanupsIdentifier(address,uint256)": {
        "params": {
          "archaeologist": "The address of an archaeologist",
          "index": "The index of the archaeologist's cleaned-up sarcophagi"
        },
        "returns": {
          "_0": "the identifier associated with the index of the archaeologist's cleaned-up sarcophagi"
        }
      },
      "archaeologistSuccessesIdentifier(address,uint256)": {
        "params": {
          "archaeologist": "The address of an archaeologist",
          "index": "The index of the archaeologist's unwrapped sarcophagi"
        },
        "returns": {
          "_0": "the identifier associated with the index of the archaeologist's unwrapped sarcophagi"
        }
      },
      "getArchaeologistAccusalsCount(address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose accusations count is being returned"
        }
      },
      "getArchaeologistCleanupsCount(address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose cleanups count is being returned"
        }
      },
      "getArchaeologistProfile(address)": {
        "params": {
          "archaeologist": "The archaeologist account's address"
        },
        "returns": {
          "_0": "the Archaeologist object"
        }
      },
      "getArchaeologistProfileAddressAtIndex(uint256)": {
        "params": {
          "index": "The index of the registered archaeologist"
        },
        "returns": {
          "_0": "address of the archaeologist"
        }
      },
      "getArchaeologistProfileAddresses()": {
        "returns": {
          "_0": "addresses of registered archaeologists"
        }
      },
      "getArchaeologistProfiles(address[])": {
        "params": {
          "addresses": "The list of archaeologist addresses"
        },
        "returns": {
          "_0": "The list of archaeologist profiles"
        }
      },
      "getArchaeologistSarcophagi(address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose sarcophagi are being returned"
        }
      },
      "getArchaeologistSuccessOnSarcophagus(address,bytes32)": {
        "params": {
          "archaeologist": "The address of the archaeologist",
          "sarcoId": "the sarcophagus to check if unwrapping occured"
        }
      },
      "getArchaeologistSuccessesCount(address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose success"
        }
      },
      "getArchaeologistsStatistics(address[])": {
        "params": {
          "addresses": "The list of archaeologist addresses"
        },
        "returns": {
          "_0": "The list of archaeologist statistics"
        }
      },
      "getCursedBond(address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose cursed bond is being returned"
        }
      },
      "getCursedBondPercentage()": {
        "returns": {
          "_0": "The cursed bond percentage - cursedBondPercentage"
        }
      },
      "getEmbalmerClaimWindow()": {
        "returns": {
          "_0": "The embalmer claim window"
        }
      },
      "getEmbalmerSarcophagi(address)": {
        "params": {
          "embalmer": "The address of the embalmer whose sarcophagi are being returned"
        }
      },
      "getExpirationThreshold()": {
        "returns": {
          "_0": "The expiration threshold"
        }
      },
      "getFreeBond(address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose free bond is being returned"
        }
      },
      "getGracePeriod()": {
        "returns": {
          "_0": "The resurrection grace period"
        }
      },
      "getProtocolFeeBasePercentage()": {
        "returns": {
          "_0": "The protocol fee base percentage - protocolFeeBasePercentage"
        }
      },
      "getRecipientSarcophagi(address)": {
        "params": {
          "recipient": "The address of the recipient whose sarcophagi are being returned"
        }
      },
      "getRewards(address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose reward is being returned"
        }
      },
      "getSarcophagus(bytes32)": {
        "params": {
          "sarcoId": "The identifier of the sarcophagus being returned"
        }
      },
      "getSarcophagusArchaeologist(bytes32,address)": {
        "params": {
          "archaeologist": "The address of the archaeologist whose data is being returned",
          "sarcoId": "The identifier of the sarcophagus whose data is being returned"
        }
      },
      "getTotalProtocolFees()": {
        "returns": {
          "_0": "The total protocol fees"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "archaeologistAccusalsIdentifier(address,uint256)": {
        "notice": "Returns the sarcophagus unique identifier for a given archaeologist and index of the accused sarcophagi"
      },
      "archaeologistCleanupsIdentifier(address,uint256)": {
        "notice": "Returns the sarcophagus unique identifier for a given archaeologist and index of the cleaned-up sarcophagi"
      },
      "archaeologistSuccessesIdentifier(address,uint256)": {
        "notice": "Returns the sarcophagus unique identifier for a given archaeologist and index of the successfully unwrapped sarcophagi"
      },
      "getArchaeologistAccusalsCount(address)": {
        "notice": "Returns the number of accusations for an archaeologist."
      },
      "getArchaeologistCleanupsCount(address)": {
        "notice": "Returns the number of cleanups for an archaeologist."
      },
      "getArchaeologistProfile(address)": {
        "notice": "Given an archaeologist address, return that archaeologist's profile"
      },
      "getArchaeologistProfileAddressAtIndex(uint256)": {
        "notice": "Given an index (of the full archaeologist array), return the archaeologist address at that index"
      },
      "getArchaeologistProfileAddresses()": {
        "notice": "Return the list of registereed archaeologist addresses."
      },
      "getArchaeologistProfiles(address[])": {
        "notice": "Gets archaeologist profiles given a list of archaeologist addresses. If an invalid address is included, simply leaves it out of the list."
      },
      "getArchaeologistSarcophagi(address)": {
        "notice": "Given an archaeologist's address, returns the identifiers of all sarcophagi that the archaeologist has participated in."
      },
      "getArchaeologistSuccessOnSarcophagus(address,bytes32)": {
        "notice": "Returns whether an archaeologist completed an unwrap for a sarcophagus"
      },
      "getArchaeologistSuccessesCount(address)": {
        "notice": "Returns the number of successful unwraps for an archaeologist."
      },
      "getArchaeologistsStatistics(address[])": {
        "notice": "Gets all reputation statistics for each archaeologist Contains a list of counts for each category."
      },
      "getCursedBond(address)": {
        "notice": "Returns the amount of cursed bond stored in the contract for an archaeologist."
      },
      "getCursedBondPercentage()": {
        "notice": "Get the cursed bond percentage from the contract."
      },
      "getEmbalmerClaimWindow()": {
        "notice": "Gets the window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys"
      },
      "getEmbalmerSarcophagi(address)": {
        "notice": "Given an embalmer's address, returns the identifiers of all sarcophagi that the embalmer has created."
      },
      "getExpirationThreshold()": {
        "notice": "Gets the expiration threshold after which a sarcophagus must be renegotiated"
      },
      "getFreeBond(address)": {
        "notice": "Returns the amount of free bond stored in the contract for an archaeologist."
      },
      "getGracePeriod()": {
        "notice": "Gets the grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time passes"
      },
      "getProtocolFeeBasePercentage()": {
        "notice": "Get the protocol fee base percentage from the contract."
      },
      "getRecipientSarcophagi(address)": {
        "notice": "Given a recipient's address, returns the identifiers of all sarcophagi that the recipient has participated in."
      },
      "getRewards(address)": {
        "notice": "Returns the amount of rewards stored in the contract for an archaeologist."
      },
      "getSarcophagus(bytes32)": {
        "notice": "Returns data on the sarcophagus with the supplied id includes aggregate data on cursed archaeologists associated with the sarcophagus     - publishedPrivateKeyCount - the total number of private keys published by archaeologists on the sarcophagus     - hasLockedBond - true if archaeologists still have bond locked in the contract for this sarcophagus"
      },
      "getSarcophagusArchaeologist(bytes32,address)": {
        "notice": "Returns the data stored on a sarcophagus for an archaeologist."
      },
      "getTotalProtocolFees()": {
        "notice": "Gets the total protocol fees from the contract."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}