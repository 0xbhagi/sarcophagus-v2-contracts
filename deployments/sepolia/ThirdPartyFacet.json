{
  "address": "0x408E91946a336Df994656D43Df4Fa1f22cC71475",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "ArchaeologistNotOnSarcophagus",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "embalmerClaimWindowEnd",
          "type": "uint256"
        }
      ],
      "name": "EmbalmerClaimWindowPassed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "cursedBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "NotEnoughCursedBond",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusAlreadyCleaned",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusCompromised",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusInactive",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SarcophagusIsUnwrappable",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "senderAddress",
          "type": "address"
        }
      ],
      "name": "SenderNotEmbalmerOrAdmin",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "embalmerClaimWindowEnd",
          "type": "uint256"
        }
      ],
      "name": "TooEarlyForAdminClean",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "publishDeadline",
          "type": "uint256"
        }
      ],
      "name": "TooEarlyForClean",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "accuser",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "accuserBondReward",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "embalmerBondReward",
          "type": "uint256"
        }
      ],
      "name": "AccuseArchaeologist",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "cleaner",
          "type": "address"
        }
      ],
      "name": "Clean",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ThirdPartyFacet.Signature[]",
          "name": "signatures",
          "type": "tuple[]"
        },
        {
          "internalType": "address",
          "name": "paymentAddress",
          "type": "address"
        }
      ],
      "name": "accuse",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "clean",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xe01663d88e94c0e1a1180d0f5e73fcffa861ff776c8c306e799ab469546668fb",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x60e021fE3F1567752D97f1Bc9Fc77E24efc8FBDC",
    "contractAddress": null,
    "transactionIndex": 1,
    "gasUsed": "1454383",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf38bdcdfd51a27438c5176a0a3c5123b173a224a6cf4c107354372f28182fb6a",
    "transactionHash": "0xe01663d88e94c0e1a1180d0f5e73fcffa861ff776c8c306e799ab469546668fb",
    "logs": [],
    "blockNumber": 2519870,
    "cumulativeGasUsed": "1640395",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "4aa61604c0a9efd866e19679821c2a67",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"ArchaeologistNotOnSarcophagus\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"embalmerClaimWindowEnd\",\"type\":\"uint256\"}],\"name\":\"EmbalmerClaimWindowPassed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cursedBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotEnoughCursedBond\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusAlreadyCleaned\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusCompromised\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusInactive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SarcophagusIsUnwrappable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"}],\"name\":\"SenderNotEmbalmerOrAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"embalmerClaimWindowEnd\",\"type\":\"uint256\"}],\"name\":\"TooEarlyForAdminClean\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publishDeadline\",\"type\":\"uint256\"}],\"name\":\"TooEarlyForClean\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accuser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accuserBondReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"embalmerBondReward\",\"type\":\"uint256\"}],\"name\":\"AccuseArchaeologist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cleaner\",\"type\":\"address\"}],\"name\":\"Clean\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ThirdPartyFacet.Signature[]\",\"name\":\"signatures\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"}],\"name\":\"accuse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"clean\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"EmbalmerClaimWindowPassed(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed clean attempt\",\"embalmerClaimWindowEnd\":\"Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\"}}],\"SarcophagusAlreadyCleaned(bytes32)\":[{\"params\":{\"sarcoId\":\"ID of sarcophagus archaeologist has attempted to publish a private key on\"}}],\"SenderNotEmbalmerOrAdmin(address)\":[{\"params\":{\"senderAddress\":\"Address of sender\"}}],\"TooEarlyForAdminClean(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed clean attempt\",\"embalmerClaimWindowEnd\":\"Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\"}}],\"TooEarlyForClean(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed clean attempt\",\"publishDeadline\":\"Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\"}}]},\"kind\":\"dev\",\"methods\":{\"accuse(bytes32,(uint8,bytes32,bytes32)[],address)\":{\"params\":{\"paymentAddress\":\"the address to which rewards should be sent if successful\",\"sarcoId\":\"The identifier of the sarcophagus having leaked private keys\",\"signatures\":\"an array of signatures of the sarcoId signed by the leaked private keys\"}},\"clean(bytes32)\":{\"params\":{\"sarcoId\":\"The identifier of the sarcophagus to clean\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"EmbalmerClaimWindowPassed(uint256,uint256)\":[{\"notice\":\"Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\"}],\"SarcophagusAlreadyCleaned(bytes32)\":[{\"notice\":\"Clean has been called on a sarcophagus that has already been cleaned\"}],\"SenderNotEmbalmerOrAdmin(address)\":[{\"notice\":\"Clean has been called by someone other than the admin or embalmer of the sarcophagus\"}],\"TooEarlyForAdminClean(uint256,uint256)\":[{\"notice\":\"Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\"}],\"TooEarlyForClean(uint256,uint256)\":[{\"notice\":\"Clean has been called before the deadline for archaeologists to publish private keys has passed\"}]},\"kind\":\"user\",\"methods\":{\"accuse(bytes32,(uint8,bytes32,bytes32)[],address)\":{\"notice\":\"Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id and payment address generated with the leaked private keys If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus state will be updated to Accused and bonds for all remaining unaccused archaeologists will be returned\"},\"clean(bytes32)\":{\"notice\":\"If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod, their locked bonds and diggingFees may be claimed by either the embalmer or the admin embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will be able to claim remaining locked bond and diggingFees\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/ThirdPartyFacet.sol\":\"ThirdPartyFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"contracts/facets/ThirdPartyFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport {LibDiamond} from \\\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport {AppStorage} from \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\ncontract ThirdPartyFacet {\\n    AppStorage internal s;\\n\\n    event AccuseArchaeologist(\\n        bytes32 indexed sarcoId,\\n        address indexed accuser,\\n        uint256 accuserBondReward,\\n        uint256 embalmerBondReward\\n    );\\n\\n    event Clean(bytes32 indexed sarcoId, address indexed cleaner);\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice Clean has been called on a sarcophagus that has already been cleaned\\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a private key on\\n    error SarcophagusAlreadyCleaned(bytes32 sarcoId);\\n\\n    /// @notice Clean has been called before the deadline for archaeologists to publish private keys has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param publishDeadline Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\\n    error TooEarlyForClean(uint256 currentTime, uint256 publishDeadline);\\n\\n    /// @notice Clean has been called by someone other than the admin or embalmer of the sarcophagus\\n    /// @param senderAddress Address of sender\\n    error SenderNotEmbalmerOrAdmin(address senderAddress);\\n\\n    /// @notice Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error EmbalmerClaimWindowPassed(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error TooEarlyForAdminClean(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod,\\n    /// their locked bonds and diggingFees may be claimed by either the embalmer or the admin\\n    /// embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will\\n    /// be able to claim remaining locked bond and diggingFees\\n    /// @param sarcoId The identifier of the sarcophagus to clean\\n    function clean(bytes32 sarcoId) external {\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not already been cleaned\\n        if (sarcophagus.isCleaned) {\\n            revert SarcophagusAlreadyCleaned(sarcoId);\\n        }\\n\\n        // Confirm that the resurrectionTime + gracePeriod have passed\\n        if (block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod) {\\n            revert TooEarlyForClean(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\\n        }\\n\\n        // Confirm tx sender is embalmer or admin\\n        if (msg.sender != sarcophagus.embalmerAddress && msg.sender != LibDiamond.contractOwner()) {\\n            revert SenderNotEmbalmerOrAdmin(msg.sender);\\n        }\\n\\n        // if sender is embalmer, confirm current time is within embalmerClaimWindow\\n        if (\\n            msg.sender == sarcophagus.embalmerAddress &&\\n            block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert EmbalmerClaimWindowPassed(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // if sender is admin, confirm embalmerClaimWindow has passed\\n        if (\\n            msg.sender == LibDiamond.contractOwner() &&\\n            block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert TooEarlyForAdminClean(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // sum of locked bonds and digging fees for all archaeologists that have failed to publish private keys before publish deadline and have not been accused\\n        uint256 totalDiggingFeesAndLockedBonds = 0;\\n        for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]];\\n            if (!cursedArchaeologist.isAccused && cursedArchaeologist.privateKey == 0) {\\n                totalDiggingFeesAndLockedBonds += cursedArchaeologist.diggingFee; // add digging fee for cursedArchaeologist\\n                totalDiggingFeesAndLockedBonds += cursedArchaeologist.diggingFee; // add locked bond for cursedArchaeologist\\n\\n                // slash the archaeologist's locked bond for the sarcophagus\\n                LibBonds.decreaseCursedBond(\\n                    sarcophagus.cursedArchaeologistAddresses[i],\\n                    cursedArchaeologist.diggingFee\\n                );\\n\\n                // track that the archaeologist has had a clean on this sarcophagus\\n                s.archaeologistCleanups[sarcophagus.cursedArchaeologistAddresses[i]].push(sarcoId);\\n            }\\n        }\\n\\n        // if caller is embalmer, transfer them the total locked bonds and digging fees\\n        if (msg.sender == sarcophagus.embalmerAddress) {\\n            s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFeesAndLockedBonds);\\n        }\\n\\n        // if caller is admin, add total locked bonds and digging fees into protocolFees\\n        if (msg.sender == LibDiamond.contractOwner()) {\\n            s.totalProtocolFees += totalDiggingFeesAndLockedBonds;\\n        }\\n\\n        sarcophagus.isCleaned = true;\\n        emit Clean(sarcoId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id\\n     * and payment address generated with the leaked private keys\\n     * If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be\\n     * split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer\\n     *\\n     * If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus\\n     * state will be updated to Accused and bonds for all remaining unaccused archaeologists will be\\n     * returned\\n     *\\n     * @param sarcoId The identifier of the sarcophagus having leaked private keys\\n     * @param signatures an array of signatures of the sarcoId signed by the leaked private keys\\n     * @param paymentAddress the address to which rewards should be sent if successful\\n     */\\n    function accuse(\\n        bytes32 sarcoId,\\n        Signature[] calldata signatures,\\n        address paymentAddress\\n    ) external {\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // verify that current time is not past resurrection time\\n        if (block.timestamp > sarcophagus.resurrectionTime) {\\n            revert LibErrors.SarcophagusIsUnwrappable();\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // build an array of the addresses of the archaeologists currently being accused\\n        address[] memory accusedArchAddresses = new address[](signatures.length);\\n\\n        // track the combined locked bond across all archaeologists being accused in this call\\n        // locked bond will be equal to the amount of diggingFees allocated by the embalmer to pay the archaeologist\\n        uint256 totalDiggingFees = 0;\\n        uint256 accusalCount = 0;\\n        for (uint256 i = 0; i < signatures.length; i++) {\\n            // todo: obtain signing key for signature\\n            bytes memory publicKey = bytes(\\\"\\\");\\n            // look up the archaeologist responsible for the publicKey\\n            address accusedArchaeologistAddress = s.publicKeyToArchaeologistAddress[publicKey];\\n            LibTypes.CursedArchaeologist storage accusedArchaeologist = sarcophagus\\n                .cursedArchaeologists[accusedArchaeologistAddress];\\n\\n            // verify the accused archaeologist is cursed on the sarcophagus\\n            if (accusedArchaeologist.publicKey.length == 0) {\\n                revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\\n            }\\n\\n            // if the archaeologist has already been accused on this sarcophagus break without taking action\\n            if (accusedArchaeologist.isAccused) {\\n                break;\\n            }\\n\\n            // mark the archaeologist on the sarcophagus as having been accused\\n            accusedArchaeologist.isAccused = true;\\n            accusedArchAddresses[accusalCount++] = accusedArchaeologistAddress;\\n\\n            // track the sum of all digging fees for all accused archaeologists\\n            totalDiggingFees += accusedArchaeologist.diggingFee;\\n\\n            // slash the accused archaeologist's bond\\n            LibBonds.decreaseCursedBond(\\n                accusedArchaeologistAddress,\\n                accusedArchaeologist.diggingFee\\n            );\\n\\n            // Save the accusal against the archaeologist\\n            s.archaeologistAccusals[accusedArchaeologistAddress].push(sarcoId);\\n        }\\n\\n        // if none of the accusals were valid because the archaeologists have all already been accused, return without taking action\\n        if (accusalCount == 0) {\\n            return;\\n        }\\n\\n        // the sarcophagus is compromised if the current call has successfully accused the sss threshold of archaeologists\\n        if (accusalCount >= sarcophagus.threshold) {\\n            sarcophagus.isCompromised = true;\\n        } else {\\n            // if the current call hasn't resulted in at least sss threshold archaeologists being accused\\n            // check if total number of historical accusals on sarcophagus is greater than threshold\\n            uint256 totalAccusals = 0;\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                if (\\n                    sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    totalAccusals++;\\n                }\\n            }\\n            // the sarcophagus is compromised if k or more archaeologists have been accused over the lifetime of the sarcophagus\\n            if (totalAccusals >= sarcophagus.threshold) {\\n                sarcophagus.isCompromised = true;\\n            }\\n        }\\n\\n        // if k or more archaeologists have been accused over the lifetime of the sarcophagus, funds should\\n        // be returned to the remaining well behaved archaeologists\\n        if (sarcophagus.isCompromised) {\\n            // iterate through all archaeologist addresses on the sarcophagus\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                // if the archaeologist has never been accused, release their locked bond back to them\\n                if (\\n                    !sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    LibBonds.freeArchaeologist(\\n                        sarcoId,\\n                        sarcophagus.cursedArchaeologistAddresses[i]\\n                    );\\n                }\\n            }\\n        }\\n\\n        // refund the diggingFees allocated by the embalmer to the accused archaeologists\\n        // split the total bond being slashed between the embalmer and the payment address\\n        (uint256 accuserBondReward, uint256 embalmerBondReward) = _distributeLoot(\\n            paymentAddress,\\n            sarcophagus,\\n            totalDiggingFees\\n        );\\n\\n        emit AccuseArchaeologist(sarcoId, msg.sender, accuserBondReward, embalmerBondReward);\\n    }\\n\\n    /**\\n     * @notice Takes a sarcophagus's digging fee, splits it in half, and sends\\n     * to paymentAddress and embalmer\\n     * @param paymentAddress payment address for the transaction caller\\n     * @param sarc the sarcophagus to operate on\\n     * @param totalDiggingFee the sum of digging fees of all archs that failed to fulfil their duties\\n     * @return halfToSender the amount of SARCO token going to transaction\\n     * sender\\n     * @return halfToEmbalmer the amount of SARCO token going to embalmer\\n     */\\n    function _distributeLoot(\\n        address paymentAddress,\\n        LibTypes.Sarcophagus storage sarc,\\n        uint256 totalDiggingFee\\n    ) private returns (uint256, uint256) {\\n        // split the sarcophagus's cursed bond into two halves\\n        uint256 halfToEmbalmer = totalDiggingFee / 2;\\n        uint256 halfToSender = totalDiggingFee - halfToEmbalmer;\\n\\n        // transfer the cursed half, plus digging fee to the\\n        // embalmer\\n        s.sarcoToken.transfer(sarc.embalmerAddress, totalDiggingFee + halfToEmbalmer);\\n\\n        // transfer the other half of the cursed bond to the transaction caller\\n        s.sarcoToken.transfer(paymentAddress, halfToSender);\\n\\n        return (halfToSender, halfToEmbalmer);\\n    }\\n\\n    function _hashHelper(bytes memory data) private pure returns (bytes32) {\\n        return keccak256(data);\\n    }\\n}\\n\",\"keccak256\":\"0x8465e76fa4840ada01e9612ecaa4b81f5dc400c7d7b5711f3ad5eb30d57ded18\",\"license\":\"Unlicense\"},\"contracts/libraries/LibBonds.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\n\\nlibrary LibBonds {\\n    /// @notice Decreases the amount stored in the freeBond mapping for an\\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\\n    /// the amount.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being decreased\\n    /// @param amount The amount to decrease the free bond by\\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current free bond\\n        if (amount > s.archaeologistProfiles[archaeologist].freeBond) {\\n            revert LibErrors.NotEnoughFreeBond(\\n                s.archaeologistProfiles[archaeologist].freeBond,\\n                amount\\n            );\\n        }\\n\\n        // Decrease the free bond amount\\n        s.archaeologistProfiles[archaeologist].freeBond -= amount;\\n    }\\n\\n    /// @notice Increases the amount stored in the freeBond mapping for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being decreased\\n    /// @param amount The amount to decrease the free bond by\\n    function increaseFreeBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Increase the free bond amount\\n        s.archaeologistProfiles[archaeologist].freeBond += amount;\\n    }\\n\\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\\n    /// archaeologist. Reverts if the archaeologist's cursed bond is lower than\\n    /// the amount.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// cursed bond is being decreased\\n    /// @param amount The amount to decrease the cursed bond by\\n    function decreaseCursedBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current cursed bond\\n        if (amount > s.archaeologistProfiles[archaeologist].cursedBond) {\\n            revert LibErrors.NotEnoughCursedBond(\\n                s.archaeologistProfiles[archaeologist].cursedBond,\\n                amount\\n            );\\n        }\\n\\n        // Decrease the cursed bond amount\\n        s.archaeologistProfiles[archaeologist].cursedBond -= amount;\\n    }\\n\\n    /// @notice Increases the amount stored in the cursedBond mapping for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// cursed bond is being decreased\\n    /// @param amount The amount to decrease the cursed bond by\\n    function increaseCursedBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Increase the cursed bond amount\\n        s.archaeologistProfiles[archaeologist].cursedBond += amount;\\n    }\\n\\n    /// @notice Locks up the archaeologist's bond, decreasing the\\n    /// archaeologist's free bond by an amount and increasing the\\n    /// archaeologist's cursed bond by the same amount.\\n    /// @param archaeologist The address of the archaeologist\\n    /// @param amount The amount to lock up\\n    function lockUpBond(address archaeologist, uint256 amount) internal {\\n        // Decrease the free bond amount\\n        decreaseFreeBond(archaeologist, amount);\\n\\n        // Increase the cursed bond amount\\n        increaseCursedBond(archaeologist, amount);\\n    }\\n\\n    /// @notice Unlocks the archaeologist's bond, increasing the\\n    /// archaeologist's free bond by an amount and decreasing the\\n    /// archaeologist's cursed bond by the same amount.\\n    /// @param archaeologist The address of the archaeologist\\n    /// @param amount The amount to unlock\\n    function unlockBond(address archaeologist, uint256 amount) internal {\\n        // Decrease the cursed bond amount\\n        decreaseCursedBond(archaeologist, amount);\\n\\n        // Increase the free bond amount\\n        increaseFreeBond(archaeologist, amount);\\n    }\\n\\n\\n    /// @notice Calculates an archaeologist's cursed bond and frees them\\n    /// (unlocks the cursed bond).\\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\\n    /// @param archaeologistAddress the address of the archaeologist to free\\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\\n            .sarcophagi[sarcoId]\\n            .cursedArchaeologists[archaeologistAddress];\\n\\n        // Free up the archaeologist's locked bond\\n        unlockBond(archaeologistAddress, cursedArchaeologist.diggingFee);\\n    }\\n}\\n\",\"keccak256\":\"0xc74cba3d575a7d40f467c7e0601e31c829a8b2b658c4234692c609e189637478\",\"license\":\"Unlicense\"},\"contracts/libraries/LibErrors.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title A collection of Errors\\n * @notice This library defines all of the Errors that the Sarcophagus system\\n * uses.\\n */\\nlibrary LibErrors {\\n\\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\\n\\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\\n\\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\\n\\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\\n\\n    error PrivateKeyDoesNotMatchPublicKey(bytes32 privateKey, bytes publicKey);\\n\\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\\n\\n    error SarcophagusInactive(bytes32 sarcoId);\\n\\n    error SarcophagusCompromised(bytes32 sarcoId);\\n\\n    error SenderNotEmbalmer(address sender, address embalmer);\\n\\n    error InvalidSignature(\\n        // address recovered from signature via ecrecover\\n        address recoveredAddress,\\n        // address we expected to have signed the data\\n        address expectedAddress\\n    );\\n\\n    // Used when an attempt is made to accuse or rewrap after the resurrection time has already passed (so it's actually time to unwrap it)\\n    error SarcophagusIsUnwrappable();\\n\\n}\\n\",\"keccak256\":\"0x6f4ec50d4efeafbaa98ee904c442c44e95e8c7317add80a32beeaf09e9063481\",\"license\":\"Unlicense\"},\"contracts/libraries/LibTypes.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title Types shared across facets for the Sarcophagus diamond\\n */\\nlibrary LibTypes {\\n    struct Sarcophagus {\\n        // never zero - use for existence checks\\n        uint256 resurrectionTime;\\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\\n        bool isCompromised;\\n        bool isCleaned;\\n        string name;\\n        uint8 threshold;\\n        uint256 maximumRewrapInterval;\\n        string arweaveTxId;\\n        address embalmerAddress;\\n        address recipientAddress;\\n        address[] cursedArchaeologistAddresses;\\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\\n    }\\n\\n    struct CursedArchaeologist {\\n        // never empty - use for existence checks\\n        bytes publicKey;\\n        bytes32 privateKey;\\n        bool isAccused;\\n        uint256 diggingFee;\\n    }\\n\\n    struct ArchaeologistProfile {\\n        bool exists; // todo: use peerid.length instead of exists\\n        string peerId;\\n        uint256 minimumDiggingFee;\\n        uint256 maximumRewrapInterval;\\n        uint256 freeBond;\\n        uint256 cursedBond;\\n    }\\n\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n}\\n\",\"keccak256\":\"0xd36dac645e4d3af3bda54c124479e6d932f54aad472b2ee48920b36e81fc10e9\",\"license\":\"Unlicense\"},\"contracts/libraries/LibUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\n\\n/**\\n * @title Utility functions used within the Sarcophagus system\\n * @notice This library implements various functions that are used throughout\\n * Sarcophagus, mainly to DRY up the codebase\\n * @dev these functions are all stateless, public, pure/view\\n */\\nlibrary LibUtils {\\n    /**\\n     * @notice The archaeologist needs to sign off on two pieces of data\\n     * to guarantee their unrwap will be successful\\n     *\\n     * @param publicKey public key archaeologist is responsible for\\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\\n     * @param diggingFee that the archaeologist has agreed to for the sarcophagus\\n     * @param v signature element\\n     * @param r signature element\\n     * @param s signature element\\n     * @param account address to confirm signature of data came from\\n     */\\n    function verifyArchaeologistSignature(\\n        bytes memory publicKey, // todo: data location?\\n        uint256 agreedMaximumRewrapInterval,\\n        uint256 timestamp,\\n        uint256 diggingFee,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        address account\\n    ) internal pure {\\n        // Hash the hash of the data payload\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encode(\\n                        publicKey,\\n                        agreedMaximumRewrapInterval,\\n                        diggingFee,\\n                        timestamp\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Generate the address from the signature.\\n        // ecrecover should always return a valid address.\\n        address recoveredAddress = ecrecover(messageHash, v, r, s);\\n\\n        if (recoveredAddress != account) {\\n            revert LibErrors.InvalidSignature(recoveredAddress, account);\\n        }\\n    }\\n\\n    /// @notice Checks if an archaeologist profile exists and\\n    /// reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check existence of\\n    function revertIfArchProfileExists(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].exists) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Checks if an archaeologist profile doesn't exist and\\n    /// reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check lack of existence of\\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (!s.archaeologistProfiles[archaeologist].exists) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\\n    /// @return The protocol fees amount\\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 100;\\n    }\\n}\\n\",\"keccak256\":\"0xb64e29c11af874ae1f3dacef8d24eb3a8b581cec8a907cd059de419c33711c65\",\"license\":\"Unlicense\"},\"contracts/storage/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\n/**\\n* Global diamond storage struct to be shared across facets\\n* TODO: Implement diamond storage pattern and consider splitting storage into facet specific structs\\n*/\\nstruct AppStorage {\\n    // SARCO token contract\\n    IERC20 sarcoToken;\\n\\n    // total protocol fees available to be withdrawn by the admin\\n    uint256 totalProtocolFees;\\n\\n    /**\\n    * Protocol level admin configurations\\n    */\\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap\\n    uint256 protocolFeeBasePercentage;\\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time\\n    uint256 gracePeriod;\\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated\\n    uint256 expirationThreshold;\\n    // window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\\n    uint256 embalmerClaimWindow;\\n\\n    /**\\n    * Ownership mappings\\n    */\\n    // embalmer address => ids of sarcophagi they've created\\n    mapping(address => bytes32[]) embalmerSarcophagi;\\n    // archaeologist address =>  ids of sarcophagi they're protecting\\n    mapping(address => bytes32[]) archaeologistSarcophagi;\\n    // recipient address =>  ids of sarcophagi they're recipient on\\n    mapping(address => bytes32[]) recipientSarcophagi;\\n\\n    // public key => archaeologist address\\n    mapping(bytes => address) publicKeyToArchaeologistAddress;\\n\\n    // sarcophagus id => sarcophagus object\\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\\n\\n    // archaeologist addresses\\n    address[] archaeologistProfileAddresses;\\n    // archaeologist address => profile\\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\\n\\n\\n    // current balance of rewards available for the archaeologist to withdraw\\n    mapping(address => uint256) archaeologistRewards;\\n\\n\\n    /**\\n    * Archaeologist reputation statistics\\n    * todo: could these be organized differently?\\n    */\\n    mapping(address => bytes32[]) archaeologistSuccesses;\\n    mapping(address => bytes32[]) archaeologistAccusals;\\n    mapping(address => bytes32[]) archaeologistCleanups;\\n}\\n\\nlibrary LibAppStorage {\\n    function getAppStorage() internal pure returns (AppStorage storage s) {\\n        // Set the position of our struct in contract storage\\n        // Since AppStorage s is the first and only state variable declared in\\n        // facets its position in contract storage is 0\\n        assembly {\\n            s.slot := 0\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x930c8b51585d3b62feb595057a35cf9c7a38e162d8f914b564cbb9168d6035c3\",\"license\":\"Unlicense\"},\"hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x2205345e83eb86f5281f159a9215a096cb6d404782619f9b8e9d7a4a46c32a37\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061196e806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80634519c2021461003b57806397b03b5314610057575b600080fd5b610055600480360381019061005091906114c3565b610073565b005b610071600480360381019061006c9190611537565b61073e565b005b600080600a016000868152602001908152602001600020905060008160000154036100d557846040517f018da6880000000000000000000000000000000000000000000000000000000081526004016100cc9190611573565b60405180910390fd5b8060000154421115610113576040517f8680d5de00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8060010160009054906101000a900460ff161561016757846040517f9af72b8600000000000000000000000000000000000000000000000000000000815260040161015e9190611573565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8160000154036101cf57846040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016101c69190611573565b60405180910390fd5b60008484905067ffffffffffffffff8111156101ee576101ed61158e565b5b60405190808252806020026020018201604052801561021c5781602001602082028036833780820191505090505b50905060008060005b87879050811015610458576000604051806020016040528060008152509050600080600901826040516102589190611637565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008760090160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008160000180546102df9061167d565b90500361032357336040517f82881f0300000000000000000000000000000000000000000000000000000000815260040161031a91906116bd565b60405180910390fd5b8060020160009054906101000a900460ff161561034257505050610458565b60018160020160006101000a81548160ff0219169083151502179055508187868061036c90611711565b97508151811061037f5761037e611759565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508060030154866103c99190611788565b95506103d9828260030154610f7a565b6000600f0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208c9080600181540180825580915050600190039060005260206000200160009091909190915055505050808061045090611711565b915050610225565b506000810361046a5750505050610738565b8360030160009054906101000a900460ff1660ff1681106104a75760018460010160006101000a81548160ff0219169083151502179055506105af565b6000805b8560080180549050811015610573578560090160008760080183815481106104d6576104d5611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160009054906101000a900460ff161561056057818061055c90611711565b9250505b808061056b90611711565b9150506104ab565b508460030160009054906101000a900460ff1660ff1681106105ad5760018560010160006101000a81548160ff0219169083151502179055505b505b8360010160009054906101000a900460ff16156106ce5760005b84600801805490508110156106cc578460090160008660080183815481106105f4576105f3611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160009054906101000a900460ff166106b9576106b88986600801838154811061068857610687611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166110b5565b5b80806106c490611711565b9150506105c9565b505b6000806106dc87878661112e565b915091503373ffffffffffffffffffffffffffffffffffffffff168a7f6cee286923fc4de6af78ba8b06ff9f4236e5aad4282a5e13a3cea8446c803fd484846040516107299291906117ed565b60405180910390a35050505050505b50505050565b600080600a016000838152602001908152602001600020905060008160000154036107a057816040517f018da6880000000000000000000000000000000000000000000000000000000081526004016107979190611573565b60405180910390fd5b8060010160009054906101000a900460ff16156107f457816040517f9af72b860000000000000000000000000000000000000000000000000000000081526004016107eb9190611573565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81600001540361085c57816040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016108539190611573565b60405180910390fd5b8060010160019054906101000a900460ff16156108b057816040517fc921f1850000000000000000000000000000000000000000000000000000000081526004016108a79190611573565b60405180910390fd5b60006003015481600001546108c59190611788565b421161091e574260006003015482600001546108e19190611788565b6040517f808b7d7c0000000000000000000000000000000000000000000000000000000081526004016109159291906117ed565b60405180910390fd5b8060060160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141580156109b157506109816112d7565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b156109f357336040517fd5fa066e0000000000000000000000000000000000000000000000000000000081526004016109ea91906116bd565b60405180910390fd5b8060060160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148015610a7557506000600501546000600301548260000154610a689190611788565b610a729190611788565b42115b15610add57426000600501546000600301548360000154610a969190611788565b610aa09190611788565b6040517f569861b1000000000000000000000000000000000000000000000000000000008152600401610ad49291906117ed565b60405180910390fd5b610ae56112d7565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148015610b4357506000600501546000600301548260000154610b359190611788565b610b3f9190611788565b4211155b15610bab57426000600501546000600301548360000154610b649190611788565b610b6e9190611788565b6040517ff88af35b000000000000000000000000000000000000000000000000000000008152600401610ba29291906117ed565b60405180910390fd5b6000805b8260080180549050811015610d9d576000836009016000856008018481548110610bdc57610bdb611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060020160009054906101000a900460ff16158015610c6857506000801b8160010154145b15610d8957806003015483610c7d9190611788565b9250806003015483610c8f9190611788565b9250610cdf846008018381548110610caa57610ca9611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168260030154610f7a565b60006010016000856008018481548110610cfc57610cfb611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208590806001815401808255809150506001900390600052602060002001600090919091909150555b508080610d9590611711565b915050610baf565b508160060160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610ebd576000800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8360060160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16836040518363ffffffff1660e01b8152600401610e78929190611816565b6020604051808303816000875af1158015610e97573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ebb9190611877565b505b610ec56112d7565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610f14578060006001016000828254610f0c9190611788565b925050819055505b60018260010160016101000a81548160ff0219169083151502179055503373ffffffffffffffffffffffffffffffffffffffff16837ffa165ffb1378fffa7397821a24fb52e993eab195619a2573789fca8a9e12b26660405160405180910390a3505050565b6000610f8461130a565b905080600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600501548211156110555780600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154826040517faf5a111b00000000000000000000000000000000000000000000000000000000815260040161104c9291906117ed565b60405180910390fd5b8181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546110a991906118a4565b92505081905550505050565b60006110bf61130a565b9050600081600a01600085815260200190815260200160002060090160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905061112883826003015461130f565b50505050565b60008060006002846111409190611907565b90506000818561115091906118a4565b90506000800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8760060160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1684886111c39190611788565b6040518363ffffffff1660e01b81526004016111e0929190611816565b6020604051808303816000875af11580156111ff573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112239190611877565b506000800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb88836040518363ffffffff1660e01b8152600401611283929190611816565b6020604051808303816000875af11580156112a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112c69190611877565b508082935093505050935093915050565b60006112e1611327565b60040160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600090565b6113198282610f7a565b6113238282611354565b5050565b6000807fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90508091505090565b600061135e61130a565b90508181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546113b49190611788565b92505081905550505050565b600080fd5b600080fd5b6000819050919050565b6113dd816113ca565b81146113e857600080fd5b50565b6000813590506113fa816113d4565b92915050565b600080fd5b600080fd5b600080fd5b60008083601f84011261142557611424611400565b5b8235905067ffffffffffffffff81111561144257611441611405565b5b60208301915083606082028301111561145e5761145d61140a565b5b9250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061149082611465565b9050919050565b6114a081611485565b81146114ab57600080fd5b50565b6000813590506114bd81611497565b92915050565b600080600080606085870312156114dd576114dc6113c0565b5b60006114eb878288016113eb565b945050602085013567ffffffffffffffff81111561150c5761150b6113c5565b5b6115188782880161140f565b9350935050604061152b878288016114ae565b91505092959194509250565b60006020828403121561154d5761154c6113c0565b5b600061155b848285016113eb565b91505092915050565b61156d816113ca565b82525050565b60006020820190506115886000830184611564565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600081519050919050565b600081905092915050565b60005b838110156115f15780820151818401526020810190506115d6565b83811115611600576000848401525b50505050565b6000611611826115bd565b61161b81856115c8565b935061162b8185602086016115d3565b80840191505092915050565b60006116438284611606565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000600282049050600182168061169557607f821691505b6020821081036116a8576116a761164e565b5b50919050565b6116b781611485565b82525050565b60006020820190506116d260008301846116ae565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000819050919050565b600061171c82611707565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361174e5761174d6116d8565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600061179382611707565b915061179e83611707565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156117d3576117d26116d8565b5b828201905092915050565b6117e781611707565b82525050565b600060408201905061180260008301856117de565b61180f60208301846117de565b9392505050565b600060408201905061182b60008301856116ae565b61183860208301846117de565b9392505050565b60008115159050919050565b6118548161183f565b811461185f57600080fd5b50565b6000815190506118718161184b565b92915050565b60006020828403121561188d5761188c6113c0565b5b600061189b84828501611862565b91505092915050565b60006118af82611707565b91506118ba83611707565b9250828210156118cd576118cc6116d8565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061191282611707565b915061191d83611707565b92508261192d5761192c6118d8565b5b82820490509291505056fea264697066735822122086e21ac73b5be639696d2f620e593687b70f17de3a660b676058f57e681787a564736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80634519c2021461003b57806397b03b5314610057575b600080fd5b610055600480360381019061005091906114c3565b610073565b005b610071600480360381019061006c9190611537565b61073e565b005b600080600a016000868152602001908152602001600020905060008160000154036100d557846040517f018da6880000000000000000000000000000000000000000000000000000000081526004016100cc9190611573565b60405180910390fd5b8060000154421115610113576040517f8680d5de00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8060010160009054906101000a900460ff161561016757846040517f9af72b8600000000000000000000000000000000000000000000000000000000815260040161015e9190611573565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8160000154036101cf57846040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016101c69190611573565b60405180910390fd5b60008484905067ffffffffffffffff8111156101ee576101ed61158e565b5b60405190808252806020026020018201604052801561021c5781602001602082028036833780820191505090505b50905060008060005b87879050811015610458576000604051806020016040528060008152509050600080600901826040516102589190611637565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008760090160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008160000180546102df9061167d565b90500361032357336040517f82881f0300000000000000000000000000000000000000000000000000000000815260040161031a91906116bd565b60405180910390fd5b8060020160009054906101000a900460ff161561034257505050610458565b60018160020160006101000a81548160ff0219169083151502179055508187868061036c90611711565b97508151811061037f5761037e611759565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508060030154866103c99190611788565b95506103d9828260030154610f7a565b6000600f0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208c9080600181540180825580915050600190039060005260206000200160009091909190915055505050808061045090611711565b915050610225565b506000810361046a5750505050610738565b8360030160009054906101000a900460ff1660ff1681106104a75760018460010160006101000a81548160ff0219169083151502179055506105af565b6000805b8560080180549050811015610573578560090160008760080183815481106104d6576104d5611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160009054906101000a900460ff161561056057818061055c90611711565b9250505b808061056b90611711565b9150506104ab565b508460030160009054906101000a900460ff1660ff1681106105ad5760018560010160006101000a81548160ff0219169083151502179055505b505b8360010160009054906101000a900460ff16156106ce5760005b84600801805490508110156106cc578460090160008660080183815481106105f4576105f3611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160009054906101000a900460ff166106b9576106b88986600801838154811061068857610687611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166110b5565b5b80806106c490611711565b9150506105c9565b505b6000806106dc87878661112e565b915091503373ffffffffffffffffffffffffffffffffffffffff168a7f6cee286923fc4de6af78ba8b06ff9f4236e5aad4282a5e13a3cea8446c803fd484846040516107299291906117ed565b60405180910390a35050505050505b50505050565b600080600a016000838152602001908152602001600020905060008160000154036107a057816040517f018da6880000000000000000000000000000000000000000000000000000000081526004016107979190611573565b60405180910390fd5b8060010160009054906101000a900460ff16156107f457816040517f9af72b860000000000000000000000000000000000000000000000000000000081526004016107eb9190611573565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81600001540361085c57816040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016108539190611573565b60405180910390fd5b8060010160019054906101000a900460ff16156108b057816040517fc921f1850000000000000000000000000000000000000000000000000000000081526004016108a79190611573565b60405180910390fd5b60006003015481600001546108c59190611788565b421161091e574260006003015482600001546108e19190611788565b6040517f808b7d7c0000000000000000000000000000000000000000000000000000000081526004016109159291906117ed565b60405180910390fd5b8060060160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141580156109b157506109816112d7565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b156109f357336040517fd5fa066e0000000000000000000000000000000000000000000000000000000081526004016109ea91906116bd565b60405180910390fd5b8060060160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148015610a7557506000600501546000600301548260000154610a689190611788565b610a729190611788565b42115b15610add57426000600501546000600301548360000154610a969190611788565b610aa09190611788565b6040517f569861b1000000000000000000000000000000000000000000000000000000008152600401610ad49291906117ed565b60405180910390fd5b610ae56112d7565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148015610b4357506000600501546000600301548260000154610b359190611788565b610b3f9190611788565b4211155b15610bab57426000600501546000600301548360000154610b649190611788565b610b6e9190611788565b6040517ff88af35b000000000000000000000000000000000000000000000000000000008152600401610ba29291906117ed565b60405180910390fd5b6000805b8260080180549050811015610d9d576000836009016000856008018481548110610bdc57610bdb611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060020160009054906101000a900460ff16158015610c6857506000801b8160010154145b15610d8957806003015483610c7d9190611788565b9250806003015483610c8f9190611788565b9250610cdf846008018381548110610caa57610ca9611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168260030154610f7a565b60006010016000856008018481548110610cfc57610cfb611759565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208590806001815401808255809150506001900390600052602060002001600090919091909150555b508080610d9590611711565b915050610baf565b508160060160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610ebd576000800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8360060160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16836040518363ffffffff1660e01b8152600401610e78929190611816565b6020604051808303816000875af1158015610e97573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ebb9190611877565b505b610ec56112d7565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610f14578060006001016000828254610f0c9190611788565b925050819055505b60018260010160016101000a81548160ff0219169083151502179055503373ffffffffffffffffffffffffffffffffffffffff16837ffa165ffb1378fffa7397821a24fb52e993eab195619a2573789fca8a9e12b26660405160405180910390a3505050565b6000610f8461130a565b905080600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600501548211156110555780600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154826040517faf5a111b00000000000000000000000000000000000000000000000000000000815260040161104c9291906117ed565b60405180910390fd5b8181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546110a991906118a4565b92505081905550505050565b60006110bf61130a565b9050600081600a01600085815260200190815260200160002060090160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905061112883826003015461130f565b50505050565b60008060006002846111409190611907565b90506000818561115091906118a4565b90506000800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb8760060160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1684886111c39190611788565b6040518363ffffffff1660e01b81526004016111e0929190611816565b6020604051808303816000875af11580156111ff573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112239190611877565b506000800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb88836040518363ffffffff1660e01b8152600401611283929190611816565b6020604051808303816000875af11580156112a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112c69190611877565b508082935093505050935093915050565b60006112e1611327565b60040160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600090565b6113198282610f7a565b6113238282611354565b5050565b6000807fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90508091505090565b600061135e61130a565b90508181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040160008282546113b49190611788565b92505081905550505050565b600080fd5b600080fd5b6000819050919050565b6113dd816113ca565b81146113e857600080fd5b50565b6000813590506113fa816113d4565b92915050565b600080fd5b600080fd5b600080fd5b60008083601f84011261142557611424611400565b5b8235905067ffffffffffffffff81111561144257611441611405565b5b60208301915083606082028301111561145e5761145d61140a565b5b9250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061149082611465565b9050919050565b6114a081611485565b81146114ab57600080fd5b50565b6000813590506114bd81611497565b92915050565b600080600080606085870312156114dd576114dc6113c0565b5b60006114eb878288016113eb565b945050602085013567ffffffffffffffff81111561150c5761150b6113c5565b5b6115188782880161140f565b9350935050604061152b878288016114ae565b91505092959194509250565b60006020828403121561154d5761154c6113c0565b5b600061155b848285016113eb565b91505092915050565b61156d816113ca565b82525050565b60006020820190506115886000830184611564565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600081519050919050565b600081905092915050565b60005b838110156115f15780820151818401526020810190506115d6565b83811115611600576000848401525b50505050565b6000611611826115bd565b61161b81856115c8565b935061162b8185602086016115d3565b80840191505092915050565b60006116438284611606565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000600282049050600182168061169557607f821691505b6020821081036116a8576116a761164e565b5b50919050565b6116b781611485565b82525050565b60006020820190506116d260008301846116ae565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000819050919050565b600061171c82611707565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361174e5761174d6116d8565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600061179382611707565b915061179e83611707565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156117d3576117d26116d8565b5b828201905092915050565b6117e781611707565b82525050565b600060408201905061180260008301856117de565b61180f60208301846117de565b9392505050565b600060408201905061182b60008301856116ae565b61183860208301846117de565b9392505050565b60008115159050919050565b6118548161183f565b811461185f57600080fd5b50565b6000815190506118718161184b565b92915050565b60006020828403121561188d5761188c6113c0565b5b600061189b84828501611862565b91505092915050565b60006118af82611707565b91506118ba83611707565b9250828210156118cd576118cc6116d8565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061191282611707565b915061191d83611707565b92508261192d5761192c6118d8565b5b82820490509291505056fea264697066735822122086e21ac73b5be639696d2f620e593687b70f17de3a660b676058f57e681787a564736f6c634300080d0033",
  "devdoc": {
    "errors": {
      "EmbalmerClaimWindowPassed(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed clean attempt",
            "embalmerClaimWindowEnd": "Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow"
          }
        }
      ],
      "SarcophagusAlreadyCleaned(bytes32)": [
        {
          "params": {
            "sarcoId": "ID of sarcophagus archaeologist has attempted to publish a private key on"
          }
        }
      ],
      "SenderNotEmbalmerOrAdmin(address)": [
        {
          "params": {
            "senderAddress": "Address of sender"
          }
        }
      ],
      "TooEarlyForAdminClean(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed clean attempt",
            "embalmerClaimWindowEnd": "Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow"
          }
        }
      ],
      "TooEarlyForClean(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed clean attempt",
            "publishDeadline": "Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod"
          }
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "accuse(bytes32,(uint8,bytes32,bytes32)[],address)": {
        "params": {
          "paymentAddress": "the address to which rewards should be sent if successful",
          "sarcoId": "The identifier of the sarcophagus having leaked private keys",
          "signatures": "an array of signatures of the sarcoId signed by the leaked private keys"
        }
      },
      "clean(bytes32)": {
        "params": {
          "sarcoId": "The identifier of the sarcophagus to clean"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "EmbalmerClaimWindowPassed(uint256,uint256)": [
        {
          "notice": "Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed"
        }
      ],
      "SarcophagusAlreadyCleaned(bytes32)": [
        {
          "notice": "Clean has been called on a sarcophagus that has already been cleaned"
        }
      ],
      "SenderNotEmbalmerOrAdmin(address)": [
        {
          "notice": "Clean has been called by someone other than the admin or embalmer of the sarcophagus"
        }
      ],
      "TooEarlyForAdminClean(uint256,uint256)": [
        {
          "notice": "Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed"
        }
      ],
      "TooEarlyForClean(uint256,uint256)": [
        {
          "notice": "Clean has been called before the deadline for archaeologists to publish private keys has passed"
        }
      ]
    },
    "kind": "user",
    "methods": {
      "accuse(bytes32,(uint8,bytes32,bytes32)[],address)": {
        "notice": "Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id and payment address generated with the leaked private keys If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus state will be updated to Accused and bonds for all remaining unaccused archaeologists will be returned"
      },
      "clean(bytes32)": {
        "notice": "If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod, their locked bonds and diggingFees may be claimed by either the embalmer or the admin embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will be able to claim remaining locked bond and diggingFees"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2828,
        "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
        "label": "s",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(AppStorage)4934_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_bytes32)dyn_storage": {
        "base": "t_bytes32",
        "encoding": "dynamic_array",
        "label": "bytes32[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes_memory_ptr": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_contract(IERC20)77": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_array(t_bytes32)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bytes32[])",
        "numberOfBytes": "32",
        "value": "t_array(t_bytes32)dyn_storage"
      },
      "t_mapping(t_address,t_struct(ArchaeologistProfile)4647_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct LibTypes.ArchaeologistProfile)",
        "numberOfBytes": "32",
        "value": "t_struct(ArchaeologistProfile)4647_storage"
      },
      "t_mapping(t_address,t_struct(CursedArchaeologist)4634_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct LibTypes.CursedArchaeologist)",
        "numberOfBytes": "32",
        "value": "t_struct(CursedArchaeologist)4634_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_struct(Sarcophagus)4625_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct LibTypes.Sarcophagus)",
        "numberOfBytes": "32",
        "value": "t_struct(Sarcophagus)4625_storage"
      },
      "t_mapping(t_bytes_memory_ptr,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes_memory_ptr",
        "label": "mapping(bytes => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(AppStorage)4934_storage": {
        "encoding": "inplace",
        "label": "struct AppStorage",
        "members": [
          {
            "astId": 4869,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "sarcoToken",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(IERC20)77"
          },
          {
            "astId": 4871,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "totalProtocolFees",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 4874,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "protocolFeeBasePercentage",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 4876,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "gracePeriod",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 4878,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "expirationThreshold",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 4880,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "embalmerClaimWindow",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 4886,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "embalmerSarcophagi",
            "offset": 0,
            "slot": "6",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          },
          {
            "astId": 4891,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistSarcophagi",
            "offset": 0,
            "slot": "7",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          },
          {
            "astId": 4896,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "recipientSarcophagi",
            "offset": 0,
            "slot": "8",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          },
          {
            "astId": 4900,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "publicKeyToArchaeologistAddress",
            "offset": 0,
            "slot": "9",
            "type": "t_mapping(t_bytes_memory_ptr,t_address)"
          },
          {
            "astId": 4905,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "sarcophagi",
            "offset": 0,
            "slot": "10",
            "type": "t_mapping(t_bytes32,t_struct(Sarcophagus)4625_storage)"
          },
          {
            "astId": 4908,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistProfileAddresses",
            "offset": 0,
            "slot": "11",
            "type": "t_array(t_address)dyn_storage"
          },
          {
            "astId": 4913,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistProfiles",
            "offset": 0,
            "slot": "12",
            "type": "t_mapping(t_address,t_struct(ArchaeologistProfile)4647_storage)"
          },
          {
            "astId": 4917,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistRewards",
            "offset": 0,
            "slot": "13",
            "type": "t_mapping(t_address,t_uint256)"
          },
          {
            "astId": 4923,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistSuccesses",
            "offset": 0,
            "slot": "14",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          },
          {
            "astId": 4928,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistAccusals",
            "offset": 0,
            "slot": "15",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          },
          {
            "astId": 4933,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "archaeologistCleanups",
            "offset": 0,
            "slot": "16",
            "type": "t_mapping(t_address,t_array(t_bytes32)dyn_storage)"
          }
        ],
        "numberOfBytes": "544"
      },
      "t_struct(ArchaeologistProfile)4647_storage": {
        "encoding": "inplace",
        "label": "struct LibTypes.ArchaeologistProfile",
        "members": [
          {
            "astId": 4636,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "exists",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 4638,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "peerId",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          },
          {
            "astId": 4640,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "minimumDiggingFee",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 4642,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "maximumRewrapInterval",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 4644,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "freeBond",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 4646,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "cursedBond",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(CursedArchaeologist)4634_storage": {
        "encoding": "inplace",
        "label": "struct LibTypes.CursedArchaeologist",
        "members": [
          {
            "astId": 4627,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "publicKey",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes_storage"
          },
          {
            "astId": 4629,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "privateKey",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          },
          {
            "astId": 4631,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "isAccused",
            "offset": 0,
            "slot": "2",
            "type": "t_bool"
          },
          {
            "astId": 4633,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "diggingFee",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(Sarcophagus)4625_storage": {
        "encoding": "inplace",
        "label": "struct LibTypes.Sarcophagus",
        "members": [
          {
            "astId": 4600,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "resurrectionTime",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 4602,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "isCompromised",
            "offset": 0,
            "slot": "1",
            "type": "t_bool"
          },
          {
            "astId": 4604,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "isCleaned",
            "offset": 1,
            "slot": "1",
            "type": "t_bool"
          },
          {
            "astId": 4606,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "name",
            "offset": 0,
            "slot": "2",
            "type": "t_string_storage"
          },
          {
            "astId": 4608,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "threshold",
            "offset": 0,
            "slot": "3",
            "type": "t_uint8"
          },
          {
            "astId": 4610,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "maximumRewrapInterval",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 4612,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "arweaveTxId",
            "offset": 0,
            "slot": "5",
            "type": "t_string_storage"
          },
          {
            "astId": 4614,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "embalmerAddress",
            "offset": 0,
            "slot": "6",
            "type": "t_address"
          },
          {
            "astId": 4616,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "recipientAddress",
            "offset": 0,
            "slot": "7",
            "type": "t_address"
          },
          {
            "astId": 4619,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "cursedArchaeologistAddresses",
            "offset": 0,
            "slot": "8",
            "type": "t_array(t_address)dyn_storage"
          },
          {
            "astId": 4624,
            "contract": "contracts/facets/ThirdPartyFacet.sol:ThirdPartyFacet",
            "label": "cursedArchaeologists",
            "offset": 0,
            "slot": "9",
            "type": "t_mapping(t_address,t_struct(CursedArchaeologist)4634_storage)"
          }
        ],
        "numberOfBytes": "320"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}