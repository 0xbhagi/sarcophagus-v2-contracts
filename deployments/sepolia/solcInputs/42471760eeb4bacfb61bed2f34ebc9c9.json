{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/facets/EmbalmerFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract EmbalmerFacet {\n    // IMPORTANT: AppStorage must be the first state variable in the facet.\n    AppStorage internal s;\n\n    /// @notice Emitted when a sarcophagus is created\n    /// @param sarcoId Id of the new sarcophagus\n    /// @param name Name of the new sarcophagus\n    /// @param resurrectionTime Resurrection time of the new sarcophagus\n    /// @param embalmer Address of embalmer\n    /// @param recipient Address of recipient\n    /// @param cursedArchaeologists Array of addresses of cursed archaeologists\n    /// @param totalDiggingFees Total digging fees charged to embalmer to create the sarcophagus\n    /// @param createSarcophagusProtocolFees Total protocol fees charged to embalmer to create the sarcophagus\n    /// @param arweaveTxId arweaveTxId arweave tx id for the sarcophagus: [sarcophagus payload tx, encrypted key share tx]\n    event CreateSarcophagus(\n        bytes32 indexed sarcoId,\n        string name,\n        uint256 resurrectionTime,\n        address embalmer,\n        address recipient,\n        address[] cursedArchaeologists,\n        uint256 totalDiggingFees,\n        uint256 createSarcophagusProtocolFees,\n        string arweaveTxId\n    );\n\n    /// @notice Emitted when a sarcophagus is rewrapped\n    /// @param sarcoId Id of sarcophagus that was buried\n    /// @param resurrectionTime New resurrection time for the sarcophagus\n    /// @param totalDiggingFees Total digging fees charged to the embalmer for the rewrap\n    /// @param rewrapSarcophagusProtocolFees Total protocol fees charged to the embalmer for the rewrap\n    event RewrapSarcophagus(\n        bytes32 indexed sarcoId,\n        uint256 resurrectionTime,\n        uint256 totalDiggingFees,\n        uint256 rewrapSarcophagusProtocolFees\n    );\n\n    /// @notice Emitted when a sarcophagus is buried\n    /// @param sarcoId Id of sarcophagus that was buried\n    event BurySarcophagus(bytes32 indexed sarcoId);\n\n    /// @notice Parameters of a sarcophagus, supplied during sarcophagus creation\n    struct SarcophagusParams {\n        string name;\n        // highest rewrap interval bonded archaeologists have agreed to accept for lifetime of sarcophagus\n        uint256 maximumRewrapInterval;\n        address recipientAddress;\n        uint256 resurrectionTime;\n        uint8 threshold;\n        uint256 creationTime;\n    }\n\n    /// @notice Parameters of an archaeologist's curse, supplied during sarcophagus creation\n    struct SelectedArchaeologistData {\n        bytes publicKey;\n        address archAddress;\n        // diggingFee archaeologist has agreed to receive on sarcophagus for its entire lifetime\n        uint256 diggingFee;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an id that is already in use\n    /// @param sarcoId Id that is already in use\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with expired parameters\n    /// @param currentTime Timestamp of the failed create attempt\n    /// @param creationTime Time when the sarcophagus parameters were created\n    /// @param creationDeadline Deadline for creation of a sarcophagus with the supplied parameters\n    error SarcophagusParametersExpired(\n        uint256 currentTime,\n        uint256 creationTime,\n        uint256 creationDeadline\n    );\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with no archaeologists\n    error NoArchaeologistsProvided();\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a shamir secret sharing threshold of 0\n    error ThresholdCannotBeZero();\n\n    error ThresholdGreaterThanTotalNumberOfArchaeologists(\n        uint8 threshold,\n        uint256 totalNumberOfArchaeologists\n    );\n\n    error ArchaeologistListContainsDuplicate(address archaeologistAddress);\n\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that has already passed\n    /// @param currentTime Timestamp of the failed rewrap attempt\n    /// @param resurrectionTime Resurrection timestamp which has already passed\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\n\n    error PublicKeyAlreadyUsed();\n\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that exceeds the maximum rewrap interval\n    /// @param resurrectionTime Resurrection timestamp which is too far in the future\n    /// @param sarcophagusMaximumRewrapInterval Maximum rewrap interval set for the sarcophagus\n    /// @param maximumPermissibleResurrectionTime Resurrection timestamp which is too far in the future\n    error ResurrectionTimeTooFarInFuture(\n        uint256 resurrectionTime,\n        uint256 sarcophagusMaximumRewrapInterval,\n        uint256 maximumPermissibleResurrectionTime\n    );\n\n    error NewResurrectionTimeInPast(uint256 currentTime, uint256 newResurrectionTime);\n\n    error NewResurrectionTimeTooFarInFuture(\n        uint256 resurrectionTime,\n        uint256 sarcophagusMaximumRewrapInterval,\n        uint256 maximumPermissibleResurrectionTime\n    );\n\n    /// @notice Creates a sarcophagus with the supplied parameters and locks\n    /// a portion of each archaeologist's freeBond equal to the diggingFees for the sarcophagus.\n    /// Verifies that all supplied archaeologists have signed off on the sarcophagus negotiation parameters:\n    ///    - publicKey key they are responsible for\n    ///    - maximumRewrapInterval to be enforced for the lifetime of the sarcophagus\n    ///    - creationTime of sarcophagus\n    ///    - diggingFee to be paid to that archaeologist on all rewraps for the lifetime of the sarcophagus\n    ///\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param sarcophagusParams params to set on sarcophagus being created\n    /// @param selectedArchaeologists the archaeologists the embalmer has selected to curse\n    /// @param arweaveTxId ordered pair of arweave tx ids: [sarcophagus payload tx, encrypted key share tx]\n    function createSarcophagus(\n        bytes32 sarcoId,\n        SarcophagusParams calldata sarcophagusParams,\n        SelectedArchaeologistData[] calldata selectedArchaeologists,\n        string memory arweaveTxId\n    ) external {\n        // Confirm that sarcophagus with supplied id doesn't already exist\n        if (s.sarcophagi[sarcoId].resurrectionTime > 0) {\n            revert SarcophagusAlreadyExists(sarcoId);\n        }\n\n        // Confirm that agreed upon sarcophagus parameters have not expired\n        if (block.timestamp > sarcophagusParams.creationTime + s.expirationThreshold) {\n            revert SarcophagusParametersExpired(\n                block.timestamp,\n                sarcophagusParams.creationTime,\n                sarcophagusParams.creationTime + s.expirationThreshold\n            );\n        }\n\n        // Confirm that resurrection time is in the future\n        if (block.timestamp >= sarcophagusParams.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagusParams.resurrectionTime);\n        }\n\n        // Confirm that resurrection or rewrap will occur before the maximumRewrapInterval elapses\n        if (\n            block.timestamp + sarcophagusParams.maximumRewrapInterval <\n            sarcophagusParams.resurrectionTime\n        ) {\n            revert ResurrectionTimeTooFarInFuture(\n                sarcophagusParams.resurrectionTime,\n                sarcophagusParams.maximumRewrapInterval,\n                block.timestamp + sarcophagusParams.maximumRewrapInterval\n            );\n        }\n\n        // Confirm that archaeologists are provided\n        if (selectedArchaeologists.length == 0) {\n            revert NoArchaeologistsProvided();\n        }\n        // Confirm that threshold is greater than 0\n        if (sarcophagusParams.threshold == 0) {\n            revert ThresholdCannotBeZero();\n        }\n        // Confirm that threshold is less than or equal to the number of archaeologists\n        // (k <= n in a shamir secret sharing scheme)\n        if (sarcophagusParams.threshold > selectedArchaeologists.length) {\n            revert ThresholdGreaterThanTotalNumberOfArchaeologists(\n                sarcophagusParams.threshold,\n                selectedArchaeologists.length\n            );\n        }\n\n        // create the sarcophagus\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n        sarcophagus.name = sarcophagusParams.name;\n        sarcophagus.threshold = sarcophagusParams.threshold;\n        sarcophagus.resurrectionTime = sarcophagusParams.resurrectionTime;\n        sarcophagus.maximumRewrapInterval = sarcophagusParams.maximumRewrapInterval;\n        sarcophagus.arweaveTxId = arweaveTxId;\n        sarcophagus.embalmerAddress = msg.sender;\n        sarcophagus.recipientAddress = sarcophagusParams.recipientAddress;\n        sarcophagus.cursedArchaeologistAddresses = new address[](selectedArchaeologists.length);\n\n        // track total digging fees due upon creation of sarcophagus\n        uint256 totalDiggingFees = 0;\n\n        for (uint256 i = 0; i < selectedArchaeologists.length; i++) {\n            // confirm archaeologist is registered\n            LibUtils.revertIfArchProfileDoesNotExist(selectedArchaeologists[i].archAddress);\n\n            // Confirm archaeologist isn't already cursed on sarcophagus\n            if (\n                sarcophagus\n                    .cursedArchaeologists[selectedArchaeologists[i].archAddress]\n                    .publicKey\n                    .length != 0\n            ) {\n                revert ArchaeologistListContainsDuplicate(selectedArchaeologists[i].archAddress);\n            }\n\n            // todo: check convenience structure for public keys that have already been used\n            if(s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] != address(0)) {\n                revert PublicKeyAlreadyUsed();\n            }\n\n            LibUtils.verifyArchaeologistSignature(\n                selectedArchaeologists[i].publicKey,\n                sarcophagusParams.maximumRewrapInterval,\n                sarcophagusParams.creationTime,\n                selectedArchaeologists[i].diggingFee,\n                selectedArchaeologists[i].v,\n                selectedArchaeologists[i].r,\n                selectedArchaeologists[i].s,\n                selectedArchaeologists[i].archAddress\n            );\n\n            totalDiggingFees += selectedArchaeologists[i].diggingFee;\n\n            // Lock the archaeologist's free bond\n            LibBonds.lockUpBond(\n                selectedArchaeologists[i].archAddress,\n                selectedArchaeologists[i].diggingFee\n            );\n\n            // save the cursedArchaeologist and cursedArchaeologistAddress to be stored on the new sarcophagus\n            sarcophagus.cursedArchaeologists[selectedArchaeologists[i].archAddress] = LibTypes\n                .CursedArchaeologist({\n                    publicKey: selectedArchaeologists[i].publicKey,\n                    privateKey: 0,\n                    isAccused: false,\n                    diggingFee: selectedArchaeologists[i].diggingFee\n                });\n\n            sarcophagus.cursedArchaeologistAddresses[i] = selectedArchaeologists[i].archAddress;\n\n            // add address to pub key mapping\n            s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] = selectedArchaeologists[i].archAddress;\n\n            // update archaeologist-specific convenience lookup structures\n            s.publicKeyToArchaeologistAddress[\n                selectedArchaeologists[i].publicKey\n            ] = selectedArchaeologists[i].archAddress;\n            s.archaeologistSarcophagi[selectedArchaeologists[i].archAddress].push(sarcoId);\n        }\n\n        // update sarcophagus-specific convenience lookup structures\n        s.embalmerSarcophagi[msg.sender].push(sarcoId);\n        s.recipientSarcophagi[sarcophagusParams.recipientAddress].push(sarcoId);\n\n        // Transfer totalDiggingFees and the protocolFees in SARCO from embalmer to this contract\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\n        s.totalProtocolFees += protocolFees;\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\n\n        emit CreateSarcophagus(\n            sarcoId,\n            sarcophagusParams.name,\n            sarcophagusParams.resurrectionTime,\n            msg.sender,\n            sarcophagusParams.recipientAddress,\n            sarcophagus.cursedArchaeologistAddresses,\n            totalDiggingFees,\n            protocolFees,\n            arweaveTxId\n        );\n    }\n\n    /// @notice Updates the resurrectionTime on a sarcophagus. Callable by the embalmer of a sarcophagus if its\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param resurrectionTime the new resurrection time\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime) external {\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm the sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm tx sender is embalmer\n        if (sarcophagus.embalmerAddress != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\n        }\n\n        // Confirm resurrection time has not yet passed\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Confirm that new resurrection time is in future\n        if (block.timestamp >= resurrectionTime) {\n            revert NewResurrectionTimeInPast(block.timestamp, resurrectionTime);\n        }\n\n        // Confirm that new resurrection time doesn't exceed sarcophagus's maximumRewrapInterval\n        if (block.timestamp + sarcophagus.maximumRewrapInterval < resurrectionTime) {\n            revert NewResurrectionTimeTooFarInFuture(\n                resurrectionTime,\n                sarcophagus.maximumRewrapInterval,\n                block.timestamp + sarcophagus.maximumRewrapInterval\n            );\n        }\n\n        // track total digging fees across all archaeologists on the sarcophagus\n        uint256 totalDiggingFees = 0;\n\n        // pay digging fee to each cursed archaeologist on the sarcophagus that has not been accused\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\n                .cursedArchaeologists[archaeologistAddresses[i]];\n\n            // if the archaeologist hasn't been accused transfer them their digging fees\n            if (!cursedArchaeologist.isAccused) {\n                s.archaeologistRewards[archaeologistAddresses[i]] += cursedArchaeologist.diggingFee;\n                totalDiggingFees += cursedArchaeologist.diggingFee;\n            }\n        }\n\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\n\n        // Add the protocol fee to the total protocol fees in storage\n        s.totalProtocolFees += protocolFees;\n\n        // Update the resurrectionTime on the sarcophagus to the supplied value\n        sarcophagus.resurrectionTime = resurrectionTime;\n\n        // Transfer the new digging fees and protocol fees from embalmer to contract\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\n\n        emit RewrapSarcophagus(sarcoId, resurrectionTime, totalDiggingFees, protocolFees);\n    }\n\n    /// @notice Terminates a sarcophagus by setting its resurrection time to infinity and returning locked\n    /// bonds to all innocent cursed archaeologists. Callable by the embalmer of a sarcophagus if its\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\n    /// @param sarcoId the identifier of the sarcophagus\n    function burySarcophagus(bytes32 sarcoId) external {\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm the sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm tx sender is embalmer\n        if (sarcophagus.embalmerAddress != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\n        }\n        // Confirm that the current resurrection time is in the future\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Set resurrection time to infinity\n        sarcophagus.resurrectionTime = 2 ** 256 - 1;\n\n        // for each archaeologist on the sarcophagus, unlock bond and pay digging fees\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\n                .cursedArchaeologists[archaeologistAddresses[i]];\n            // if the archaeologist hasn't been accused transfer them their digging fees and return their locked bond\n            if (!cursedArchaeologist.isAccused) {\n                s.archaeologistRewards[archaeologistAddresses[i]] += cursedArchaeologist.diggingFee;\n                LibBonds.freeArchaeologist(sarcoId, archaeologistAddresses[i]);\n            }\n        }\n\n        emit BurySarcophagus(sarcoId);\n    }\n}\n"
    },
    "contracts/libraries/LibBonds.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\n\nlibrary LibBonds {\n    /// @notice Decreases the amount stored in the freeBond mapping for an\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\n    /// the amount.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being decreased\n    /// @param amount The amount to decrease the free bond by\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Revert if the amount is greater than the current free bond\n        if (amount > s.archaeologistProfiles[archaeologist].freeBond) {\n            revert LibErrors.NotEnoughFreeBond(\n                s.archaeologistProfiles[archaeologist].freeBond,\n                amount\n            );\n        }\n\n        // Decrease the free bond amount\n        s.archaeologistProfiles[archaeologist].freeBond -= amount;\n    }\n\n    /// @notice Increases the amount stored in the freeBond mapping for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being decreased\n    /// @param amount The amount to decrease the free bond by\n    function increaseFreeBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Increase the free bond amount\n        s.archaeologistProfiles[archaeologist].freeBond += amount;\n    }\n\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\n    /// archaeologist. Reverts if the archaeologist's cursed bond is lower than\n    /// the amount.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being decreased\n    /// @param amount The amount to decrease the cursed bond by\n    function decreaseCursedBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Revert if the amount is greater than the current cursed bond\n        if (amount > s.archaeologistProfiles[archaeologist].cursedBond) {\n            revert LibErrors.NotEnoughCursedBond(\n                s.archaeologistProfiles[archaeologist].cursedBond,\n                amount\n            );\n        }\n\n        // Decrease the cursed bond amount\n        s.archaeologistProfiles[archaeologist].cursedBond -= amount;\n    }\n\n    /// @notice Increases the amount stored in the cursedBond mapping for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being decreased\n    /// @param amount The amount to decrease the cursed bond by\n    function increaseCursedBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Increase the cursed bond amount\n        s.archaeologistProfiles[archaeologist].cursedBond += amount;\n    }\n\n    /// @notice Locks up the archaeologist's bond, decreasing the\n    /// archaeologist's free bond by an amount and increasing the\n    /// archaeologist's cursed bond by the same amount.\n    /// @param archaeologist The address of the archaeologist\n    /// @param amount The amount to lock up\n    function lockUpBond(address archaeologist, uint256 amount) internal {\n        // Decrease the free bond amount\n        decreaseFreeBond(archaeologist, amount);\n\n        // Increase the cursed bond amount\n        increaseCursedBond(archaeologist, amount);\n    }\n\n    /// @notice Unlocks the archaeologist's bond, increasing the\n    /// archaeologist's free bond by an amount and decreasing the\n    /// archaeologist's cursed bond by the same amount.\n    /// @param archaeologist The address of the archaeologist\n    /// @param amount The amount to unlock\n    function unlockBond(address archaeologist, uint256 amount) internal {\n        // Decrease the cursed bond amount\n        decreaseCursedBond(archaeologist, amount);\n\n        // Increase the free bond amount\n        increaseFreeBond(archaeologist, amount);\n    }\n\n\n    /// @notice Calculates an archaeologist's cursed bond and frees them\n    /// (unlocks the cursed bond).\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\n    /// @param archaeologistAddress the address of the archaeologist to free\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\n            .sarcophagi[sarcoId]\n            .cursedArchaeologists[archaeologistAddress];\n\n        // Free up the archaeologist's locked bond\n        unlockBond(archaeologistAddress, cursedArchaeologist.diggingFee);\n    }\n}\n"
    },
    "contracts/libraries/LibErrors.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\n/**\n * @title A collection of Errors\n * @notice This library defines all of the Errors that the Sarcophagus system\n * uses.\n */\nlibrary LibErrors {\n\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\n\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\n\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\n\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\n\n    error PrivateKeyDoesNotMatchPublicKey(bytes32 privateKey, bytes publicKey);\n\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\n\n    error SarcophagusInactive(bytes32 sarcoId);\n\n    error SarcophagusCompromised(bytes32 sarcoId);\n\n    error SenderNotEmbalmer(address sender, address embalmer);\n\n    error InvalidSignature(\n        // address recovered from signature via ecrecover\n        address recoveredAddress,\n        // address we expected to have signed the data\n        address expectedAddress\n    );\n\n    // Used when an attempt is made to accuse or rewrap after the resurrection time has already passed (so it's actually time to unwrap it)\n    error SarcophagusIsUnwrappable();\n\n}\n"
    },
    "contracts/libraries/LibTypes.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\n/**\n * @title Types shared across facets for the Sarcophagus diamond\n */\nlibrary LibTypes {\n    struct Sarcophagus {\n        // never zero - use for existence checks\n        uint256 resurrectionTime;\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\n        bool isCompromised;\n        bool isCleaned;\n        string name;\n        uint8 threshold;\n        uint256 maximumRewrapInterval;\n        string arweaveTxId;\n        address embalmerAddress;\n        address recipientAddress;\n        address[] cursedArchaeologistAddresses;\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\n    }\n\n    struct CursedArchaeologist {\n        // never empty - use for existence checks\n        bytes publicKey;\n        bytes32 privateKey;\n        bool isAccused;\n        uint256 diggingFee;\n    }\n\n    struct ArchaeologistProfile {\n        bool exists; // todo: use peerid.length instead of exists\n        string peerId;\n        uint256 minimumDiggingFee;\n        uint256 maximumRewrapInterval;\n        uint256 freeBond;\n        uint256 cursedBond;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n}\n"
    },
    "contracts/libraries/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\n\n/**\n * @title Utility functions used within the Sarcophagus system\n * @notice This library implements various functions that are used throughout\n * Sarcophagus, mainly to DRY up the codebase\n * @dev these functions are all stateless, public, pure/view\n */\nlibrary LibUtils {\n    /**\n     * @notice The archaeologist needs to sign off on two pieces of data\n     * to guarantee their unrwap will be successful\n     *\n     * @param publicKey public key archaeologist is responsible for\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\n     * @param diggingFee that the archaeologist has agreed to for the sarcophagus\n     * @param v signature element\n     * @param r signature element\n     * @param s signature element\n     * @param account address to confirm signature of data came from\n     */\n    function verifyArchaeologistSignature(\n        bytes memory publicKey, // todo: data location?\n        uint256 agreedMaximumRewrapInterval,\n        uint256 timestamp,\n        uint256 diggingFee,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address account\n    ) internal pure {\n        // Hash the hash of the data payload\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(\n                    abi.encode(\n                        publicKey,\n                        agreedMaximumRewrapInterval,\n                        diggingFee,\n                        timestamp\n                    )\n                )\n            )\n        );\n\n        // Generate the address from the signature.\n        // ecrecover should always return a valid address.\n        address recoveredAddress = ecrecover(messageHash, v, r, s);\n\n        if (recoveredAddress != account) {\n            revert LibErrors.InvalidSignature(recoveredAddress, account);\n        }\n    }\n\n    /// @notice Checks if an archaeologist profile exists and\n    /// reverts if so\n    ///\n    /// @param archaeologist the archaeologist address to check existence of\n    function revertIfArchProfileExists(address archaeologist) internal view {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        if (s.archaeologistProfiles[archaeologist].exists) {\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\n        }\n    }\n\n    /// @notice Checks if an archaeologist profile doesn't exist and\n    /// reverts if so\n    ///\n    /// @param archaeologist the archaeologist address to check lack of existence of\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        if (!s.archaeologistProfiles[archaeologist].exists) {\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\n        }\n    }\n\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\n    /// @return The protocol fees amount\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 100;\n    }\n}\n"
    },
    "contracts/storage/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\n\n/**\n* Global diamond storage struct to be shared across facets\n* TODO: Implement diamond storage pattern and consider splitting storage into facet specific structs\n*/\nstruct AppStorage {\n    // SARCO token contract\n    IERC20 sarcoToken;\n\n    // total protocol fees available to be withdrawn by the admin\n    uint256 totalProtocolFees;\n\n    /**\n    * Protocol level admin configurations\n    */\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap\n    uint256 protocolFeeBasePercentage;\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time\n    uint256 gracePeriod;\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated\n    uint256 expirationThreshold;\n    // window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\n    uint256 embalmerClaimWindow;\n\n    /**\n    * Ownership mappings\n    */\n    // embalmer address => ids of sarcophagi they've created\n    mapping(address => bytes32[]) embalmerSarcophagi;\n    // archaeologist address =>  ids of sarcophagi they're protecting\n    mapping(address => bytes32[]) archaeologistSarcophagi;\n    // recipient address =>  ids of sarcophagi they're recipient on\n    mapping(address => bytes32[]) recipientSarcophagi;\n\n    // public key => archaeologist address\n    mapping(bytes => address) publicKeyToArchaeologistAddress;\n\n    // sarcophagus id => sarcophagus object\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\n\n    // archaeologist addresses\n    address[] archaeologistProfileAddresses;\n    // archaeologist address => profile\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\n\n\n    // current balance of rewards available for the archaeologist to withdraw\n    mapping(address => uint256) archaeologistRewards;\n\n\n    /**\n    * Archaeologist reputation statistics\n    * todo: could these be organized differently?\n    */\n    mapping(address => bytes32[]) archaeologistSuccesses;\n    mapping(address => bytes32[]) archaeologistAccusals;\n    mapping(address => bytes32[]) archaeologistCleanups;\n}\n\nlibrary LibAppStorage {\n    function getAppStorage() internal pure returns (AppStorage storage s) {\n        // Set the position of our struct in contract storage\n        // Since AppStorage s is the first and only state variable declared in\n        // facets its position in contract storage is 0\n        assembly {\n            s.slot := 0\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}