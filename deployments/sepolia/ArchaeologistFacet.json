{
  "address": "0x639980c5404764a45d9762b2a3acc8991C1ce7B6",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologistAddress",
          "type": "address"
        }
      ],
      "name": "ArchaeologistAlreadyPublishedPrivateKey",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologistAddress",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "ArchaeologistHasBeenAccused",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "ArchaeologistNotOnSarcophagus",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "exists",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        }
      ],
      "name": "ArchaeologistProfileExistsShouldBe",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "archaeologistAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "publicKey",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "privateKey",
          "type": "bytes32"
        }
      ],
      "name": "ArchaeologistPublishedIncorrectPrivateKey",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "cursedBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "NotEnoughCursedBond",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "NotEnoughFreeBond",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusCompromised",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        }
      ],
      "name": "SarcophagusInactive",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "resurrectionTime",
          "type": "uint256"
        }
      ],
      "name": "TooEarlyForPublish",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "publishDeadline",
          "type": "uint256"
        }
      ],
      "name": "TooLateForPublish",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "depositedBond",
          "type": "uint256"
        }
      ],
      "name": "DepositFreeBond",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "privateKey",
          "type": "bytes32"
        }
      ],
      "name": "PublishPrivateKey",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "minimumDiggingFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        }
      ],
      "name": "RegisterArchaeologist",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "minimumDiggingFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        }
      ],
      "name": "UpdateArchaeologist",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "withdrawnBond",
          "type": "uint256"
        }
      ],
      "name": "WithdrawFreeBond",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "archaeologist",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "withdrawnReward",
          "type": "uint256"
        }
      ],
      "name": "WithdrawReward",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "depositFreeBond",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "sarcoId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "privateKey",
          "type": "bytes32"
        }
      ],
      "name": "publishPrivateKey",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "minimumDiggingFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        }
      ],
      "name": "registerArchaeologist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "peerId",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "minimumDiggingFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maximumRewrapInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "freeBond",
          "type": "uint256"
        }
      ],
      "name": "updateArchaeologist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawFreeBond",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawReward",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x09d580100ee8470305cf180034291a0b3761730240867576975a0f28459c8819",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x60e021fE3F1567752D97f1Bc9Fc77E24efc8FBDC",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "1805313",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd6206ebf926b6fcac9748652cdfb6ee8756b333772a70b7c59edaf3206838ce9",
    "transactionHash": "0x09d580100ee8470305cf180034291a0b3761730240867576975a0f28459c8819",
    "logs": [],
    "blockNumber": 2630333,
    "cumulativeGasUsed": "1805313",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "9b1a1cbc137d98a70bc447679d5e9b0d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologistAddress\",\"type\":\"address\"}],\"name\":\"ArchaeologistAlreadyPublishedPrivateKey\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologistAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"ArchaeologistHasBeenAccused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"ArchaeologistNotOnSarcophagus\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"ArchaeologistProfileExistsShouldBe\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologistAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"}],\"name\":\"ArchaeologistPublishedIncorrectPrivateKey\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cursedBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotEnoughCursedBond\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotEnoughFreeBond\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusCompromised\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"}],\"name\":\"SarcophagusInactive\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resurrectionTime\",\"type\":\"uint256\"}],\"name\":\"TooEarlyForPublish\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publishDeadline\",\"type\":\"uint256\"}],\"name\":\"TooLateForPublish\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositedBond\",\"type\":\"uint256\"}],\"name\":\"DepositFreeBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"}],\"name\":\"PublishPrivateKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumDiggingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"}],\"name\":\"RegisterArchaeologist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumDiggingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"}],\"name\":\"UpdateArchaeologist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnBond\",\"type\":\"uint256\"}],\"name\":\"WithdrawFreeBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnReward\",\"type\":\"uint256\"}],\"name\":\"WithdrawReward\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositFreeBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sarcoId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"}],\"name\":\"publishPrivateKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"}],\"name\":\"registerArchaeologist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"peerId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRewrapInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"}],\"name\":\"updateArchaeologist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFreeBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ArchaeologistAlreadyPublishedPrivateKey(address)\":[{\"params\":{\"archaeologistAddress\":\"address of publishing archaeologist\"}}],\"ArchaeologistHasBeenAccused(address,bytes32)\":[{\"params\":{\"archaeologistAddress\":\"Address of accused archaeologist who is attempting to publish their private key\",\"sarcoId\":\"ID of sarcophagus archaeologist has attempted to publish a key on\"}}],\"ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)\":[{\"params\":{\"archaeologistAddress\":\"address of publishing archaeologist\",\"privateKey\":\"privateKey the archaeologist has attempted to publish\",\"publicKey\":\"publicKey stored for archaeologist on the sarcophagus\"}}],\"TooEarlyForPublish(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed publish attempt\",\"resurrectionTime\":\"Time after which the sarcophagus can be resurrected\"}}],\"TooLateForPublish(uint256,uint256)\":[{\"params\":{\"currentTime\":\"Timestamp of the failed publish attempt\",\"publishDeadline\":\"Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)\"}}]},\"events\":{\"PublishPrivateKey(bytes32,bytes32)\":{\"params\":{\"privateKey\":\"private key that has been published\",\"sarcoId\":\"ID of sarcophagus archaeologist has published the private key on\"}}},\"kind\":\"dev\",\"methods\":{\"depositFreeBond(uint256)\":{\"params\":{\"amount\":\"The amount to deposit\"}},\"publishPrivateKey(bytes32,bytes32)\":{\"params\":{\"privateKey\":\"The private key the archaeologist is publishing\",\"sarcoId\":\"The identifier of the sarcophagus to unwrap\"}},\"registerArchaeologist(string,uint256,uint256,uint256)\":{\"params\":{\"freeBond\":\"How much bond the archaeologist wants to deposit during the register call (if any)\",\"maximumRewrapInterval\":\"The longest interval of time from a rewrap time the arch will accept for a resurrection\",\"minimumDiggingFee\":\"The archaeologist's minimum amount to accept for a digging fee\",\"peerId\":\"The libp2p identifier for the archaeologist\"}},\"updateArchaeologist(string,uint256,uint256,uint256)\":{\"params\":{\"maximumRewrapInterval\":\"The longest interval of time from a rewrap time the arch will accept for a resurrection freeBond How much bond the archaeologist wants to deposit during the update call (if any)\",\"minimumDiggingFee\":\"The archaeologist's minimum amount to accept for a digging fee\",\"peerId\":\"The libp2p identifier for the archaeologist\"}},\"withdrawFreeBond(uint256)\":{\"params\":{\"amount\":\"The amount to withdraw\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"ArchaeologistAlreadyPublishedPrivateKey(address)\":[{\"notice\":\"Archaeologist has attempted to publish a key for a sarcophagus twice\"}],\"ArchaeologistHasBeenAccused(address,bytes32)\":[{\"notice\":\"An archaeologist that has already been successfully accused has attempted to publish their private key\"}],\"ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)\":[{\"notice\":\"Archaeologist has attempted to publish the incorrect private key for a sarcophagus\"}],\"TooEarlyForPublish(uint256,uint256)\":[{\"notice\":\"Archaeologist has attempted to publish a key before the resurrection time\"}],\"TooLateForPublish(uint256,uint256)\":[{\"notice\":\"Archaeologist has attempted to publish a key after the end of the resurrection window\"}]},\"events\":{\"PublishPrivateKey(bytes32,bytes32)\":{\"notice\":\"Emitted when an archaeologist successfully publishes their private key for a sarcophagus\"}},\"kind\":\"user\",\"methods\":{\"depositFreeBond(uint256)\":{\"notice\":\"Deposits an archaeologist's free bond to the contract.\"},\"publishPrivateKey(bytes32,bytes32)\":{\"notice\":\"Publishes the private key for which the archaeologist is responsible during the sarcophagus resurrection window. Pays digging fees to the archaeologist and releases their locked bond. Cannot be called on a compromised or buried sarcophagus.\"},\"registerArchaeologist(string,uint256,uint256,uint256)\":{\"notice\":\"Registers the archaeologist profile\"},\"updateArchaeologist(string,uint256,uint256,uint256)\":{\"notice\":\"Updates the archaeologist profile\"},\"withdrawFreeBond(uint256)\":{\"notice\":\"Withdraws an archaeologist's free bond from the contract.\"},\"withdrawReward()\":{\"notice\":\"Withdraws all rewards from an archaeologist's reward pool\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/ArchaeologistFacet.sol\":\"ArchaeologistFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"contracts/facets/ArchaeologistFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport {LibPrivateKeys} from \\\"../libraries/LibPrivateKeys.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\n\\ncontract ArchaeologistFacet {\\n\\n    /// @notice Emitted when an archaeologist successfully publishes their private key for a sarcophagus\\n    /// @param sarcoId ID of sarcophagus archaeologist has published the private key on\\n    /// @param privateKey private key that has been published\\n    event PublishPrivateKey(bytes32 indexed sarcoId, bytes32 privateKey);\\n\\n    event DepositFreeBond(address indexed archaeologist, uint256 depositedBond);\\n\\n    event RegisterArchaeologist(\\n        address indexed archaeologist,\\n        string peerId,\\n        uint256 minimumDiggingFee,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond\\n    );\\n\\n    event UpdateArchaeologist(\\n        address indexed archaeologist,\\n        string peerId,\\n        uint256 minimumDiggingFee,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond\\n    );\\n\\n    event WithdrawFreeBond(address indexed archaeologist, uint256 withdrawnBond);\\n\\n    event WithdrawReward(address indexed archaeologist, uint256 withdrawnReward);\\n\\n    /// @notice An archaeologist that has already been successfully accused has attempted to publish their private key\\n    /// @param archaeologistAddress Address of accused archaeologist who is attempting to publish their private key\\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a key on\\n    error ArchaeologistHasBeenAccused(address archaeologistAddress, bytes32 sarcoId);\\n\\n    /// @notice Archaeologist has attempted to publish a key before the resurrection time\\n    /// @param currentTime Timestamp of the failed publish attempt\\n    /// @param resurrectionTime Time after which the sarcophagus can be resurrected\\n    error TooEarlyForPublish(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Archaeologist has attempted to publish a key after the end of the resurrection window\\n    /// @param currentTime Timestamp of the failed publish attempt\\n    /// @param publishDeadline Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)\\n    error TooLateForPublish(uint256 currentTime, uint256 publishDeadline);\\n\\n    /// @notice Archaeologist has attempted to publish a key for a sarcophagus twice\\n    /// @param archaeologistAddress address of publishing archaeologist\\n    error ArchaeologistAlreadyPublishedPrivateKey(address archaeologistAddress);\\n\\n    /// @notice Archaeologist has attempted to publish the incorrect private key for a sarcophagus\\n    /// @param archaeologistAddress address of publishing archaeologist\\n    /// @param publicKey publicKey stored for archaeologist on the sarcophagus\\n    /// @param privateKey privateKey the archaeologist has attempted to publish\\n    error ArchaeologistPublishedIncorrectPrivateKey(\\n        address archaeologistAddress,\\n        bytes publicKey,\\n        bytes32 privateKey\\n    );\\n\\n    /// @notice Registers the archaeologist profile\\n    /// @param peerId The libp2p identifier for the archaeologist\\n    /// @param minimumDiggingFee The archaeologist's minimum amount to accept for a digging fee\\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\\n    /// for a resurrection\\n    /// @param freeBond How much bond the archaeologist wants to deposit during the register call (if any)\\n    function registerArchaeologist(\\n        string memory peerId,\\n        uint256 minimumDiggingFee,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        // verify that the archaeologist does not already exist\\n        LibUtils.revertIfArchProfileExists(msg.sender);\\n\\n        // create a new archaeologist\\n        LibTypes.ArchaeologistProfile memory newArch = LibTypes.ArchaeologistProfile({\\n            exists: true,\\n            peerId: peerId,\\n            minimumDiggingFee: minimumDiggingFee,\\n            maximumRewrapInterval: maximumRewrapInterval,\\n            freeBond: freeBond,\\n            cursedBond: 0\\n        });\\n\\n        // transfer SARCO tokens from the archaeologist to this contract, to be\\n        // used as their free bond. can be 0.\\n        if (freeBond > 0) {\\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\\n        }\\n\\n        // save the new archaeologist into relevant data structures\\n        s.archaeologistProfiles[msg.sender] = newArch;\\n        s.archaeologistProfileAddresses.push(msg.sender);\\n\\n        emit RegisterArchaeologist(\\n            msg.sender,\\n            newArch.peerId,\\n            newArch.minimumDiggingFee,\\n            newArch.maximumRewrapInterval,\\n            newArch.freeBond\\n        );\\n    }\\n\\n    /// @notice Updates the archaeologist profile\\n    /// @param peerId The libp2p identifier for the archaeologist\\n    /// @param minimumDiggingFee The archaeologist's minimum amount to accept for a digging fee\\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\\n    /// for a resurrection\\n    /// freeBond How much bond the archaeologist wants to deposit during the update call (if any)\\n    function updateArchaeologist(\\n        string memory peerId,\\n        uint256 minimumDiggingFee,\\n        uint256 maximumRewrapInterval,\\n        uint256 freeBond\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        // verify that the archaeologist exists\\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\\n\\n        // create a new archaeologist\\n        LibTypes.ArchaeologistProfile storage existingArch = s.archaeologistProfiles[msg.sender];\\n        existingArch.peerId = peerId;\\n        existingArch.minimumDiggingFee = minimumDiggingFee;\\n        existingArch.maximumRewrapInterval = maximumRewrapInterval;\\n\\n        // transfer SARCO tokens from the archaeologist to this contract, to be\\n        // used as their free bond. can be 0.\\n        if (freeBond > 0) {\\n            LibBonds.increaseFreeBond(msg.sender, freeBond);\\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\\n        }\\n\\n        emit UpdateArchaeologist(\\n            msg.sender,\\n            existingArch.peerId,\\n            existingArch.minimumDiggingFee,\\n            existingArch.maximumRewrapInterval,\\n            existingArch.freeBond\\n        );\\n    }\\n\\n    /// @notice Deposits an archaeologist's free bond to the contract.\\n    /// @param amount The amount to deposit\\n    function depositFreeBond(uint256 amount) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\\n        // Increase the archaeologist's free bond in app storage\\n        LibBonds.increaseFreeBond(msg.sender, amount);\\n\\n        // Transfer the amount of sarcoToken from the archaeologist to the contract\\n        s.sarcoToken.transferFrom(msg.sender, address(this), amount);\\n        // Emit an event\\n        emit DepositFreeBond(msg.sender, amount);\\n    }\\n\\n    /// @notice Withdraws an archaeologist's free bond from the contract.\\n    /// @param amount The amount to withdraw\\n    function withdrawFreeBond(uint256 amount) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\\n        // Decrease the archaeologist's free bond amount.\\n        // Reverts if there is not enough free bond on the contract.\\n        LibBonds.decreaseFreeBond(msg.sender, amount);\\n\\n        // Transfer the amount of sarcoToken to the archaeologist\\n        s.sarcoToken.transfer(msg.sender, amount);\\n\\n        // Emit an event\\n        emit WithdrawFreeBond(msg.sender, amount);\\n    }\\n\\n    /// @notice Withdraws all rewards from an archaeologist's reward pool\\n    function withdrawReward() external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        uint256 amountToWithdraw = s.archaeologistRewards[msg.sender];\\n        s.archaeologistRewards[msg.sender] = 0;\\n\\n        // Transfer the amount of sarcoToken to the archaeologist\\n        s.sarcoToken.transfer(msg.sender, amountToWithdraw);\\n\\n        emit WithdrawReward(msg.sender, amountToWithdraw);\\n    }\\n\\n    /// @notice Publishes the private key for which the archaeologist is responsible during the\\n    /// sarcophagus resurrection window.\\n    /// Pays digging fees to the archaeologist and releases their locked bond.\\n    /// Cannot be called on a compromised or buried sarcophagus.\\n    /// @param sarcoId The identifier of the sarcophagus to unwrap\\n    /// @param privateKey The private key the archaeologist is publishing\\n    function publishPrivateKey(bytes32 sarcoId, bytes32 privateKey) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm current time is after resurrectionTime\\n        if (block.timestamp < sarcophagus.resurrectionTime) {\\n            revert TooEarlyForPublish(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm current time is within gracePeriod\\n        if (block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod) {\\n            revert TooLateForPublish(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\\n        }\\n\\n        // Confirm tx sender is an archaeologist on the sarcophagus\\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\\n            .sarcophagi[sarcoId]\\n            .cursedArchaeologists[msg.sender];\\n        if (cursedArchaeologist.publicKey.length == 0) {\\n            revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\\n        }\\n\\n        // Confirm archaeologist has not already leaked their private key\\n        if (cursedArchaeologist.isAccused) {\\n            revert ArchaeologistHasBeenAccused(msg.sender, sarcoId);\\n        }\\n\\n        // Confirm archaeologist has not already published their private key\\n        if (cursedArchaeologist.privateKey != 0) {\\n            revert ArchaeologistAlreadyPublishedPrivateKey(msg.sender);\\n        }\\n\\n        // Confirm that the private key being submitted matches the public key stored on the\\n        // sarcophagus for this archaeologist\\n        if (!LibPrivateKeys.isPublicKeyFromPrivateKey(privateKey, cursedArchaeologist.publicKey)) {\\n            revert ArchaeologistPublishedIncorrectPrivateKey(\\n                msg.sender,\\n                cursedArchaeologist.publicKey,\\n                privateKey\\n            );\\n        }\\n\\n        // Store the private key on cursed archaeologist\\n        cursedArchaeologist.privateKey = privateKey;\\n\\n        // Free archaeologist locked bond and transfer digging fees\\n        LibBonds.freeArchaeologist(sarcoId, msg.sender);\\n        s.archaeologistRewards[msg.sender] += cursedArchaeologist.diggingFee;\\n\\n        // Save the successful sarcophagus against the archaeologist\\n        s.archaeologistSuccesses[msg.sender].push(sarcoId);\\n\\n        emit PublishPrivateKey(sarcoId, privateKey);\\n    }\\n}\\n\",\"keccak256\":\"0x0a21a01e07e92b6e1ac5074f62ed414a8184d7d18d2b6861276caeee16ac8820\",\"license\":\"Unlicense\"},\"contracts/facets/EmbalmerFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract EmbalmerFacet {\\n\\n    /// @notice Emitted when a sarcophagus is created\\n    /// @param sarcoId Id of the new sarcophagus\\n    /// @param name Name of the new sarcophagus\\n    /// @param resurrectionTime Resurrection time of the new sarcophagus\\n    /// @param embalmer Address of embalmer\\n    /// @param recipient Address of recipient\\n    /// @param cursedArchaeologists Array of addresses of cursed archaeologists\\n    /// @param totalDiggingFees Total digging fees charged to embalmer to create the sarcophagus\\n    /// @param createSarcophagusProtocolFees Total protocol fees charged to embalmer to create the sarcophagus\\n    /// @param arweaveTxId arweave tx id for the sarcophagus\\n    event CreateSarcophagus(\\n        bytes32 indexed sarcoId,\\n        string name,\\n        uint256 resurrectionTime,\\n        address embalmer,\\n        address recipient,\\n        address[] cursedArchaeologists,\\n        uint256 totalDiggingFees,\\n        uint256 createSarcophagusProtocolFees,\\n        string arweaveTxId\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is rewrapped\\n    /// @param sarcoId Id of sarcophagus that was rewrapped\\n    /// @param resurrectionTime New resurrection time for the sarcophagus\\n    /// @param totalDiggingFees Total digging fees charged to the embalmer for the rewrap\\n    /// @param rewrapSarcophagusProtocolFees Total protocol fees charged to the embalmer for the rewrap\\n    event RewrapSarcophagus(\\n        bytes32 indexed sarcoId,\\n        uint256 resurrectionTime,\\n        uint256 totalDiggingFees,\\n        uint256 rewrapSarcophagusProtocolFees\\n    );\\n\\n    /// @notice Emitted when a sarcophagus is buried\\n    /// @param sarcoId Id of sarcophagus that was buried\\n    event BurySarcophagus(bytes32 indexed sarcoId);\\n\\n    /// @notice Parameters of a sarcophagus, supplied during sarcophagus creation\\n    struct SarcophagusParams {\\n        string name;\\n        // highest rewrap interval bonded archaeologists have agreed to accept for lifetime of sarcophagus\\n        uint256 maximumRewrapInterval;\\n        address recipientAddress;\\n        uint256 resurrectionTime;\\n        uint8 threshold;\\n        uint256 creationTime;\\n    }\\n\\n    /// @notice Parameters of an archaeologist's curse, supplied during sarcophagus creation\\n    struct CurseParams {\\n        bytes publicKey;\\n        address archAddress;\\n        // diggingFee archaeologist has agreed to receive on sarcophagus for its entire lifetime\\n        uint256 diggingFee;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an id that is already in use\\n    /// @param sarcoId Id that is already in use\\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with expired parameters\\n    /// @param currentTime Timestamp of the failed create attempt\\n    /// @param creationTime Time when the sarcophagus parameters were created\\n    /// @param creationDeadline Deadline for creation of a sarcophagus with the supplied parameters\\n    error SarcophagusParametersExpired(\\n        uint256 currentTime,\\n        uint256 creationTime,\\n        uint256 creationDeadline\\n    );\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with no archaeologists\\n    error NoArchaeologistsProvided();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a shamir secret sharing threshold of 0\\n    error ThresholdCannotBeZero();\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with more required archaeologists than total archaeologists\\n    error ThresholdGreaterThanTotalNumberOfArchaeologists(\\n        uint8 threshold,\\n        uint256 totalNumberOfArchaeologists\\n    );\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an archaeologist list that contains the same archaeologist more than once\\n    error ArchaeologistListContainsDuplicate(address archaeologistAddress);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that has already passed\\n    /// @param currentTime Timestamp of the failed rewrap attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a public key that has already been assigned to another sarcophagus\\n    /// @param publicKey the duplicated public key\\n    error DuplicatePublicKey(bytes publicKey);\\n\\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that exceeds the maximum rewrap interval\\n    /// @param resurrectionTime Resurrection timestamp which is too far in the future\\n    /// @param sarcophagusMaximumRewrapInterval Maximum rewrap interval set for the sarcophagus\\n    /// @param maximumPermissibleResurrectionTime Resurrection timestamp which is too far in the future\\n    error ResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    error NewResurrectionTimeInPast(uint256 currentTime, uint256 newResurrectionTime);\\n\\n    error NewResurrectionTimeTooFarInFuture(\\n        uint256 resurrectionTime,\\n        uint256 sarcophagusMaximumRewrapInterval,\\n        uint256 maximumPermissibleResurrectionTime\\n    );\\n\\n    /// @notice Creates a sarcophagus with the supplied parameters and locks\\n    /// a portion of each archaeologist's freeBond equal to the diggingFees for the sarcophagus.\\n    /// Verifies that all supplied archaeologists have signed off on the sarcophagus negotiation parameters:\\n    ///    - publicKey key they are responsible for\\n    ///    - maximumRewrapInterval to be enforced for the lifetime of the sarcophagus\\n    ///    - creationTime of sarcophagus\\n    ///    - diggingFee to be paid to that archaeologist on all rewraps for the lifetime of the sarcophagus\\n    ///\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param sarcophagusParams params to set on sarcophagus being created\\n    /// @param selectedArchaeologists the archaeologists the embalmer has selected to curse\\n    /// @param arweaveTxId id of tx storing the sarcophagus payload on arweave\\n    function createSarcophagus(\\n        bytes32 sarcoId,\\n        SarcophagusParams calldata sarcophagusParams,\\n        CurseParams[] calldata selectedArchaeologists,\\n        string calldata arweaveTxId\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        // Confirm that sarcophagus with supplied id doesn't already exist\\n        if (s.sarcophagi[sarcoId].resurrectionTime > 0) {\\n            revert SarcophagusAlreadyExists(sarcoId);\\n        }\\n\\n        // Confirm that agreed upon sarcophagus parameters have not expired\\n        if (block.timestamp > sarcophagusParams.creationTime + s.expirationThreshold) {\\n            revert SarcophagusParametersExpired(\\n                block.timestamp,\\n                sarcophagusParams.creationTime,\\n                sarcophagusParams.creationTime + s.expirationThreshold\\n            );\\n        }\\n\\n        // Confirm that resurrection time is in the future\\n        if (block.timestamp >= sarcophagusParams.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagusParams.resurrectionTime);\\n        }\\n\\n        // Confirm that resurrection or rewrap will occur before the maximumRewrapInterval elapses\\n        if (\\n            block.timestamp + sarcophagusParams.maximumRewrapInterval <\\n            sarcophagusParams.resurrectionTime\\n        ) {\\n            revert ResurrectionTimeTooFarInFuture(\\n                sarcophagusParams.resurrectionTime,\\n                sarcophagusParams.maximumRewrapInterval,\\n                block.timestamp + sarcophagusParams.maximumRewrapInterval\\n            );\\n        }\\n\\n        // Confirm that archaeologists are provided\\n        if (selectedArchaeologists.length == 0) {\\n            revert NoArchaeologistsProvided();\\n        }\\n        // Confirm that threshold is greater than 0\\n        if (sarcophagusParams.threshold == 0) {\\n            revert ThresholdCannotBeZero();\\n        }\\n        // Confirm that threshold is less than or equal to the number of archaeologists\\n        // (k <= n in a shamir secret sharing scheme)\\n        if (sarcophagusParams.threshold > selectedArchaeologists.length) {\\n            revert ThresholdGreaterThanTotalNumberOfArchaeologists(\\n                sarcophagusParams.threshold,\\n                selectedArchaeologists.length\\n            );\\n        }\\n\\n        // create the sarcophagus\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n        sarcophagus.name = sarcophagusParams.name;\\n        sarcophagus.threshold = sarcophagusParams.threshold;\\n        sarcophagus.resurrectionTime = sarcophagusParams.resurrectionTime;\\n        sarcophagus.maximumRewrapInterval = sarcophagusParams.maximumRewrapInterval;\\n        sarcophagus.arweaveTxId = arweaveTxId;\\n        sarcophagus.embalmerAddress = msg.sender;\\n        sarcophagus.recipientAddress = sarcophagusParams.recipientAddress;\\n        sarcophagus.cursedArchaeologistAddresses = new address[](selectedArchaeologists.length);\\n\\n        // track total digging fees due upon creation of sarcophagus\\n        uint256 totalDiggingFees = 0;\\n\\n        for (uint256 i = 0; i < selectedArchaeologists.length; i++) {\\n            // confirm archaeologist is registered\\n            LibUtils.revertIfArchProfileDoesNotExist(selectedArchaeologists[i].archAddress);\\n\\n            // Confirm archaeologist isn't already cursed on sarcophagus\\n            if (\\n                sarcophagus\\n                    .cursedArchaeologists[selectedArchaeologists[i].archAddress]\\n                    .publicKey\\n                    .length != 0\\n            ) {\\n                revert ArchaeologistListContainsDuplicate(selectedArchaeologists[i].archAddress);\\n            }\\n\\n            if (\\n                s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] != address(0)\\n            ) {\\n                revert DuplicatePublicKey(selectedArchaeologists[i].publicKey);\\n            }\\n\\n            LibUtils.verifyArchaeologistSignature(\\n                selectedArchaeologists[i].publicKey,\\n                sarcophagusParams.maximumRewrapInterval,\\n                sarcophagusParams.creationTime,\\n                selectedArchaeologists[i]\\n            );\\n\\n\\n            totalDiggingFees += selectedArchaeologists[i].diggingFee;\\n\\n            // Lock the archaeologist's free bond\\n            LibBonds.lockUpBond(\\n                selectedArchaeologists[i].archAddress,\\n                selectedArchaeologists[i].diggingFee\\n            );\\n\\n            // save the cursedArchaeologist and cursedArchaeologistAddress to be stored on the new sarcophagus\\n            sarcophagus.cursedArchaeologists[selectedArchaeologists[i].archAddress] = LibTypes\\n                .CursedArchaeologist({\\n                    publicKey: selectedArchaeologists[i].publicKey,\\n                    privateKey: 0,\\n                    isAccused: false,\\n                    diggingFee: selectedArchaeologists[i].diggingFee\\n                });\\n\\n            sarcophagus.cursedArchaeologistAddresses[i] = selectedArchaeologists[i].archAddress;\\n\\n            // add address to pub key mapping\\n            s.publicKeyToArchaeologistAddress[\\n                selectedArchaeologists[i].publicKey\\n            ] = selectedArchaeologists[i].archAddress;\\n\\n            // update archaeologist-specific convenience lookup structures\\n            s.publicKeyToArchaeologistAddress[\\n                selectedArchaeologists[i].publicKey\\n            ] = selectedArchaeologists[i].archAddress;\\n            s.archaeologistSarcophagi[selectedArchaeologists[i].archAddress].push(sarcoId);\\n        }\\n\\n        // update sarcophagus-specific convenience lookup structures\\n        s.embalmerSarcophagi[msg.sender].push(sarcoId);\\n        s.recipientSarcophagi[sarcophagusParams.recipientAddress].push(sarcoId);\\n\\n        // Transfer totalDiggingFees and the protocolFees in SARCO from embalmer to this contract\\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n        s.totalProtocolFees += protocolFees;\\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\\n\\n        emit CreateSarcophagus(\\n            sarcoId,\\n            sarcophagusParams.name,\\n            sarcophagusParams.resurrectionTime,\\n            msg.sender,\\n            sarcophagusParams.recipientAddress,\\n            sarcophagus.cursedArchaeologistAddresses,\\n            totalDiggingFees,\\n            protocolFees,\\n            arweaveTxId\\n        );\\n    }\\n\\n    /// @notice Updates the resurrectionTime on a sarcophagus. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    /// @param resurrectionTime the new resurrection time\\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n\\n        // Confirm resurrection time has not yet passed\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time is in future\\n        if (block.timestamp >= resurrectionTime) {\\n            revert NewResurrectionTimeInPast(block.timestamp, resurrectionTime);\\n        }\\n\\n        // Confirm that new resurrection time doesn't exceed sarcophagus's maximumRewrapInterval\\n        if (block.timestamp + sarcophagus.maximumRewrapInterval < resurrectionTime) {\\n            revert NewResurrectionTimeTooFarInFuture(\\n                resurrectionTime,\\n                sarcophagus.maximumRewrapInterval,\\n                block.timestamp + sarcophagus.maximumRewrapInterval\\n            );\\n        }\\n\\n        // track total digging fees across all archaeologists on the sarcophagus\\n        uint256 totalDiggingFees = 0;\\n\\n        // pay digging fee to each cursed archaeologist on the sarcophagus that has not been accused\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n\\n            // if the archaeologist hasn't been accused transfer them their digging fees\\n            if (!cursedArchaeologist.isAccused) {\\n                s.archaeologistRewards[archaeologistAddresses[i]] += cursedArchaeologist.diggingFee;\\n                totalDiggingFees += cursedArchaeologist.diggingFee;\\n            }\\n        }\\n\\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\\n\\n        // Add the protocol fee to the total protocol fees in storage\\n        s.totalProtocolFees += protocolFees;\\n\\n        // Update the resurrectionTime on the sarcophagus to the supplied value\\n        sarcophagus.resurrectionTime = resurrectionTime;\\n\\n        // Transfer the new digging fees and protocol fees from embalmer to contract\\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\\n\\n        emit RewrapSarcophagus(sarcoId, resurrectionTime, totalDiggingFees, protocolFees);\\n    }\\n\\n    /// @notice Terminates a sarcophagus by setting its resurrection time to infinity and returning locked\\n    /// bonds to all innocent cursed archaeologists. Callable by the embalmer of a sarcophagus if its\\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\\n    /// @param sarcoId the identifier of the sarcophagus\\n    function burySarcophagus(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm tx sender is embalmer\\n        if (sarcophagus.embalmerAddress != msg.sender) {\\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\\n        }\\n        // Confirm that the current resurrection time is in the future\\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Set resurrection time to infinity\\n        sarcophagus.resurrectionTime = 2 ** 256 - 1;\\n\\n        // for each archaeologist on the sarcophagus, unlock bond and pay digging fees\\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\\n        for (uint256 i = 0; i < archaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[archaeologistAddresses[i]];\\n            // if the archaeologist hasn't been accused transfer them their digging fees and return their locked bond\\n            if (!cursedArchaeologist.isAccused) {\\n                s.archaeologistRewards[archaeologistAddresses[i]] += cursedArchaeologist.diggingFee;\\n                LibBonds.freeArchaeologist(sarcoId, archaeologistAddresses[i]);\\n            }\\n        }\\n\\n        emit BurySarcophagus(sarcoId);\\n    }\\n}\\n\",\"keccak256\":\"0xfff0bd84aa29a28104b185cbf4a459c0db335fcedc7fe08758fec83331136258\",\"license\":\"Unlicense\"},\"contracts/facets/ThirdPartyFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport {LibDiamond} from \\\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport {LibBonds} from \\\"../libraries/LibBonds.sol\\\";\\nimport {LibUtils} from \\\"../libraries/LibUtils.sol\\\";\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\ncontract ThirdPartyFacet {\\n\\n    event AccuseArchaeologist(\\n        bytes32 indexed sarcoId,\\n        address indexed accuser,\\n        uint256 accuserBondReward,\\n        uint256 embalmerBondReward\\n    );\\n\\n    event Clean(bytes32 indexed sarcoId, address indexed cleaner);\\n\\n    /// @notice Clean has been called on a sarcophagus that has already been cleaned\\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a private key on\\n    error SarcophagusAlreadyCleaned(bytes32 sarcoId);\\n\\n    /// @notice Clean has been called before the deadline for archaeologists to publish private keys has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param publishDeadline Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\\n    error TooEarlyForClean(uint256 currentTime, uint256 publishDeadline);\\n\\n    /// @notice Clean has been called by someone other than the admin or embalmer of the sarcophagus\\n    /// @param senderAddress Address of sender\\n    error SenderNotEmbalmerOrAdmin(address senderAddress);\\n\\n    /// @notice Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error EmbalmerClaimWindowPassed(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\\n    /// @param currentTime Timestamp of the failed clean attempt\\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\\n    error TooEarlyForAdminClean(uint256 currentTime, uint256 embalmerClaimWindowEnd);\\n\\n    /// @notice Emitted when a third party attempts to accuse an archaeologist on a sarcophagus where the resurrection time has already passed\\n    /// @param currentTime Timestamp of the failed accuse attempt\\n    /// @param resurrectionTime Resurrection timestamp which has already passed\\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\\n\\n    /// @notice Emitted when accuse is called with an unequal numbers of public keys and signatures\\n    /// @param signatures the number of signatures passed into the accuse call\\n    /// @param publicKeys the number of public keys passed into the accuse call\\n    error DifferentNumberOfSignaturesAndPublicKeys(uint256 signatures, uint256 publicKeys);\\n\\n    /// @notice Emitted when accuse is called with an invalid signature for the supplied sarcoId, paymentAddress, and publicKey\\n    /// @param sarcoId that should have been signed\\n    /// @param paymentAddress payment address that should have been signed\\n    /// @param publicKey publicKey that should be derived from signing key\\n    /// @param signature invalid signature\\n    error InvalidAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes publicKey,\\n        LibTypes.Signature signature\\n    );\\n\\n    /// @notice If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod,\\n    /// their locked bonds and diggingFees may be claimed by either the embalmer or the admin\\n    /// embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will\\n    /// be able to claim remaining locked bond and diggingFees\\n    /// @param sarcoId The identifier of the sarcophagus to clean\\n    function clean(bytes32 sarcoId) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm the sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus has not already been cleaned\\n        if (sarcophagus.isCleaned) {\\n            revert SarcophagusAlreadyCleaned(sarcoId);\\n        }\\n\\n        // Confirm that the resurrectionTime + gracePeriod have passed\\n        if (block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod) {\\n            revert TooEarlyForClean(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\\n        }\\n\\n        // Confirm tx sender is embalmer or admin\\n        if (msg.sender != sarcophagus.embalmerAddress && msg.sender != LibDiamond.contractOwner()) {\\n            revert SenderNotEmbalmerOrAdmin(msg.sender);\\n        }\\n\\n        // if sender is embalmer, confirm current time is within embalmerClaimWindow\\n        if (\\n            msg.sender == sarcophagus.embalmerAddress &&\\n            block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert EmbalmerClaimWindowPassed(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // if sender is admin, confirm embalmerClaimWindow has passed\\n        if (\\n            msg.sender == LibDiamond.contractOwner() &&\\n            block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n        ) {\\n            revert TooEarlyForAdminClean(\\n                block.timestamp,\\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\\n            );\\n        }\\n\\n        // sum of locked bonds and digging fees for all archaeologists that have failed to publish private keys before publish deadline and have not been accused\\n        uint256 totalDiggingFeesAndLockedBonds = 0;\\n        for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\\n                .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]];\\n            if (!cursedArchaeologist.isAccused && cursedArchaeologist.privateKey == 0) {\\n                totalDiggingFeesAndLockedBonds += cursedArchaeologist.diggingFee;\\n                // add digging fee for cursedArchaeologist\\n                totalDiggingFeesAndLockedBonds += cursedArchaeologist.diggingFee;\\n                // add locked bond for cursedArchaeologist\\n\\n                // slash the archaeologist's locked bond for the sarcophagus\\n                LibBonds.decreaseCursedBond(\\n                    sarcophagus.cursedArchaeologistAddresses[i],\\n                    cursedArchaeologist.diggingFee\\n                );\\n\\n                // track that the archaeologist has had a clean on this sarcophagus\\n                s.archaeologistCleanups[sarcophagus.cursedArchaeologistAddresses[i]].push(sarcoId);\\n            }\\n        }\\n\\n        // if caller is embalmer, transfer them the total locked bonds and digging fees\\n        if (msg.sender == sarcophagus.embalmerAddress) {\\n            s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFeesAndLockedBonds);\\n        }\\n\\n        // if caller is admin, add total locked bonds and digging fees into protocolFees\\n        if (msg.sender == LibDiamond.contractOwner()) {\\n            s.totalProtocolFees += totalDiggingFeesAndLockedBonds;\\n        }\\n\\n        sarcophagus.isCleaned = true;\\n        emit Clean(sarcoId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id\\n     * and payment address generated with the leaked private keys\\n     * If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be\\n     * split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer\\n     *\\n     * If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus\\n     * state will be updated to Accused and bonds for all remaining unaccused archaeologists will be\\n     * returned\\n     *\\n     * @param sarcoId The identifier of the sarcophagus having leaked private keys\\n     * @param publicKeys an array of public keys corresponding to leaked private keys - order must match order of signatures\\n     * @param signatures an array of signatures of the sarcoId and payment address signed by the leaked private keys - order must match order of publicKeys\\n     * @param paymentAddress the address to which rewards should be sent if successful\\n     */\\n    function accuse(\\n        bytes32 sarcoId,\\n        bytes[] calldata publicKeys,\\n        LibTypes.Signature[] calldata signatures,\\n        address paymentAddress\\n    ) external {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\\n\\n        // Confirm sarcophagus exists\\n        if (sarcophagus.resurrectionTime == 0) {\\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\\n        }\\n\\n        // verify that current time is not past resurrection time\\n        if (block.timestamp > sarcophagus.resurrectionTime) {\\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\\n        }\\n\\n        // Confirm the sarcophagus has not been compromised\\n        if (sarcophagus.isCompromised) {\\n            revert LibErrors.SarcophagusCompromised(sarcoId);\\n        }\\n\\n        // Confirm the sarcophagus is not buried\\n        if (sarcophagus.resurrectionTime == 2 ** 256 - 1) {\\n            revert LibErrors.SarcophagusInactive(sarcoId);\\n        }\\n        if (signatures.length != publicKeys.length) {\\n            revert DifferentNumberOfSignaturesAndPublicKeys(signatures.length, publicKeys.length);\\n        }\\n        // build an array of the addresses of the archaeologists currently being accused\\n        address[] memory accusedArchAddresses = new address[](signatures.length);\\n\\n        // track the combined locked bond across all archaeologists being accused in this call\\n        // locked bond will be equal to the amount of diggingFees allocated by the embalmer to pay the archaeologist\\n        uint256 totalDiggingFees = 0;\\n        uint256 accusalCount = 0;\\n        for (uint256 i = 0; i < signatures.length; i++) {\\n            if (\\n                !LibUtils.verifyAccusalSignature(sarcoId, paymentAddress, publicKeys[i], signatures[i])\\n            ) {\\n                revert InvalidAccusalSignature(sarcoId, paymentAddress, publicKeys[i], signatures[i]);\\n            }\\n\\n            // look up the archaeologist responsible for the publicKey\\n            address accusedArchaeologistAddress = s.publicKeyToArchaeologistAddress[publicKeys[i]];\\n            LibTypes.CursedArchaeologist storage accusedArchaeologist = sarcophagus\\n                .cursedArchaeologists[accusedArchaeologistAddress];\\n\\n            // verify the accused archaeologist is cursed on the sarcophagus\\n            if (accusedArchaeologist.publicKey.length == 0) {\\n                revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\\n            }\\n\\n            // if the archaeologist has already been accused on this sarcophagus break without taking action\\n            if (accusedArchaeologist.isAccused) {\\n                break;\\n            }\\n\\n            // mark the archaeologist on the sarcophagus as having been accused\\n            accusedArchaeologist.isAccused = true;\\n            accusedArchAddresses[accusalCount++] = accusedArchaeologistAddress;\\n\\n            // track the sum of all digging fees for all accused archaeologists\\n            totalDiggingFees += accusedArchaeologist.diggingFee;\\n\\n            // slash the accused archaeologist's bond\\n            LibBonds.decreaseCursedBond(\\n                accusedArchaeologistAddress,\\n                accusedArchaeologist.diggingFee\\n            );\\n\\n            // Save the accusal against the archaeologist\\n            s.archaeologistAccusals[accusedArchaeologistAddress].push(sarcoId);\\n        }\\n\\n        // if none of the accusals were valid because the archaeologists have all already been accused, return without taking action\\n        if (accusalCount == 0) {\\n            return;\\n        }\\n\\n        // the sarcophagus is compromised if the current call has successfully accused the sss threshold of archaeologists\\n        if (accusalCount >= sarcophagus.threshold) {\\n            sarcophagus.isCompromised = true;\\n        } else {\\n            // if the current call hasn't resulted in at least sss threshold archaeologists being accused\\n            // check if total number of historical accusals on sarcophagus is greater than threshold\\n            uint256 totalAccusals = 0;\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                if (\\n                    sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    totalAccusals++;\\n                }\\n            }\\n            // the sarcophagus is compromised if k or more archaeologists have been accused over the lifetime of the sarcophagus\\n            if (totalAccusals >= sarcophagus.threshold) {\\n                sarcophagus.isCompromised = true;\\n            }\\n        }\\n\\n        // if k or more archaeologists have been accused over the lifetime of the sarcophagus, funds should\\n        // be returned to the remaining well behaved archaeologists\\n        if (sarcophagus.isCompromised) {\\n            // iterate through all archaeologist addresses on the sarcophagus\\n            for (uint256 i = 0; i < sarcophagus.cursedArchaeologistAddresses.length; i++) {\\n                // if the archaeologist has never been accused, release their locked bond back to them\\n                if (\\n                    !sarcophagus\\n                        .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\\n                        .isAccused\\n                ) {\\n                    LibBonds.freeArchaeologist(\\n                        sarcoId,\\n                        sarcophagus.cursedArchaeologistAddresses[i]\\n                    );\\n                }\\n            }\\n        }\\n\\n        // refund the diggingFees allocated by the embalmer to the accused archaeologists\\n        // split the total bond being slashed between the embalmer and the payment address\\n        (uint256 accuserBondReward, uint256 embalmerBondReward) = _distributeLoot(\\n            paymentAddress,\\n            sarcophagus,\\n            totalDiggingFees\\n        );\\n\\n        emit AccuseArchaeologist(sarcoId, msg.sender, accuserBondReward, embalmerBondReward);\\n    }\\n\\n    /**\\n     * @notice Takes a sarcophagus's digging fee, splits it in half, and sends\\n     * to paymentAddress and embalmer\\n     * @param paymentAddress payment address for the transaction caller\\n     * @param sarc the sarcophagus to operate on\\n     * @param totalDiggingFee the sum of digging fees of all archs that failed to fulfil their duties\\n     * @return halfToSender the amount of SARCO token going to transaction\\n     * sender\\n     * @return halfToEmbalmer the amount of SARCO token going to embalmer\\n     */\\n    function _distributeLoot(\\n        address paymentAddress,\\n        LibTypes.Sarcophagus storage sarc,\\n        uint256 totalDiggingFee\\n    ) private returns (uint256, uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n        // split the sarcophagus's cursed bond into two halves\\n        uint256 halfToEmbalmer = totalDiggingFee / 2;\\n        uint256 halfToSender = totalDiggingFee - halfToEmbalmer;\\n\\n        // transfer the cursed half, plus digging fee to the\\n        // embalmer\\n        s.sarcoToken.transfer(sarc.embalmerAddress, totalDiggingFee + halfToEmbalmer);\\n\\n        // transfer the other half of the cursed bond to the transaction caller\\n        s.sarcoToken.transfer(paymentAddress, halfToSender);\\n\\n        return (halfToSender, halfToEmbalmer);\\n    }\\n\\n    function _hashHelper(bytes memory data) private pure returns (bytes32) {\\n        return keccak256(data);\\n    }\\n}\\n\",\"keccak256\":\"0x304accc240dec902c61f0ac1b8bb0e61f41b3c3ebc03911117ad5e7bcbb76dd9\",\"license\":\"Unlicense\"},\"contracts/libraries/LibBonds.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\n\\nlibrary LibBonds {\\n    /// @notice Decreases the amount stored in the freeBond mapping for an\\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\\n    /// the amount.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being decreased\\n    /// @param amount The amount to decrease the free bond by\\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current free bond\\n        if (amount > s.archaeologistProfiles[archaeologist].freeBond) {\\n            revert LibErrors.NotEnoughFreeBond(\\n                s.archaeologistProfiles[archaeologist].freeBond,\\n                amount\\n            );\\n        }\\n\\n        // Decrease the free bond amount\\n        s.archaeologistProfiles[archaeologist].freeBond -= amount;\\n    }\\n\\n    /// @notice Increases the amount stored in the freeBond mapping for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// free bond is being decreased\\n    /// @param amount The amount to decrease the free bond by\\n    function increaseFreeBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Increase the free bond amount\\n        s.archaeologistProfiles[archaeologist].freeBond += amount;\\n    }\\n\\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\\n    /// archaeologist. Reverts if the archaeologist's cursed bond is lower than\\n    /// the amount.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// cursed bond is being decreased\\n    /// @param amount The amount to decrease the cursed bond by\\n    function decreaseCursedBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Revert if the amount is greater than the current cursed bond\\n        if (amount > s.archaeologistProfiles[archaeologist].cursedBond) {\\n            revert LibErrors.NotEnoughCursedBond(\\n                s.archaeologistProfiles[archaeologist].cursedBond,\\n                amount\\n            );\\n        }\\n\\n        // Decrease the cursed bond amount\\n        s.archaeologistProfiles[archaeologist].cursedBond -= amount;\\n    }\\n\\n    /// @notice Increases the amount stored in the cursedBond mapping for an\\n    /// archaeologist.\\n    /// @param archaeologist The address of the archaeologist whose\\n    /// cursed bond is being decreased\\n    /// @param amount The amount to decrease the cursed bond by\\n    function increaseCursedBond(address archaeologist, uint256 amount) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        // Increase the cursed bond amount\\n        s.archaeologistProfiles[archaeologist].cursedBond += amount;\\n    }\\n\\n    /// @notice Locks up the archaeologist's bond, decreasing the\\n    /// archaeologist's free bond by an amount and increasing the\\n    /// archaeologist's cursed bond by the same amount.\\n    /// @param archaeologist The address of the archaeologist\\n    /// @param amount The amount to lock up\\n    function lockUpBond(address archaeologist, uint256 amount) internal {\\n        // Decrease the free bond amount\\n        decreaseFreeBond(archaeologist, amount);\\n\\n        // Increase the cursed bond amount\\n        increaseCursedBond(archaeologist, amount);\\n    }\\n\\n    /// @notice Unlocks the archaeologist's bond, increasing the\\n    /// archaeologist's free bond by an amount and decreasing the\\n    /// archaeologist's cursed bond by the same amount.\\n    /// @param archaeologist The address of the archaeologist\\n    /// @param amount The amount to unlock\\n    function unlockBond(address archaeologist, uint256 amount) internal {\\n        // Decrease the cursed bond amount\\n        decreaseCursedBond(archaeologist, amount);\\n\\n        // Increase the free bond amount\\n        increaseFreeBond(archaeologist, amount);\\n    }\\n\\n\\n    /// @notice Calculates an archaeologist's cursed bond and frees them\\n    /// (unlocks the cursed bond).\\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\\n    /// @param archaeologistAddress the address of the archaeologist to free\\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\\n            .sarcophagi[sarcoId]\\n            .cursedArchaeologists[archaeologistAddress];\\n\\n        // Free up the archaeologist's locked bond\\n        unlockBond(archaeologistAddress, cursedArchaeologist.diggingFee);\\n    }\\n}\\n\",\"keccak256\":\"0xc74cba3d575a7d40f467c7e0601e31c829a8b2b658c4234692c609e189637478\",\"license\":\"Unlicense\"},\"contracts/libraries/LibErrors.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title A collection of Errors\\n * @notice This library defines all of the Errors that the Sarcophagus system\\n * uses.\\n */\\nlibrary LibErrors {\\n\\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\\n\\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\\n\\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\\n\\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\\n\\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\\n\\n    error SarcophagusInactive(bytes32 sarcoId);\\n\\n    error SarcophagusCompromised(bytes32 sarcoId);\\n\\n    error SenderNotEmbalmer(address sender, address embalmer);\\n\\n    error InvalidSignature(\\n        // address recovered from signature via ecrecover\\n        address recoveredAddress,\\n        // address we expected to have signed the data\\n        address expectedAddress\\n    );\\n\\n}\\n\",\"keccak256\":\"0x049cbf7e26ce029bd8ad8a2909e7de13886c3f1bd8aa8eefdb480e3ebb178318\",\"license\":\"Unlicense\"},\"contracts/libraries/LibPrivateKeys.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n\\n/**\\n * @title Private key verification\\n * @notice Implements a private key -> public key checking function\\n * @dev modified from https://github.com/1Address/ecsol, removes extra code\\n * which isn't necessary for our Sarcophagus implementation\\n */\\nlibrary LibPrivateKeys {\\n    /**\\n     * @notice Given a private key and a public key, determines if that public\\n     * key was derived from the private key\\n     * @dev based on https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n     * @param privKey an secp256k1 private key\\n     * @param pubKey an uncompressed 65 byte secp256k1 public key\\n     * @return bool indicating whether the public key is derived from the\\n     * private key\\n     */\\n    function isPublicKeyFromPrivateKey(bytes32 privKey, bytes storage pubKey) internal view returns (bool) {\\n        // removes the 0x04 prefix from an uncompressed public key\\n        bytes memory truncatedPublicKey = new bytes(pubKey.length-1);\\n        for (uint256 i = 1; i < pubKey.length; i++) {\\n            truncatedPublicKey[i-1] = pubKey[i];\\n        }\\n\\n        // generator point coordinates and order of secp256k1\\n        uint256 gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\\n        uint256 gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\\n        uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\\n\\n        address signer = ecrecover(\\n            0,\\n            gy % 2 != 0 ? 28 : 27,\\n            bytes32(gx),\\n            bytes32(mulmod(uint256(privKey), gx, m))\\n        );\\n\\n        address xyAddress = address(\\n            uint160(uint256(keccak256(truncatedPublicKey)) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        );\\n        return xyAddress == signer;\\n    }\\n}\\n\",\"keccak256\":\"0x7b90c2b1828edcac015dd57d13c08c6597185ba8fa74b15784cce115da327ad7\",\"license\":\"MIT\"},\"contracts/libraries/LibTypes.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title Types shared across facets for the Sarcophagus diamond\\n */\\nlibrary LibTypes {\\n    struct Sarcophagus {\\n        // never zero - use for existence checks\\n        uint256 resurrectionTime;\\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\\n        bool isCompromised;\\n        bool isCleaned;\\n        string name;\\n        uint8 threshold;\\n        uint256 maximumRewrapInterval;\\n        string arweaveTxId;\\n        address embalmerAddress;\\n        address recipientAddress;\\n        address[] cursedArchaeologistAddresses;\\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\\n    }\\n\\n    struct CursedArchaeologist {\\n        // never empty - use for existence checks\\n        bytes publicKey;\\n        bytes32 privateKey;\\n        bool isAccused;\\n        uint256 diggingFee;\\n    }\\n\\n    struct ArchaeologistProfile {\\n        bool exists; // todo: use peerid.length instead of exists\\n        string peerId;\\n        uint256 minimumDiggingFee;\\n        uint256 maximumRewrapInterval;\\n        uint256 freeBond;\\n        uint256 cursedBond;\\n    }\\n\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n}\\n\",\"keccak256\":\"0xd36dac645e4d3af3bda54c124479e6d932f54aad472b2ee48920b36e81fc10e9\",\"license\":\"Unlicense\"},\"contracts/libraries/LibUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/LibAppStorage.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\nimport {LibErrors} from \\\"../libraries/LibErrors.sol\\\";\\nimport \\\"../facets/ThirdPartyFacet.sol\\\";\\nimport \\\"./LibTypes.sol\\\";\\nimport \\\"../facets/EmbalmerFacet.sol\\\";\\n\\n/**\\n * @title Utility functions used within the Sarcophagus system\\n * @notice This library implements various functions that are used throughout\\n * Sarcophagus, mainly to DRY up the codebase\\n * @dev these functions are all stateless, public, pure/view\\n */\\nlibrary LibUtils {\\n    /**\\n     * @notice The archaeologist needs to sign off on two pieces of data\\n     * to guarantee their unrwap will be successful\\n     *\\n     * @param publicKey public key archaeologist is responsible for\\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\\n     * @param curseParams parameters of curse signed by archaeologist\\n     */\\n    function verifyArchaeologistSignature(\\n        bytes calldata publicKey,\\n        uint256 agreedMaximumRewrapInterval,\\n        uint256 timestamp,\\n        EmbalmerFacet.CurseParams calldata curseParams\\n    ) internal pure {\\n        // Hash the hash of the data payload\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encode(\\n                        curseParams.publicKey,\\n                        agreedMaximumRewrapInterval,\\n                        curseParams.diggingFee,\\n                        timestamp\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Generate the address from the signature.\\n        // ecrecover should always return a valid address.\\n        address recoveredAddress = ecrecover(messageHash, curseParams.v, curseParams.r, curseParams.s);\\n\\n        if (recoveredAddress != curseParams.archAddress) {\\n            revert LibErrors.InvalidSignature(recoveredAddress, curseParams.archAddress);\\n        }\\n    }\\n\\n    /// @notice Verifies that a signature and public key were created from the same private key\\n    /// @param sarcoId the sarcoId that was signed\\n    /// @param paymentAddress the payment address that was signed\\n    /// @param publicKey an uncompressed 65 byte secp256k1 public key\\n    /// @param signature signature on the sarco id and payment address\\n    /// @return true if the signature was signed by the private key corresponding to the supplied public key\\n    function verifyAccusalSignature(\\n        bytes32 sarcoId,\\n        address paymentAddress,\\n        bytes calldata publicKey,\\n        LibTypes.Signature calldata signature\\n    ) internal pure returns (bool) {\\n        // removes the 0x04 prefix from an uncompressed public key\\n        bytes memory truncatedPublicKey = new bytes(publicKey.length - 1);\\n        for (uint256 i = 1; i < publicKey.length; i++) {\\n            truncatedPublicKey[i - 1] = publicKey[i];\\n        }\\n        bytes32 messageHash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(abi.encode(sarcoId, paymentAddress))));\\n        // Use ecrecover to get the address that signed the message\\n        address signingAddress = ecrecover(messageHash, signature.v, signature.r, signature.s);\\n\\n        address publicKeyAddress = address(\\n            uint160(uint256(keccak256(truncatedPublicKey)) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        );\\n\\n        return signingAddress == publicKeyAddress;\\n    }\\n\\n    /// @notice Checks if an archaeologist profile exists and\\n    /// reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check existence of\\n    function revertIfArchProfileExists(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (s.archaeologistProfiles[archaeologist].exists) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Checks if an archaeologist profile doesn't exist and\\n    /// reverts if so\\n    ///\\n    /// @param archaeologist the archaeologist address to check lack of existence of\\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        if (!s.archaeologistProfiles[archaeologist].exists) {\\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\\n        }\\n    }\\n\\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\\n    /// @return The protocol fees amount\\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.getAppStorage();\\n\\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 100;\\n    }\\n}\\n\",\"keccak256\":\"0xa83fbafb36e608f73040937acb992b4644c1f49502de70a5b815261116d7af34\",\"license\":\"Unlicense\"},\"contracts/storage/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libraries/LibTypes.sol\\\";\\n\\n/**\\n* Global diamond storage struct to be shared across facets\\n* TODO: Implement diamond storage pattern and consider splitting storage into facet specific structs\\n*/\\nstruct AppStorage {\\n\\n    // SARCO token contract\\n    IERC20 sarcoToken;\\n\\n    // total protocol fees available to be withdrawn by the admin\\n    uint256 totalProtocolFees;\\n\\n    /**\\n    * Protocol level admin configurations\\n    */\\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap\\n    uint256 protocolFeeBasePercentage;\\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time\\n    uint256 gracePeriod;\\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated\\n    uint256 expirationThreshold;\\n    // window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\\n    uint256 embalmerClaimWindow;\\n\\n    /**\\n    * Ownership mappings\\n    */\\n    // embalmer address => ids of sarcophagi they've created\\n    mapping(address => bytes32[]) embalmerSarcophagi;\\n    // archaeologist address =>  ids of sarcophagi they're protecting\\n    mapping(address => bytes32[]) archaeologistSarcophagi;\\n    // recipient address =>  ids of sarcophagi they're recipient on\\n    mapping(address => bytes32[]) recipientSarcophagi;\\n\\n    // public key => archaeologist address\\n    mapping(bytes => address) publicKeyToArchaeologistAddress;\\n\\n    // sarcophagus id => sarcophagus object\\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\\n\\n    // archaeologist addresses\\n    address[] archaeologistProfileAddresses;\\n    // archaeologist address => profile\\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\\n\\n\\n    // current balance of rewards available for the archaeologist to withdraw\\n    mapping(address => uint256) archaeologistRewards;\\n\\n\\n    /**\\n    * Archaeologist reputation statistics\\n    * todo: could these be organized differently?\\n    */\\n    mapping(address => bytes32[]) archaeologistSuccesses;\\n    mapping(address => bytes32[]) archaeologistAccusals;\\n    mapping(address => bytes32[]) archaeologistCleanups;\\n}\\n\\nlibrary LibAppStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"sarcophagus.storage.dev1\\\");\\n\\n    function getAppStorage() internal pure returns (AppStorage storage s) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1c13d8b13e37b5404d2a1cab3987a0d2e299015dbff0bf43b3231996d6ef3bd9\",\"license\":\"Unlicense\"},\"hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x2205345e83eb86f5281f159a9215a096cb6d404782619f9b8e9d7a4a46c32a37\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611fc4806100206000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c80630c4c35f014610067578063364e080114610083578063449f11a61461009f5780636a5ac74c146100bb578063a4110dbe146100d7578063c885bc58146100f3575b600080fd5b610081600480360381019061007c9190611737565b6100fd565b005b61009d600480360381019061009891906117ba565b6102a6565b005b6100b960048036038101906100b49190611737565b6103ba565b005b6100d560048036038101906100d091906117ba565b61062e565b005b6100f160048036038101906100ec919061181d565b610744565b005b6100fb610be4565b005b6000610107610d72565b905061011233610d9f565b600081600c0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508581600101908051906020019061016f929190611504565b50848160020181905550838160030181905550600083111561023b576101953384610e45565b8160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330866040518463ffffffff1660e01b81526004016101f6939291906118ad565b6020604051808303816000875af1158015610215573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610239919061191c565b505b3373ffffffffffffffffffffffffffffffffffffffff167f4df9330dcb4af4b522d063da8a473d6711cdd390feef75f059a663a76c270139826001018360020154846003015485600401546040516102969493929190611a4f565b60405180910390a2505050505050565b60006102b0610d72565b90506102bb33610d9f565b6102c53383610eb1565b8060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33846040518363ffffffff1660e01b8152600401610324929190611a9b565b6020604051808303816000875af1158015610343573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610367919061191c565b503373ffffffffffffffffffffffffffffffffffffffff167fd91b1e491a880123721b161dbbf8249668b0c546077d7ba4d0016441ca9d8f45836040516103ae9190611ac4565b60405180910390a25050565b60006103c4610d72565b90506103cf33610fec565b60006040518060c001604052806001151581526020018781526020018681526020018581526020018481526020016000815250905060008311156104b3578160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330866040518463ffffffff1660e01b815260040161046e939291906118ad565b6020604051808303816000875af115801561048d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b1919061191c565b505b8082600c0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548160ff0219169083151502179055506020820151816001019080519060200190610531929190611504565b5060408201518160020155606082015181600301556080820151816004015560a0820151816005015590505081600b01339080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167fec728a18db560dc21e59ae36132eb1e1c1b00d056a88ee755e0940e471ad591e826020015183604001518460600151856080015160405161061e9493929190611b56565b60405180910390a2505050505050565b6000610638610d72565b905061064333610d9f565b61064d3383610e45565b8060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330856040518463ffffffff1660e01b81526004016106ae939291906118ad565b6020604051808303816000875af11580156106cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f1919061191c565b503373ffffffffffffffffffffffffffffffffffffffff167ff882a0847c57aefe6f6c7df2098dd0afd122eb0e886199e223651b8e45fda823836040516107389190611ac4565b60405180910390a25050565b600061074e610d72565b9050600081600a016000858152602001908152602001600020905060008160000154036107b257836040517f018da6880000000000000000000000000000000000000000000000000000000081526004016107a99190611bb1565b60405180910390fd5b8060010160009054906101000a900460ff161561080657836040517f9af72b860000000000000000000000000000000000000000000000000000000081526004016107fd9190611bb1565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81600001540361086e57836040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016108659190611bb1565b60405180910390fd5b80600001544210156108bd574281600001546040517f482768090000000000000000000000000000000000000000000000000000000081526004016108b4929190611bcc565b60405180910390fd5b816003015481600001546108d19190611c24565b42111561092a5742826003015482600001546108ed9190611c24565b6040517f4ccffab1000000000000000000000000000000000000000000000000000000008152600401610921929190611bcc565b60405180910390fd5b600082600a01600086815260200190815260200160002060090160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600081600001805461099490611978565b9050036109d857336040517f82881f030000000000000000000000000000000000000000000000000000000081526004016109cf9190611c7a565b60405180910390fd5b8060020160009054906101000a900460ff1615610a2e5733856040517fa40b4423000000000000000000000000000000000000000000000000000000008152600401610a25929190611c95565b60405180910390fd5b6000801b816001015414610a7957336040517f7b06b177000000000000000000000000000000000000000000000000000000008152600401610a709190611c7a565b60405180910390fd5b610a868482600001611093565b610ace573381600001856040517f5a95e91c000000000000000000000000000000000000000000000000000000008152600401610ac593929190611d64565b60405180910390fd5b838160010181905550610ae18533611338565b806003015483600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254610b369190611c24565b9250508190555082600e0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020859080600181540180825580915050600190039060005260206000200160009091909190915055847f3e5a6fa1aea4d7b93ca7b96ea3b3a42e221934c707be2efa8c5678da3d345f2d85604051610bd59190611bb1565b60405180910390a25050505050565b6000610bee610d72565b9050600081600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050600082600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33836040518363ffffffff1660e01b8152600401610cdc929190611a9b565b6020604051808303816000875af1158015610cfb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d1f919061191c565b503373ffffffffffffffffffffffffffffffffffffffff167fbc84835063c693975166f00cffb19f01a94c2db55b1bf259238c5da3594e506682604051610d669190611ac4565b60405180910390a25050565b6000807fe7e19c3fbf84f26ac171b2009b923863c68cc47279d5c6e6a019ce74e2daf4f490508091505090565b6000610da9610d72565b905080600c0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16610e41576001826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401610e38929190611db1565b60405180910390fd5b5050565b6000610e4f610d72565b90508181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206004016000828254610ea59190611c24565b92505081905550505050565b6000610ebb610d72565b905080600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154821115610f8c5780600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154826040517fa4e3bead000000000000000000000000000000000000000000000000000000008152600401610f83929190611bcc565b60405180910390fd5b8181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206004016000828254610fe09190611dda565b92505081905550505050565b6000610ff6610d72565b905080600c0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff161561108f576000826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401611086929190611db1565b60405180910390fd5b5050565b60008060018380546110a490611978565b90506110b09190611dda565b67ffffffffffffffff8111156110c9576110c86115d6565b5b6040519080825280601f01601f1916602001820160405280156110fb5781602001600182028036833780820191505090505b5090506000600190505b83805461111190611978565b90508110156111dc578381815461112790611978565b811061113657611135611e0e565b5b8154600116156111555790600052602060002090602091828204019190065b9054901a7f010000000000000000000000000000000000000000000000000000000000000002826001836111899190611dda565b8151811061119a57611199611e0e565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806111d490611e3d565b915050611105565b5060007f79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798905060007f483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8905060007ffffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd03641419050600060016000806002866112609190611eb4565b0361126c57601b61126f565b601c5b8660001b858061128257611281611e85565b5b888d60001c0960001b604051600081526020016040526040516112a89493929190611f49565b6020604051602081039080840390855afa1580156112ca573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff868051906020012060001c1690508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614965050505050505092915050565b6000611342610d72565b9050600081600a01600085815260200190815260200160002060090160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506113ab8382600301546113b1565b50505050565b6113bb82826113c9565b6113c58282610e45565b5050565b60006113d3610d72565b905080600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600501548211156114a45780600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154826040517faf5a111b00000000000000000000000000000000000000000000000000000000815260040161149b929190611bcc565b60405180910390fd5b8181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546114f89190611dda565b92505081905550505050565b82805461151090611978565b90600052602060002090601f0160209004810192826115325760008555611579565b82601f1061154b57805160ff1916838001178555611579565b82800160010185558215611579579182015b8281111561157857825182559160200191906001019061155d565b5b509050611586919061158a565b5090565b5b808211156115a357600081600090555060010161158b565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61160e826115c5565b810181811067ffffffffffffffff8211171561162d5761162c6115d6565b5b80604052505050565b60006116406115a7565b905061164c8282611605565b919050565b600067ffffffffffffffff82111561166c5761166b6115d6565b5b611675826115c5565b9050602081019050919050565b82818337600083830152505050565b60006116a461169f84611651565b611636565b9050828152602081018484840111156116c0576116bf6115c0565b5b6116cb848285611682565b509392505050565b600082601f8301126116e8576116e76115bb565b5b81356116f8848260208601611691565b91505092915050565b6000819050919050565b61171481611701565b811461171f57600080fd5b50565b6000813590506117318161170b565b92915050565b60008060008060808587031215611751576117506115b1565b5b600085013567ffffffffffffffff81111561176f5761176e6115b6565b5b61177b878288016116d3565b945050602061178c87828801611722565b935050604061179d87828801611722565b92505060606117ae87828801611722565b91505092959194509250565b6000602082840312156117d0576117cf6115b1565b5b60006117de84828501611722565b91505092915050565b6000819050919050565b6117fa816117e7565b811461180557600080fd5b50565b600081359050611817816117f1565b92915050565b60008060408385031215611834576118336115b1565b5b600061184285828601611808565b925050602061185385828601611808565b9150509250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006118888261185d565b9050919050565b6118988161187d565b82525050565b6118a781611701565b82525050565b60006060820190506118c2600083018661188f565b6118cf602083018561188f565b6118dc604083018461189e565b949350505050565b60008115159050919050565b6118f9816118e4565b811461190457600080fd5b50565b600081519050611916816118f0565b92915050565b600060208284031215611932576119316115b1565b5b600061194084828501611907565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000600282049050600182168061199057607f821691505b6020821081036119a3576119a2611949565b5b50919050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b600081546119dc81611978565b6119e681866119a9565b94506001821660008114611a015760018114611a1357611a46565b60ff1983168652602086019350611a46565b611a1c856119ba565b60005b83811015611a3e57815481890152600182019150602081019050611a1f565b808801955050505b50505092915050565b60006080820190508181036000830152611a6981876119cf565b9050611a78602083018661189e565b611a85604083018561189e565b611a92606083018461189e565b95945050505050565b6000604082019050611ab0600083018561188f565b611abd602083018461189e565b9392505050565b6000602082019050611ad9600083018461189e565b92915050565b600081519050919050565b60005b83811015611b08578082015181840152602081019050611aed565b83811115611b17576000848401525b50505050565b6000611b2882611adf565b611b3281856119a9565b9350611b42818560208601611aea565b611b4b816115c5565b840191505092915050565b60006080820190508181036000830152611b708187611b1d565b9050611b7f602083018661189e565b611b8c604083018561189e565b611b99606083018461189e565b95945050505050565b611bab816117e7565b82525050565b6000602082019050611bc66000830184611ba2565b92915050565b6000604082019050611be1600083018561189e565b611bee602083018461189e565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611c2f82611701565b9150611c3a83611701565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115611c6f57611c6e611bf5565b5b828201905092915050565b6000602082019050611c8f600083018461188f565b92915050565b6000604082019050611caa600083018561188f565b611cb76020830184611ba2565b9392505050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b60008154611cf181611978565b611cfb8186611cbe565b94506001821660008114611d165760018114611d2857611d5b565b60ff1983168652602086019350611d5b565b611d3185611ccf565b60005b83811015611d5357815481890152600182019150602081019050611d34565b808801955050505b50505092915050565b6000606082019050611d79600083018661188f565b8181036020830152611d8b8185611ce4565b9050611d9a6040830184611ba2565b949350505050565b611dab816118e4565b82525050565b6000604082019050611dc66000830185611da2565b611dd3602083018461188f565b9392505050565b6000611de582611701565b9150611df083611701565b925082821015611e0357611e02611bf5565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000611e4882611701565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611e7a57611e79611bf5565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000611ebf82611701565b9150611eca83611701565b925082611eda57611ed9611e85565b5b828206905092915050565b6000819050919050565b60008160001b9050919050565b6000611f17611f12611f0d84611ee5565b611eef565b6117e7565b9050919050565b611f2781611efc565b82525050565b600060ff82169050919050565b611f4381611f2d565b82525050565b6000608082019050611f5e6000830187611f1e565b611f6b6020830186611f3a565b611f786040830185611ba2565b611f856060830184611ba2565b9594505050505056fea2646970667358221220fbee25bb5010b1116d98b9198e50ef0cb35088d2517d84ea5fc72f4bc8da6f2564736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100625760003560e01c80630c4c35f014610067578063364e080114610083578063449f11a61461009f5780636a5ac74c146100bb578063a4110dbe146100d7578063c885bc58146100f3575b600080fd5b610081600480360381019061007c9190611737565b6100fd565b005b61009d600480360381019061009891906117ba565b6102a6565b005b6100b960048036038101906100b49190611737565b6103ba565b005b6100d560048036038101906100d091906117ba565b61062e565b005b6100f160048036038101906100ec919061181d565b610744565b005b6100fb610be4565b005b6000610107610d72565b905061011233610d9f565b600081600c0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508581600101908051906020019061016f929190611504565b50848160020181905550838160030181905550600083111561023b576101953384610e45565b8160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330866040518463ffffffff1660e01b81526004016101f6939291906118ad565b6020604051808303816000875af1158015610215573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610239919061191c565b505b3373ffffffffffffffffffffffffffffffffffffffff167f4df9330dcb4af4b522d063da8a473d6711cdd390feef75f059a663a76c270139826001018360020154846003015485600401546040516102969493929190611a4f565b60405180910390a2505050505050565b60006102b0610d72565b90506102bb33610d9f565b6102c53383610eb1565b8060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33846040518363ffffffff1660e01b8152600401610324929190611a9b565b6020604051808303816000875af1158015610343573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610367919061191c565b503373ffffffffffffffffffffffffffffffffffffffff167fd91b1e491a880123721b161dbbf8249668b0c546077d7ba4d0016441ca9d8f45836040516103ae9190611ac4565b60405180910390a25050565b60006103c4610d72565b90506103cf33610fec565b60006040518060c001604052806001151581526020018781526020018681526020018581526020018481526020016000815250905060008311156104b3578160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330866040518463ffffffff1660e01b815260040161046e939291906118ad565b6020604051808303816000875af115801561048d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b1919061191c565b505b8082600c0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548160ff0219169083151502179055506020820151816001019080519060200190610531929190611504565b5060408201518160020155606082015181600301556080820151816004015560a0820151816005015590505081600b01339080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff167fec728a18db560dc21e59ae36132eb1e1c1b00d056a88ee755e0940e471ad591e826020015183604001518460600151856080015160405161061e9493929190611b56565b60405180910390a2505050505050565b6000610638610d72565b905061064333610d9f565b61064d3383610e45565b8060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330856040518463ffffffff1660e01b81526004016106ae939291906118ad565b6020604051808303816000875af11580156106cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f1919061191c565b503373ffffffffffffffffffffffffffffffffffffffff167ff882a0847c57aefe6f6c7df2098dd0afd122eb0e886199e223651b8e45fda823836040516107389190611ac4565b60405180910390a25050565b600061074e610d72565b9050600081600a016000858152602001908152602001600020905060008160000154036107b257836040517f018da6880000000000000000000000000000000000000000000000000000000081526004016107a99190611bb1565b60405180910390fd5b8060010160009054906101000a900460ff161561080657836040517f9af72b860000000000000000000000000000000000000000000000000000000081526004016107fd9190611bb1565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81600001540361086e57836040517f7c6a6d700000000000000000000000000000000000000000000000000000000081526004016108659190611bb1565b60405180910390fd5b80600001544210156108bd574281600001546040517f482768090000000000000000000000000000000000000000000000000000000081526004016108b4929190611bcc565b60405180910390fd5b816003015481600001546108d19190611c24565b42111561092a5742826003015482600001546108ed9190611c24565b6040517f4ccffab1000000000000000000000000000000000000000000000000000000008152600401610921929190611bcc565b60405180910390fd5b600082600a01600086815260200190815260200160002060090160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600081600001805461099490611978565b9050036109d857336040517f82881f030000000000000000000000000000000000000000000000000000000081526004016109cf9190611c7a565b60405180910390fd5b8060020160009054906101000a900460ff1615610a2e5733856040517fa40b4423000000000000000000000000000000000000000000000000000000008152600401610a25929190611c95565b60405180910390fd5b6000801b816001015414610a7957336040517f7b06b177000000000000000000000000000000000000000000000000000000008152600401610a709190611c7a565b60405180910390fd5b610a868482600001611093565b610ace573381600001856040517f5a95e91c000000000000000000000000000000000000000000000000000000008152600401610ac593929190611d64565b60405180910390fd5b838160010181905550610ae18533611338565b806003015483600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254610b369190611c24565b9250508190555082600e0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020859080600181540180825580915050600190039060005260206000200160009091909190915055847f3e5a6fa1aea4d7b93ca7b96ea3b3a42e221934c707be2efa8c5678da3d345f2d85604051610bd59190611bb1565b60405180910390a25050505050565b6000610bee610d72565b9050600081600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050600082600d0160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33836040518363ffffffff1660e01b8152600401610cdc929190611a9b565b6020604051808303816000875af1158015610cfb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d1f919061191c565b503373ffffffffffffffffffffffffffffffffffffffff167fbc84835063c693975166f00cffb19f01a94c2db55b1bf259238c5da3594e506682604051610d669190611ac4565b60405180910390a25050565b6000807fe7e19c3fbf84f26ac171b2009b923863c68cc47279d5c6e6a019ce74e2daf4f490508091505090565b6000610da9610d72565b905080600c0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16610e41576001826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401610e38929190611db1565b60405180910390fd5b5050565b6000610e4f610d72565b90508181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206004016000828254610ea59190611c24565b92505081905550505050565b6000610ebb610d72565b905080600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154821115610f8c5780600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060040154826040517fa4e3bead000000000000000000000000000000000000000000000000000000008152600401610f83929190611bcc565b60405180910390fd5b8181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206004016000828254610fe09190611dda565b92505081905550505050565b6000610ff6610d72565b905080600c0160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff161561108f576000826040517f2eeb3571000000000000000000000000000000000000000000000000000000008152600401611086929190611db1565b60405180910390fd5b5050565b60008060018380546110a490611978565b90506110b09190611dda565b67ffffffffffffffff8111156110c9576110c86115d6565b5b6040519080825280601f01601f1916602001820160405280156110fb5781602001600182028036833780820191505090505b5090506000600190505b83805461111190611978565b90508110156111dc578381815461112790611978565b811061113657611135611e0e565b5b8154600116156111555790600052602060002090602091828204019190065b9054901a7f010000000000000000000000000000000000000000000000000000000000000002826001836111899190611dda565b8151811061119a57611199611e0e565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806111d490611e3d565b915050611105565b5060007f79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798905060007f483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8905060007ffffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd03641419050600060016000806002866112609190611eb4565b0361126c57601b61126f565b601c5b8660001b858061128257611281611e85565b5b888d60001c0960001b604051600081526020016040526040516112a89493929190611f49565b6020604051602081039080840390855afa1580156112ca573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff868051906020012060001c1690508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614965050505050505092915050565b6000611342610d72565b9050600081600a01600085815260200190815260200160002060090160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506113ab8382600301546113b1565b50505050565b6113bb82826113c9565b6113c58282610e45565b5050565b60006113d3610d72565b905080600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600501548211156114a45780600c0160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050154826040517faf5a111b00000000000000000000000000000000000000000000000000000000815260040161149b929190611bcc565b60405180910390fd5b8181600c0160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060050160008282546114f89190611dda565b92505081905550505050565b82805461151090611978565b90600052602060002090601f0160209004810192826115325760008555611579565b82601f1061154b57805160ff1916838001178555611579565b82800160010185558215611579579182015b8281111561157857825182559160200191906001019061155d565b5b509050611586919061158a565b5090565b5b808211156115a357600081600090555060010161158b565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61160e826115c5565b810181811067ffffffffffffffff8211171561162d5761162c6115d6565b5b80604052505050565b60006116406115a7565b905061164c8282611605565b919050565b600067ffffffffffffffff82111561166c5761166b6115d6565b5b611675826115c5565b9050602081019050919050565b82818337600083830152505050565b60006116a461169f84611651565b611636565b9050828152602081018484840111156116c0576116bf6115c0565b5b6116cb848285611682565b509392505050565b600082601f8301126116e8576116e76115bb565b5b81356116f8848260208601611691565b91505092915050565b6000819050919050565b61171481611701565b811461171f57600080fd5b50565b6000813590506117318161170b565b92915050565b60008060008060808587031215611751576117506115b1565b5b600085013567ffffffffffffffff81111561176f5761176e6115b6565b5b61177b878288016116d3565b945050602061178c87828801611722565b935050604061179d87828801611722565b92505060606117ae87828801611722565b91505092959194509250565b6000602082840312156117d0576117cf6115b1565b5b60006117de84828501611722565b91505092915050565b6000819050919050565b6117fa816117e7565b811461180557600080fd5b50565b600081359050611817816117f1565b92915050565b60008060408385031215611834576118336115b1565b5b600061184285828601611808565b925050602061185385828601611808565b9150509250929050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006118888261185d565b9050919050565b6118988161187d565b82525050565b6118a781611701565b82525050565b60006060820190506118c2600083018661188f565b6118cf602083018561188f565b6118dc604083018461189e565b949350505050565b60008115159050919050565b6118f9816118e4565b811461190457600080fd5b50565b600081519050611916816118f0565b92915050565b600060208284031215611932576119316115b1565b5b600061194084828501611907565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000600282049050600182168061199057607f821691505b6020821081036119a3576119a2611949565b5b50919050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b600081546119dc81611978565b6119e681866119a9565b94506001821660008114611a015760018114611a1357611a46565b60ff1983168652602086019350611a46565b611a1c856119ba565b60005b83811015611a3e57815481890152600182019150602081019050611a1f565b808801955050505b50505092915050565b60006080820190508181036000830152611a6981876119cf565b9050611a78602083018661189e565b611a85604083018561189e565b611a92606083018461189e565b95945050505050565b6000604082019050611ab0600083018561188f565b611abd602083018461189e565b9392505050565b6000602082019050611ad9600083018461189e565b92915050565b600081519050919050565b60005b83811015611b08578082015181840152602081019050611aed565b83811115611b17576000848401525b50505050565b6000611b2882611adf565b611b3281856119a9565b9350611b42818560208601611aea565b611b4b816115c5565b840191505092915050565b60006080820190508181036000830152611b708187611b1d565b9050611b7f602083018661189e565b611b8c604083018561189e565b611b99606083018461189e565b95945050505050565b611bab816117e7565b82525050565b6000602082019050611bc66000830184611ba2565b92915050565b6000604082019050611be1600083018561189e565b611bee602083018461189e565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611c2f82611701565b9150611c3a83611701565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115611c6f57611c6e611bf5565b5b828201905092915050565b6000602082019050611c8f600083018461188f565b92915050565b6000604082019050611caa600083018561188f565b611cb76020830184611ba2565b9392505050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b60008154611cf181611978565b611cfb8186611cbe565b94506001821660008114611d165760018114611d2857611d5b565b60ff1983168652602086019350611d5b565b611d3185611ccf565b60005b83811015611d5357815481890152600182019150602081019050611d34565b808801955050505b50505092915050565b6000606082019050611d79600083018661188f565b8181036020830152611d8b8185611ce4565b9050611d9a6040830184611ba2565b949350505050565b611dab816118e4565b82525050565b6000604082019050611dc66000830185611da2565b611dd3602083018461188f565b9392505050565b6000611de582611701565b9150611df083611701565b925082821015611e0357611e02611bf5565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000611e4882611701565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611e7a57611e79611bf5565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000611ebf82611701565b9150611eca83611701565b925082611eda57611ed9611e85565b5b828206905092915050565b6000819050919050565b60008160001b9050919050565b6000611f17611f12611f0d84611ee5565b611eef565b6117e7565b9050919050565b611f2781611efc565b82525050565b600060ff82169050919050565b611f4381611f2d565b82525050565b6000608082019050611f5e6000830187611f1e565b611f6b6020830186611f3a565b611f786040830185611ba2565b611f856060830184611ba2565b9594505050505056fea2646970667358221220fbee25bb5010b1116d98b9198e50ef0cb35088d2517d84ea5fc72f4bc8da6f2564736f6c634300080d0033",
  "devdoc": {
    "errors": {
      "ArchaeologistAlreadyPublishedPrivateKey(address)": [
        {
          "params": {
            "archaeologistAddress": "address of publishing archaeologist"
          }
        }
      ],
      "ArchaeologistHasBeenAccused(address,bytes32)": [
        {
          "params": {
            "archaeologistAddress": "Address of accused archaeologist who is attempting to publish their private key",
            "sarcoId": "ID of sarcophagus archaeologist has attempted to publish a key on"
          }
        }
      ],
      "ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)": [
        {
          "params": {
            "archaeologistAddress": "address of publishing archaeologist",
            "privateKey": "privateKey the archaeologist has attempted to publish",
            "publicKey": "publicKey stored for archaeologist on the sarcophagus"
          }
        }
      ],
      "TooEarlyForPublish(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed publish attempt",
            "resurrectionTime": "Time after which the sarcophagus can be resurrected"
          }
        }
      ],
      "TooLateForPublish(uint256,uint256)": [
        {
          "params": {
            "currentTime": "Timestamp of the failed publish attempt",
            "publishDeadline": "Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)"
          }
        }
      ]
    },
    "events": {
      "PublishPrivateKey(bytes32,bytes32)": {
        "params": {
          "privateKey": "private key that has been published",
          "sarcoId": "ID of sarcophagus archaeologist has published the private key on"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "depositFreeBond(uint256)": {
        "params": {
          "amount": "The amount to deposit"
        }
      },
      "publishPrivateKey(bytes32,bytes32)": {
        "params": {
          "privateKey": "The private key the archaeologist is publishing",
          "sarcoId": "The identifier of the sarcophagus to unwrap"
        }
      },
      "registerArchaeologist(string,uint256,uint256,uint256)": {
        "params": {
          "freeBond": "How much bond the archaeologist wants to deposit during the register call (if any)",
          "maximumRewrapInterval": "The longest interval of time from a rewrap time the arch will accept for a resurrection",
          "minimumDiggingFee": "The archaeologist's minimum amount to accept for a digging fee",
          "peerId": "The libp2p identifier for the archaeologist"
        }
      },
      "updateArchaeologist(string,uint256,uint256,uint256)": {
        "params": {
          "maximumRewrapInterval": "The longest interval of time from a rewrap time the arch will accept for a resurrection freeBond How much bond the archaeologist wants to deposit during the update call (if any)",
          "minimumDiggingFee": "The archaeologist's minimum amount to accept for a digging fee",
          "peerId": "The libp2p identifier for the archaeologist"
        }
      },
      "withdrawFreeBond(uint256)": {
        "params": {
          "amount": "The amount to withdraw"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "ArchaeologistAlreadyPublishedPrivateKey(address)": [
        {
          "notice": "Archaeologist has attempted to publish a key for a sarcophagus twice"
        }
      ],
      "ArchaeologistHasBeenAccused(address,bytes32)": [
        {
          "notice": "An archaeologist that has already been successfully accused has attempted to publish their private key"
        }
      ],
      "ArchaeologistPublishedIncorrectPrivateKey(address,bytes,bytes32)": [
        {
          "notice": "Archaeologist has attempted to publish the incorrect private key for a sarcophagus"
        }
      ],
      "TooEarlyForPublish(uint256,uint256)": [
        {
          "notice": "Archaeologist has attempted to publish a key before the resurrection time"
        }
      ],
      "TooLateForPublish(uint256,uint256)": [
        {
          "notice": "Archaeologist has attempted to publish a key after the end of the resurrection window"
        }
      ]
    },
    "events": {
      "PublishPrivateKey(bytes32,bytes32)": {
        "notice": "Emitted when an archaeologist successfully publishes their private key for a sarcophagus"
      }
    },
    "kind": "user",
    "methods": {
      "depositFreeBond(uint256)": {
        "notice": "Deposits an archaeologist's free bond to the contract."
      },
      "publishPrivateKey(bytes32,bytes32)": {
        "notice": "Publishes the private key for which the archaeologist is responsible during the sarcophagus resurrection window. Pays digging fees to the archaeologist and releases their locked bond. Cannot be called on a compromised or buried sarcophagus."
      },
      "registerArchaeologist(string,uint256,uint256,uint256)": {
        "notice": "Registers the archaeologist profile"
      },
      "updateArchaeologist(string,uint256,uint256,uint256)": {
        "notice": "Updates the archaeologist profile"
      },
      "withdrawFreeBond(uint256)": {
        "notice": "Withdraws an archaeologist's free bond from the contract."
      },
      "withdrawReward()": {
        "notice": "Withdraws all rewards from an archaeologist's reward pool"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}